## 📚 Q24. 예외를 어떻게 추적하나요?

### 🎯 개요
안드로이드는 문제를 식별하고 디버깅하는 데 도움이 되는 여러 도구와 기술을 제공합니다.  

### 🛠️ 추적 방식 

#### ⚙️ Logcat을 이용한 예외 로깅
예외가 발생하면 자세한 스택 트레이스를 Logcat에 기록합니다.  
E/AndroidRuntime과 같은 키워드를 사용하여 Logcat 로그를 필터링하여 예외에 집중할 수 있습니다.  

#### try-catch 혹은 Result를 이용한 예외 처리
try-catch 블록을 사용하면 예외를 제어된 방식으로 처리하고  
코드의 중요한 부분에서 앱 크래시를 방지할 수 있습니다.  

```kotlin
try {
    val result = performRiskyOperation()
} catch (e: Exception) {
    Log.e("Error", "Exception occurred: ${e.message}",e)
}
```
Result를 이용하면 onSuccess나 onFailure 콜백을 이용할 수 있음
```kotlin
runCatching {
    performRiskyOperation()
}.onSuccess {

}.onFailure {
    Timber.e("Exception occurred: ${e.message}")
}
```

https://velog.io/@skydoves/retrofit-api-handling-sandwich

#### 전역 예외 핸들러 사용하기
Thread.setDefaultUncaughtExceptionHandler를 설정하여 전역 예외 핸들러를 설정하면  
앱 전체에서 처리되지 않은 예외를 포착하는 데 도움이 됩니다.  
**이는 중앙 집중식 오류 보고 또는 로깅에 특히 유용합니다

class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
            Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}: ${exception.message}", exception)
            // 예외 세부 정보 저장 또는 서드 파티 솔루션으로 전송 (Crashlytics 등)
            // FirebaseCrashlytics.getInstance().recordException(exception)
            // 기존 핸들러 호출 (선택 사항, 시스템 기본 크래시 동작 유지)
            defaultHandler?.uncaughtException(thread, exception)
        }
    }
}

이 접근 방식은 애플리케이션 전체의 런타임 문제를 디버깅하고 모니터링 하는 데 매우 효과적입니다.

#### ⚙️ Firebase Crashlytics 사용하기
Firebase Crasylytics는 프로덕션 환경에서 예외를 추적하는 훌륭한 도구입니다.  
처리되지 않은 예외를 자동으로 기록하고 스택 프레이스, 기기 상태 및 사용자 정보와 함께 자세한 크래시 보고서를 제공합니다.  

#### ⚙️ 브레이크포인트를 이용한 디버깅
Android Studio에서 브레이크포인트를 찍으면 코드 실행을 일시 중지하고 앱 상태를 점진적으로 검사할 수 있습니다.  
변수, 메서드 호출 및 예외 스택 트레이스를 상세하게 탐색할 수 있습니다.  
![break_point](/hegunhee/images/break_point.png)

#### ⚙️ 버그 리포트 캡처하기
버그 리포트를 캡처하면 기기 로그, 스택 트레이스 및 기본 정보를 수집하여 문제를 진한다고 수정하는 데 도움이 됩니다.  

#### 🧠 요약
Logcat은 런타임 로그를 제공, try-catch나 전역 예외 핸들러는 예외가 효과적으로 기록되고 관리되도록 보장합니다.  
Firebase Crashlytics는 프로덕션 환경에서의 크래시 보고 및 디버깅을 위한 강력한 도구입니다.  
브레이크 포인트는 점진적이고 세밀하게 디버깅 경험을 가능하게 합니다.  

#### ❓ 실전 질문
#### Logcat과 Firebase Crashlytics의 차이점은?
Logcat은 개발 환경에서 예외를 확인할 수 있고  
Firebase Crashlytics는 프로덕션 환경에서 예외를 확인할 수 있습니다.  
Crashlytics를 사용하면 예외 내용, 사용 기기, 사용자에 대한 정보도 같이 나오므로  
문제를 파악하기 쉽습니다.  

## 📚 Q24. 빌드 변형과 플레이버란 무엇인가요??

### 🎯 개요
빌드 변형과 플레이버는 단일 코드베이스에서 애플리케이션의 다양한 버전을 생성하는 유연한 방법을 제공합니다.  
예) 프로덕션 빌드, 유료 및 무료 버전

### ⚙️ 빌드 변형 (Build Variants)
빌드 변형은 특정 빌드 타입과 제품 플레이버를 결합한 결과입니다.  
안드로이드 Gradle 플러그인은 각 조합에 대해 빌드 변형을 생성하여 다양한 사용 사례에 맞는 API 또는 번들을 생성할 수 있도록 합니다.  

빌드 타입은 애플리케이션이 어떻게 빌드되는지를 나타내며, 일반적으로 아래 타입을 포함합니다.  

- 디버그(Debug) : 개발 중에 사용되는 빌드 구성입니다. 디버그 도구, 로그 및 테스트용 디버그 툴을 활용
- 릴리즈 : 배포에 최적화된 구성으로, 종종 리소스 최적화와 최소화, 난독화가 적용되고 배포를 위해서는 별도의 릴리즈 키로 서명되어야 합니다.  

기본적으로 모든 안드로이드 프로젝트에는 debug 및 release 빌드 타입이 포함됩니다.  
개발자는 특정 요구사항에 맞게 커스텀 빌드 타입을 추가할 수 있습니다.  

### ⚙️ 제품 플레이버 (Product Flavors)
제품 플레이버를 통해 개발자는 무료 및 유로 버전이나 us 및 en과 같은 지역별 버전과 같이  
앱의 다양한 변형을 정의할 수 있습니다.  
각 플레이버는 애플리케이션 ID, 버전 이름 또는 리소스와 같은 고유한 구성을 가질 수 있습니다.  

```kotlin
// Kotlin DSL (build.gradle.kts)
android {
    // ...
    flavorDimensions += "version"
    
    productFlavors {
        create("free") {
            dimension = "version"
            applicationIdSuffix = ".free"
            versionNameSuffix = "-free"
        }
        
        create("paid") {
            dimension = "version"
            applicationIdSuffix = ".paid"
            versionNameSuffix = "-paid"
        }
    }
}
```
총 4가지의 조합으로 제품 변경에 따른 빌드를 수행할 수 있습니다.  

### ⚙️ 빌드 타입과 플레이버 결합하기
빌드 변형 시스템은 빌드 타입과 제품 플레이버를 결합하여 가능한 빌드 매트릭스를 만듭니다.  
- freeDebug : 디버깅용 무료 버전
- prodRelease : 릴리즈에 최적화된 유료 버전

각 조합은 변형 조건에 따른 설정, 리소스를 가지거나 코드를 다르게 동작시킬 수 있습니다.  
예) 유료 무료에 따른 광고  

### 🛠️ 빌드 변형 및 플레이버 사용의 이점

1. 효율적인 구성  
  프로젝트를 통째로 복제할 필요가 없습니다.  
  단일 코드 베이스에서 여러 빌드를 처리할 수 있습니다.  
2. 커스텀 동작  
  유료 버전에서 프리미엄 기능을 활성화하거나 디버그와 릴리즈 빌드에서  
  각각 다른 API를 사용하는 등 앱의 동작을 맞춤 설정할 수 있습니다.
3. 자동화  
  Gradle은 빌드 변형에 따라 APK 서명, 최적화 및 난독화와 같은 작업을 자동화합니다.  

### 🧠 요약
안드로이드의 빌드 변형은 빌드 타입과 제품 플레이버를 결합하여 맞춤형 앱을 빌드할 수 있도록 합니다.  
빌드 타입은 **앱 빌드 방법**에 대한 구성을 정의하고  
제품 플레이버는 **앱의 변형**을 정의합니다.  
두 가지 개념을 함께 사용하면 단일 코드베이스로 여러 빌드를 처리하여 앱 배포의 효율성과 확장성 또한 보장합니다.  

## 📚 Q26. 접근성을 어떻게 보장하나요?

### 🎯 개요
접근성은 시각, 청각 또는 신체 장애가 있는 사람들을 포함하여 모든 사람이  
애플리케이션을 사용할 수 있도록 보장하는 것입니다.  

### ⚙️ 콘텐츠 설명(Content Descriptions) 활용하기
콘텐츠 설명은 UI 컴포넌트에 텍스트 레이블을 제공하여 TalkBack과 같은 스크린 리더가  
시각 장애가 있는 사용자에게 해당 컴포넌트를 알릴 수 있도록 합니다.  
버튼, 이미지, 아이콘과 같이 상호작용하거나 정보를 제공하는 컴포넌트에 android:contentDescription 속성을 사용합니다.  
null로 설정하거나 View.IMPORTANT_FOR_ACCESSABLE_NO를 사용합니다.  

```xml
<ImageView
  android:contentDescription="사용자 프로필 사진"
  android:src="@drawable/profile_image"
  />
```

### ⚙️ 동적 글꼴 지원하기
앱이 기기 설정에서 사용자가 설정한 글꼴 크기 환경 설정을 존중하도록 보장합니다.  
자동으로 크기가 조정되도록 텍스트 크기에는 sp 단위를 사용합니다.  

### ⚙️ 포커스 관리 및 탐색
특히 커스텀 뷰, 다이얼로그 및 양식의 경우 포커스 동작을 적절하게 관리합니다.  
키보드 및 D-패드 사용자를 위한 논리적인 탐색 경로를 정의하려면 android:nextFocusDown, android:nextFocusUp  
및 관련 속성을 정의합니다.  

### ⚙️ 색상 대비 및 시각적 접근성
저시력 또는 색맹 사용자의 가독성을 향상시키기 위해 텍스트와 배경색 간에 충분한 대비를 제공합니다.  
Android Studio의 Accessibility Scanner와 같은 도구는 앱의 색상 대비를 평가하고 최적화하는 데 도움이 될 수 있습니다.  

### ⚙️ 커스텀 뷰 및 접근성
커스텀 뷰를 만들 때 AccessibilityDelegate를 구현하여 스크린 리더가 커스텀 UI 컴포넌트와 상호 작용하는 방식을 정의할 수 있습니다.  
커스텀 컴포넌트에 의미 있는 설명을 제공하려면 onInitializeAccessibilityNodeInfo() 메서드를 재정의합니다.  

```kotlin
class CustomView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) {
    init {
        importantForAccessibility = IMPORTANT_FOR_ACCESSIBILITY_YES
        isClickable = true
        
        setAccessibilityDelegate(object : AccessibilityDelegate() {
            override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfo) {
                super.onInitializeAccessibilityNodeInfo(host, info)
                info.className = Button::class.java.name
                info.text = "커스텀 구성 요소 설명"
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK)
            }
        })
    }
}
```

### ⚙️ 접근성 테스트하기
Android Studio의 Accessibility Scanner 및 Layout Inspector와 같은 도구를 사용하여 접근성 문제를 식별하고 수정합니다.  
이와 같은 도구는 앱이 보조 기술에 의존하는 사용자에게 앱을 사용 가능하도록 보장하는 데 많은 도움이 됩니다.  

### 🧠 요약
안드로이드 애플리케이션의 접근성을 보장하려면 콘텐츠 설명 제공, sp 단위를 사용한 동적 글꼴 크기 지원, 탐색을 위한 포커스 관리, 적절한 색상 대비 보장, 커스텀 뷰에 대한 접근성 지원 추가하기 등이 포함됩니다.  
또한, 안드로이드에서 제공하는 접근성 관련 도구를 활용하고 철저히 테스트함으로써 모든 사용자에게 포괄적이고 접근 가능한 애플리케이션을 구축할 수 있습니다.

## 📚 27. 안드로이드 파일 시스템이란 무엇인가요?

### 🎯 개요
안드로이드 파일 시스템은 리눅스의 파일 시스템 아키텍처 위에 구축되어  
엄격한 보안 및 권한 모델을 준수하면서 애플리케이션을 위한 비공개 및 공유 저장공간을 제공합니다.  

### ⚙️ 안드로이드 파일 시스템의 주요 구성 요소
안드로이드 파일 시스템은 각각 고유한 목적을 가진 다양한 디렉토리와 파티션으로 구성됩니다.  

- System Partition (/system)  
  안드로이드 프레임워크 라이브러리, 시스템 앱 및  구성 파일들을 포함한 핵심 운영체제에 대한 파일이 들어있습니다.  
  악의적인 수정을 방지하기 위해 읽기 전용입니다.  
- Data Partition (/data)  
  데이터베이스, SharedPreference 및 사용자가 생성한 파일을 포함한 앱 별 데이터가 저장됩니다.  
  각 앱은 /data/data 내에 해당 앱만 접근할 수 있는 비공개 디렉터리를 가지며 보안이 보장됩니다.  
- Cache Partition (/cache)  
  업데이트나 재시작 시 유지할 필요가 없는 캐시된 파일과 같은 임시 데이터 저장에 사용됩니다.  
- External Storage (/sdcard 또는 /storage)  
  여러 앱에서 접근할 수 있는 공유 저장 공간을 주로 제공합니다  
  이미지, 비디오, 문서와 같은 미디어 파일에 자주 사용됨  
- Temporary Files (/tmp)  
  임시 파일을 저장하는 위치입니다. 앱이나 시스템이 재시작될 때 지워집니다.

### ⚙️ 안드로이드에서 파일 접근하기  
프레임워크에서 제공하는 API를 사용하여 파일 시스템과 상호 작용합니다.  
필요한 파일 가시성 및  수명에 따라 앱은 파일을 다른 위치에 저장할 수 있습니다.

- 내부 저장소  
  비공개 저장 공간으로, 해당 앱만 접근할 수 있습니다. 민감하거나 앱별 데이터 저장에 이상적입니다.
- 외부 저장소  
  여러 앱에서 접근할 수 있는 공유 저장 공간으로  
  사용자가 앱 외부에서 접근할 것으로 예상하는 사용자 생성 콘텐츠 또는 미디어를 저장하는 데 사용됩니다.  

### ⚙️ 파일 권한 및 보안
- 비공개 앱 데이터 : 앱이 내부 저장소에 저장된 파일은 비공개이며 해당 앱만 접근할 수 있습니다.  
- 공유 파일 : ContentProvider를 사용하여 외부 저장소에 접근 가능합니다.  
- 범위 지정 저장소 : Android 10에서 도입되었으며, 공유 저장소에 대해 직접 접근을 제한하여 앱이 MediaStore 또는 SAF API를 사용하도록 요구합니다.

## 📚 28. 안드로이드 런타임, Dalvik, Dex 컴파일러란 무엇인가요?

### 🎯 개요
애플리케이션은 고유한 런타임 환경과 런타임 프로세스에 의존합니다.  
런타임과 컴파일러는 중요한 역할을 하며  
앱이 성능, 메모리 효율성 및 안드로이드 기기와의 호환성을 위해 최적화되도록 보장합니다.  

### ⚙️ 안드로이드 런타임  
안드로이드 4.4에서 도입되어 5.0에서는 디폴트로 사용되는 관리형 런타임 환경입니다.  
ART는  Ahead-of-Time (AOT) 컴파일을 사용하여 애플리케이션을 컴파일하며  
앱 설치 중에 바이트코드를 기계 코드로 변환합니다.  
이는 런타임 시 Just-in-Time 컴파일의 필요성을 없애 앱 시작 시간을 단축하고 실행 중 CPU 사용량을 줄입니다.  

ART의 주요 특징은 다음과 같습니다.
- 개선된 성능 : AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄입니다.  
- 가비지 컬렉션 : ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술을 도입했습니다.  
- 디버깅 및 프로파일링 지원 : 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 향상된 도구를 제공합니다.

### ⚙️ Dalvik  
Dalvik은 ART 이전에 안드로이드에서 사용된 런타임  
가상 머신 환경에서 애플리케이션을 실행하도록 설계되었으며  
제한된 메모리와 처리 능력을 위해 최적화되었습니다.  

Dalvik은 Just-in-Time 컴파일을 사용하여 런타임에 바이트 코드를 기계 코드로 변환합니다.  
이 접근 방식은 앱 설치에 필요한 시간은 줄이지만, 즉석 컴파일로 인해 런타임 오버헤드가 증가합니다.  

- 컴팩트한 바이트 코드 : Dalvik은 낮은 메모리 사용량과 빠른 실행을 위해 최적화된 .dex 파일을 사용합니다.  
- 레지스터 기반 VM : Dalvik은 스택 기반이 아닌 레지스터 기반이므로 명령어 효율이 향상됩니다.  

느린 앱 시간과 높은 CPU 사용량과 같은  한계로 ART로 대체되었습니다.  

### ⚙️ Dex 컴파일러
Dex 컴파일러는 Java/Kotlin 컴파일러에서 생성된 Java 바이트코드를  
.dex 파일로 변환합니다.  이러한 .dex 파일은 컴팩트하며 Dalvik 및 ART 런타임 환경에 최적화되어 있습니다.  

Dex 컴파일러는 안드로이드 애플리케이션이 기기에서 효율적으로 실행되도록  
하는 데 중요한 역할을 합니다.
- 멀티덱스 지원  
  64K 메모리 제한을 초과하는 애플리케이션의 경우  
  dex 컴파일러는 바이트코드를 여러 .dex 파일로 분할하는 것을 지원합니다.  
- 바이트코드 최적화  
  컴파일러는 안드로이드 기기에서 더 나은 메모리 사용량과 실행 성능을  
  위해 바이트 코드를 최적화 합니다.  
Dex 컴파일 프로세스는 안드로이드 빌드 시스템에 통합되어 있으며  
앱 개발의 빌드 단계 중에 발생합니다.  


### ⚙️ Dalvik에서 ART로의 전환  

ART의 AOT 컴파일, 개선된 가비지 컬렉션, 프로파일링  
더 나은 개발자 및 사용자 경험을 제공합니다.  

## 📚 29. APK 파일과 AAB 파일의 차이점은 무엇인가요?

### 🎯 개요
두 가지 기본 포맷으로 배포 및 설치할 수 있습니다.  
두 포맷 모두 안드로이드 앱을 패키징하는 역할을 하지만  
목적, 구조 및 설치 중 리소스 처리 방식에서 차이가 있습니다.

### ⚙️ APK (Android Package)
APK 파일은 안드로이드 애플리케이션을 배포하고 설치하는 전통적인 포맷입니다.  
앱이 기기를 작동하는 데 필요한 모든 리소스, 코드 및 메타데이터를 포함하는 완전하고 즉시 설치 가능한 패키지입니다.  

모든 기기구성, 모든 리소스를 포함하여서 사용자의 기기와 관련 없는 리소스를 포함하게 되어 파일 크기가 커질 수 있습니다.  

### ⚙️ AAB (Android App Bundle)
Google에서 도입한 AAB 형식은 APK와 같은 설치 가능한 형식이 아닌 게시 포맷입니다.  
AAB를 구글 플레이에 업로드하면, Google Play는 이를 개별 기기에 맞게 최적화된 APK로 처리합니다.  

AAB 파일은 모듈식으로, 다른 구성에 대한 리소스와 별개로 코드를 별개의 번들로 분리합니다.  
구글 플레이는 이 모듈식 구조를 사용하여 다운로드 시점에 기기별 APK를 생성합니다.  
특정 기기에 맞게 리소스와 코드를 전달하므로 사용자 기기의 앱 크기를 줄입니다.  

AAB 파일은 Google Play의 서버 측에서 처리되므로 직접 설치할 수 없습니다.

### ⚙️ APK와 AAB의 주요 차이점

1. 목적 및 구조  
- APK : 모든 구성에 대한 모든 리소스와 코드를 포함하는 완전한 패키지
- AAB : 기기별 APK를 생성하는 모듈식 게시 형식

2. 파일 크기  
- APK : 모든 기기에 대한 리소스를 포함하여 크기가 더 큽니다.  
- AAB : 더 작고 최적화된 APK를 생성할 수 있게 하여 사용자에게 전달되는 앱 크기를 줄입니다.  

3. 배포  
- APK : 기기에 직접 공유되고 사이드로딩할 수 있습니다.
- AAB : Google Play에 업로드되며, Google Play가 최종 사용자를 위해 최적화된 APK를 생성합니다.

4. 관리
- APK : 개발자가 리소스와 구성을 수동으로 관리해야 합니다.  
- AAB : 구성 관리를 Google Play에 위임하여 프로세스를 자동화합니다.

5. 도구 및 호환성
- APK : 모든 안드로이드 기기 및 앱 스토어에서 지원됩니다.  
- AAB : 설치 가능한 APK를 생성하기 위해 Google Play가 필요합니다 다른것과 호환되지 않습니다.

### 🧠 요약
APK는 전통적인 완전한 패키지 형식으로 모든 리소스를 포함하지만 파일 크기가 크고, AAB는 모듈식 게시 형식으로 Google Play에서 기기별 최적화된 APK를 생성하여 사용자에게 더 작은 앱 크기를 제공합니다.  
APK는 모든 플랫폼에서 지원되지만 AAB는 Google Play 전용이며, 개발자는 APK에서는 수동 관리가 필요하지만 AAB에서는 Google Play가 자동화된 관리를 제공합니다.

## 📚 30. R8 최적화란 무엇인가요?

### 🎯 개요
R8은 안드로이드 빌드 프로세스에서 APK 또는 AAB의 크기를 줄이고 런타임 성능을 향상시키기 위해 사용되는 코드 축소 및 최적화 도구입니다.  
안드로이드 빌드 시스템에 통합되어 이전의 ProGuard 도구를 대체하고, 코드 축소, 최적화, 난독화 및 리소스 관리를 위한 향상된 기능을 제공합니다.

### ⚙️ R8 작동 방식
R8은 빌드 단계 중에 애플리케이션 코드를 수정하여 아래의 목적들을 달성합니다.

- **코드 축소(Shrinking)**: 애플리케이션 코드베이스에서 사용되지 않는 클래스, 메서드, 필드 및 속성을 제거하여 최종적인 APK 또는 AAB 크기를 줄입니다.
- **최적화(Optimization)**: 런타임 성능을 향상시키기 위해 코드를 단순화하고 재구성합니다. 여기에는 메서드 인라이닝(inlining), 중복 코드 제거, 동일한 코드 블록 병합 등이 포함됩니다.
- **난독화(Obfuscation)**: 클래스, 메서드 및 필드의 이름을 변경하여 원래 이름을 모호하게 만들어 리버스 엔지니어링을 더 어렵게 만듭니다.
- **리소스 최적화**: 사용되지 않는 리소스(레이아웃, Drawable, 문자열)를 제거하여 앱 사이즈를 더욱 최소화합니다.

### ⚙️ R8 최적화의 주요 특징

- **죽은 코드 제거(Dead Code Removal)**: R8은 코드베이스를 분석하여 앱에서 도달할 수 없거나 사용되지 않는 코드를 식별하고 제거합니다.
- **인라이닝(Inlining)**: 짧은 메서드나 함수를 호출자쪽에 직접 인라인하여 메서드 호출 오버헤드를 줄이고 런타임 성능을 향상시킵니다.
- **클래스 병합(Class Merging)**: 유사한 클래스나 인터페이스를 하나로 결합하여 메모리 공간을 줄이고 효율성을 향상시킵니다.
- **도달 불가능한 코드 제거(Unreachable Code Elimination)**: 실행되지 않는 코드 경로를 완전히 제거합니다.
- **상수 폴딩 및 전파(Constant Folding and Propagation)**: 표현식을 단순화하고 변수를 가능한 경우 해당 상수 값으로 대체합니다.
- **난독화(Obfuscation)**: R8은 코드의 의미 있는 이름을 더 짧고 덜 설명적인 이름으로 대체하여 앱 크기를 줄이고 리버스 엔지니어링을 더 어렵게 만듭니다.

### ⚙️ R8 구성
R8은 앱 빌드 구성을 위해 ProGuard 규칙을 동일하게 사용합니다.  
코드의 어떤 부분을 축소, 난독화 또는 최적화에서 제외할지 지정할 수 있습니다.

**사용 사례:**
- **리플렉션을 위한 코드 보존**: 리플렉션을 통해 접근하는 클래스나 메서드는 런타임에 해당 패키지 이름을 알아야하기 때문에 ProGuard 규칙에 명시적으로 유지(keep)하여 난독화하지 않도록 합니다.
- **서드파티 라이브러리 제외**: 일부 라이브러리는 내부적으로 리플렉션을 사용할 수도 있고, 정상적인 기능 동작을 위해 특정 규칙이 필요할 수 있습니다.

```kotlin
// 클래스를 난독화하지 않고 보존하기 위한 ProGuard 규칙
-keep class com.example.myapp.MyClass { *; }
```

```kotlin
// build.gradle.kts에서 R8 활성화
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            isShrinkResources = true
        }
    }
}
```

### ⚙️ R8의 장점

- **긴밀한 통합**: R8은 안드로이드 빌드 시스템에 내장되어 있어 일반적인 ProGuard 규칙 외에 추가 설정이 필요하지 않습니다.
- **향상된 효율성**: 축소, 최적화 및 난독화를 단일 패스로 결합하여 ProGuard보다 빠르고 효율적입니다.
- **앱 크기 감소**: 사용되지 않는 코드와 리소스를 제거하여 최종 APK 또는 AAB 크기를 크게 줄입니다.
- **향상된 보안**: 난독화는 해커 및 크래커가 앱을 리버스 엔지니어링하기 어렵게 만들어 보안을 강화합니다.

### ⚙️ R8의 한계

- **과도한 축소 위험**: 제대로 구성하지 않으면 R8이 간접적으로 참조되는 코드나 리소스를 제거하여 런타임 오류를 유발할 수 있습니다.
- **복잡한 구성**: 복잡한 프로젝트, 특히 리플렉션이나 동적 클래스 로딩을 사용하는 프로젝트의 경우 ProGuard 규칙 작성이 복잡하고 까다로울 수 있습니다.
- **디버깅 어려움**: 난독화는 스택 트레이스에 난독화된 이름이 로깅되기 때문에 디버깅을 더 어렵게 만들 수 있습니다.

### 🧠 요약
R8은 최신 안드로이드 개발의 필수 도구로, 포괄적인 코드 사이즈 감량, 최적화 및 난독화 기능을 제공합니다.  
앱 크기를 줄이고 런타임 성능을 향상시키며 보안을 강화함으로써 R8은 개발자가 효율적이고 컴팩트한 애플리케이션을 빌드하는 데 도움을 줍니다.  
필요한 코드가 의도치 않게 제거되는 것을 방지하고 원활한 앱 동작을 보장하려면 ProGuard 규칙을 사용한 올바른 구성이 중요합니다.

### ❓ 실전 질문

#### Q) R8 최적화는 앱 성능을 어떻게 개선하고, APK/AAB 용량을 어떻게 줄이나요?

**성능 개선:**
- **인라이닝**: 메서드 호출 오버헤드 제거로 실행 속도 향상
- **상수 폴딩**: 런타임 계산을 컴파일 타임으로 이동하여 성능 향상
- **클래스 병합**: 메모리 사용량 감소로 GC 부담 감소
- **도달 불가능한 코드 제거**: 불필요한 분기 제거로 실행 경로 최적화

**용량 감소:**
- **죽은 코드 제거**: 사용되지 않는 클래스, 메서드, 필드 완전 제거
- **리소스 최적화**: 사용되지 않는 레이아웃, Drawable, 문자열 제거
- **난독화**: 긴 이름을 짧은 이름으로 변경하여 바이트코드 크기 감소
- **중복 코드 제거**: 동일한 코드 블록 병합으로 중복 제거

#### Q) R8은 ProGuard와 어떻게 다르며, 어떤 추가적인 장점을 제공하나요?

**주요 차이점:**
- **통합성**: R8은 안드로이드 빌드 시스템에 완전히 통합되어 별도 설정 불필요
- **성능**: 단일 패스로 축소, 최적화, 난독화를 동시에 처리하여 ProGuard보다 빠름
- **메모리 효율성**: 더 적은 메모리를 사용하여 대용량 프로젝트에서도 안정적
- **안드로이드 특화**: 안드로이드 플랫폼에 최적화된 최적화 기법 적용

**추가 장점:**
- **향상된 분석**: 더 정확한 코드 분석으로 불필요한 제거 위험 감소
- **빌드 속도**: ProGuard 대비 2-3배 빠른 빌드 속도
- **메모리 사용량**: ProGuard 대비 약 50% 적은 메모리 사용
- **안정성**: 안드로이드 빌드 시스템과의 긴밀한 통합으로 더 안정적인 동작