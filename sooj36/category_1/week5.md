# 📚 안드로이드 스터디 (WEEK 5)

---

### [Q24. 예외(exceptions)를 어떻게 추적하나요?]


 - > [6가지]
		 1. Logcat
		 2. try‑catch 블록
		 3. 전역 예외 핸들러
		 4. Firebase Crashlytics
		 5. 브레이크포인트(BreakPoint) 이용한 디버깅
		 6. 버그 리포트(Bug Report) 캡쳐

1. > **Logcat**
		- 예외 발생 시, 시스템은 예외 유형, 메시지 및 예외가 발생한 코드 줄을 포함하여 자세한 스택 트레이스를 로그캣이 기록.
		- E/AndroidRuntime 과 같은 키워드를 사용하여, Logcat 로그를 필터링하여 예외에 집중 가능.


2. > **try-catch**
		- 해당 블록을 사용하면 예외를 제어된 방식으로 처리하고, 코드의 중요한 부분에서 앱 크래시를 방지
	```
	try {
		val result = performRiskyOperation()
	} catch (e: Exception) {
		Log.e("Error", "Exception occurred: ${e.message}", e) 
		// 스택 트레이스 로깅
	}
	```



3. > **전역 예외 핸들러 사용하기**
		- 앱 전체에서 처리되지 않는 모든 예외를 포착하여, 중앙에서 관리할 수 있음
		- 특히 디버그나 QA 빌드에서 구현하면 예외 추적과 리포팅을 간소화 할 수 있음

```
// 1. 앱 전체의 시작점으로 Application 클래스를 상속받아 만듬

class MyApplication : Application() {

	// 2. 앱이 처음 시작될 때 실행
    override fun onCreate() {
        super.onCreate()
		// 3. 원래 안드로이드 시스템이 사용하던 기본 오류 처리 담당자(핸들러)를 기억해둠
        val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
	    
	    // 4. 이제부터 새로운 오류 처리 담당자를 지정 (안전 그물 같은 역할)
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
	        // 5. 오류가 잡히면, 로그를 남겨 어떤 오류인지 기록
            Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}: ${exception.message}", exception)
            
            // 예외 세부 정보 저장 또는 서드 파티 솔루션으로 전송 (Crashlytics 등)
	            // Firebase Crashlytics 같은 분석 도구로 오류를 보내서 개발자가 볼 수 있게도 할 수 있음
            // FirebaseCrashlytics.getInstance().recordException(exception)
            
            // 기존 핸들러 호출 (선택 사항, 시스템 기본 크래시 동작 유지)
	            // 6. 원래 시스템의 기본 동작(ex. 앱 강제 종료)을 그대로 실행하도록
            defaultHandler?.uncaughtException(thread, exception)
        }
    }
}

```
/

4. > **Firebase Crashlytics 사용하기**

			 -  프로덕션 환경에서 예외를 추적하는 도구
			 - 처리되지 않은 예외를 자동으로 기록하고 스택 트레이스, 기기 상태 및 사용자 정보와 함께 자세한 크래시 보고서를 제공하며, 중요하지 않은 문제에 대해 커스텀 예외를 기록할 수도 있음

			- Firebase와 통합되어 분석 및 해결 추적을 용이하게 함


5.  > **브레이크포인트(Breakpoints)를 이용한 디버깅**
		 - 디버그 모드를 활성화하고 코드에 브레이크포인트를 설정하면, 
		   프로그램 실행이 해당 지점에 도달한 후 멈추게 되면서 개발자는 앱의 내부 상태를 자세히 볼 수 있음
		 
		 - 변수 : 현재 각 변수에 어떤 값이 들어있는 지 확인
		 - 메서드 호출 : 어떤 메서드들이 호출되었는지 추적
		 - 예외 스택 트레이스 : 오류 발생 시 호출 기록 탐색



6. > **버그 리포트(Bug Report) 캡처하기**


| 방법                                  | 설명                                           | 실행 단계                                                                                                                                                                                              |
| ----------------------------------- | -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 개발자 옵션 (기기에서)                       | 스마트폰이나 태블릿에서 직접 버그 리포트를 생성하고 공유하는 방식         | 1. **개발자 옵션**을 활성화<br>2. `설정` → `개발자 옵션` → **`버그 신고`**로 이동<br>3. 신고 유형을 선택하고 생성된 리포트를 공유                                                                                                           |
| 안드로이드 에뮬레이터                         | PC의 안드로이드 에뮬레이터에서 버그를 발견했을 때 사용하는 방법         | 1. 에뮬레이터의 **확장 컨트롤**을 열고<br>2. **`Bug Report`**(버그 신고) 탭을 선택한 다음<br>3. 세부 정보를 입력하고 리포트를 저장                                                                                                         |
| ADB (Android Debug Bridge) терминал | PC와 기기를 연결하여 터미널 명령어로 버그 리포트를 PC에 직접 저장하는 방법 | 1. PC에서 터미널(명령 프롬프트)을 실행<br>2. 아래 명령어 명령<br><br> - **모든 기기:**<br> 터미널에서 <br>adb bugreport /path/to/save/bugreport <br><br> - **특정 기기 지정:**<br> <br>adb ‑s<br><device_serial_number> bugreport<br>` |
|                                     |                                              |                                                                                                                                                                                                    |

/


> [!실전 질문]
> - : Logcat을 사용하여 개발 환경에서 예외를 디버깅하는 것과 Firebase Crashlytics와 같은 도구를 사용하여 프로덕션 환경에서 예외를 처리하는 것의 차이점은 무엇인가요? 
>   또한, Logcat과 같은 로컬 환경에서 추적된 예외랑 프로덕션에서 추적된 예외를 각각 어떻게 해결하시나요?

	 - 문제 해결 방식 차이
		  - Logcat : 디버거를 이용한 즉각적인 원인 분석이 가능
			  - 내 기기에서 즉시 재현 가능
			  - 브레이크포인트
			  - 상태 검사 : 변수 값, 객체 상태 등을 직접 확인하며 원인 파악
			  - 즉시 수정 및 확인
			  /
		  - Firebase Crashlytics : 원인을 추리하여 로컬에서 재현하여 문제 해결
			  - 대시보드에서 통계를 확인하여 영향도 분석 →
			  - 스택 트레이스와 함께 기록된 커스텀 로그나 사용자 정보를 통해 사용자가 어떤 행동을 하다 오류를 겪었는지 추리 →
			  - 수집한 내용을 바탕으로 로컬 환경에서 재현 시도 →
			  -  버그 재현에 성공하면, Logcat과 디버거를 이용하는 단계로 


---

### [Q25. 빌드 변형(build variants)과 플레이버(flavors)란 무엇인가요?]
> **현실적인 문제들 @**
	- 무료 버전과 유료 버전을 따로 프로젝트로 만들어서 코드 중복 관리가 어려운 경우
	- 개발용과 배포용 설정을 매번 수동으로 바꿔가며 빌드
	- 지역별로 다른 서버나 리소스를 사용해야 하는 상황
  /

- **빌드 변형 (Build Variant)**
  - (Build Type) x (Product Flavor) 의 조합으로, 단일 코드베이스에서 다양한 버전의 앱을 효율적으로 생성할 수 있게 한다
  /
  - **'어떻게' 빌드할 것인가 (Build Type)**
    - 앱의 빌드 방식과 패키징 정책 정의
    - 기술적인 목적에 따라 구분
      - 디버그(Debug)
      - 릴리스(Release)
  /
  - **'무엇을' 빌드할 것인가 (Product Flavors)**
	  -  사용자에게 제공될 앱의 '변형'을 정의하며, 주로 비즈니스 로직이나 앱의 기능적 분기에서 사용
    - 플레이버 = '모듈화'의 개념을 활용해서 앱의 버전을 관리하는 기술
	    - 무료/유료 버전(free vs paid)
	    - 지역별 버전( us vs eu )
	    - 각 플레이버는 고유한 구성 보유
		    - 애플리케이션ID, 버전 이름, 리소스 등
-  구현 예시
	
```
android {
    ...
    flavorDimensions += "version" // 플레이버 차원 정의

    productFlavors {
        create("free") {
            dimension = "version"
            applicationIdSuffix = ".free"
            versionNameSuffix = "-free"
        }

        create("paid") {
            dimension = "version"
            applicationIdSuffix = ".paid"
            versionNameSuffix = "-paid"
        }
    }
}

// 이 설정으로 안드로이드 Gradle 플러그인이 자동으로 4가지 조합을 생성
1. freeDebug, 2.freeRelease, 3.paidDebug, 4.paidRelease
```

- > ✨ 빌드 변형의 장점
	- 1. →효율적 구성
		- 프로젝트 통째로 복제할 필요없이, 단일 코드베이스에서 여러 빌드 처리 가능
	- 2. →커스텀 동작
		- 유료 버전에서 프리미엄 기능 활성화
		- 디버그와 릴리스에서 각각 다른 API 사용
		- 플레이버 별로 다른 리소스나 설정 적용
	- 3. →자동화(Gradle이 빌드 변형에 따라 자동 처리)
		- APK 서명, 최적화 , 난독화

/

- > 🚨 주의 사항
- 1. 빌드 타입과 플레이버에 따라 각각 별도의 폴더에 "리소스를 넣으면 Gradle이 자동 병합해줌
	- (ex, 무료 버전에서는 다른 로고를 써야 할 경우 / 디버그용에서는 다른 서버URL 써야 할 경우)
- 2. 리소스 충돌 시 우선순위 고려 필요

	
```
// 예시: 서버 URL 설정
main/: "https://api.example.com"      (기본)
debug/: "https://dev.example.com"     (개발서버)  
free/: "https://free.example.com"     (무료버전 서버)

// freeDebug 빌드하면?
// → debug가 더 높은 우선순위라서 "https://dev.example.com" 사용!

```
- 3. 과도하게 복잡한 플레이버 구조는 관리 어려우므로 빌드 시점에 결정되는 핵심적인 것만 플레이버로.
  그 외 것(사용자가 바꿀 수 있는 것들)은 런타임 설정으로 처리 할 것



---

### [Q26. 접근성(accessibility)을 어떻게 보장하나요?]

- > 핵심 구현 방법 6가지
	- 1. 콘텐츠 설명 (Content Descriptions)
	  ![[Pasted image 20250804174645.png]]
	- 2. 동적 글꼴 크기 지원
	  ![[Pasted image 20250804174729.png]]
	- 3. 포커스 관리
	  ![[Pasted image 20250804174757.png]]
	- 4. 색상 대비
		-  텍스트와 배경 간 대비를 확보해 색맹 사용자를 위한 색상 조합 고려
	- 5. 커스텀 뷰 접근성
		- 기본 뷰들은 안드로이드가 자동으로 접근성을 제공하지만, 커스텀 뷰는 개발자가 직접  AccessibilityDelegate를 통해 정보를 제공해야 한다.
		- 구현 후, 테스트를 통해 사용 가능한 접근성인지 확인 필요
	  ![[Pasted image 20250804175205.png]]
	- 6. 접근성 테스트 (Layout Inspector, Accessibility Scanner, TalkBack)

/

> [!실전 질문 1]
> - : 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 무엇이고, 텍
> 스트 크기에 dp 단위보다 sp 단위를 사용하는 것이 선호되는 이유는
> 무엇인가요?

- sp 단위 사용 / 고정 크기 피하기 / 접근성 테스트
- sp 선호 이유
	- 1. 사용자 접근성 설정 자동 반영
		- 사용자가 큰 글꼴 선택 시 
		  sp는 자동으로 16sp → 20sp 정도로 확대되지만, dp는 고정 값
	- 2. 기본 값이 dp와 동일해 기존 디자인에 영향 X
	- 3. 표준 및 정책 준수(WCAG(웹 콘텐츠 접근성 가이드라인 준수)

오토레이아웃 써서 자동 글꼴 적용

---

### [Q27. 안드로이드 파일 시스템이란 무엇인가요?]

-  >  안드로이드 기기에서 '**데이터 저장을 관리하고 구성'하는 구조화**된 환경.
-  > **특징** :
	-  리눅스 파일 시스템 아키텍처 기반
	-  엄격한 보안 및 권한 모델 적용
	-  애플리케이션별 샌드박스 제공
		- 안드로이드는 각 앱을 격리된 환경에서 실행하여 보안을 보장
	-  비공개 저장소와 공유 저장소 분리

				 위와 같은 특징(샌드박스 모델)으로 앱이 서로의 비공개 데이터에 접근할 수 없도록 보장된 메커니즘을 가짐

- > **5가지 구성 요소**
	- ● System Partition (/system)
		- 역할: 핵심 운영체제 파일 저장 
		- 포함 내용: 
			- 안드로이드 프레임워크 라이브러리 
			- 시스템 앱 
			- 구성 파일 
		- 특징: 읽기 전용 (우발적/악의적 수정 방지)
		/
	- ● Data Partition (/data)
		- 역할: 앱별 데이터 저장
		- 포함 내용: 
			- 데이터베이스 
			- SharedPreferences 
			- 사용자가 생성한 파일
		- 구조: `/data/data/[패키지명]/` 형태로 앱별 격리
		/
	- ● Cache Partition (/cache)
		- 역할: 임시 데이터 저장
		- 특징
			-  시스템 업데이트 시 사용
			-  기기 재시작 시 삭제될 수 있음
			-  유지할 필요 없는 캐시 파일들 보관
		/
	- ● External Storage (/sdcard, /storage)
		- 역할: 공유 저장 공간 제공
		- 용도:
			- 이미지, 비디오, 문서 등 미디어 파일
			- 여러 앱에서 접근 가능한 데이터
		- 형태: 내부 저장소 또는 이동식 SD 카드
		/
	- ● Temporary Files (/tmp)
		- 역할: 앱 실행 중 임시 파일
		- 특징: 앱/시스템 재시작 시 자동 삭제

| 구성 요소 | 용도 | 접근성 |

|----------|------|--------|

| **System** (`/system`) | OS 핵심 파일 | 읽기 전용 |

| **Data** (`/data`) | 앱별 개인 데이터 | 해당 앱만 |

| **External** (`/sdcard`) | 공유 미디어 파일 | 권한 기반 |

| **Cache** (`/cache`) | 임시 파일 | 시스템 관리 |

/

> **안드로이드에서 파일 접근하기**
> 		-  애플리케이션은 안드로이드 프레임워크 API를 통해 파일 시스템과 상호 작용
	▼ 저장 위치 결정 기준
	- 파일 가시성 (누가 볼 수 있는지)
	- 파일 수명(언제까지 보관할 것인지)

| 구분        | 내부 저장소     | 외부 저장소                   |
| --------- | ---------- | ------------------------ |
| **위치**    | 앱 샌드박스 내부  | 공유 공간 (/sdcard, storage) |
| **접근 권한** | 해당 앱만      | 여러 앱 가능                  |
| **용도**    | 민감한 데이터    | 미디어, 문서                  |
| **예시**    | 로그인 정보, DB | 사진, 동영상, 음악              |
| **앱 삭제시** | 함께 삭제      | 유지됨(앱에서 저장된 건 삭제됌)       |

/

> **보안 및 권한 관리**
> 1. 비공개 앱 데이터 보호
> 	-내부 저장소 = 완전 격리
> 		 해당 앱만 접근 가능하며 다른 앱은 물리적 접근 불가
> 		 
> 	/
> 2. 공유 파일 관리
> 	- 앱 간 파일 공유 방법 : 
> 		- ① 외부 저장소 사용 
> 		- ② ContentProvider 활용
> 			- 더 안전한 방식으로, 앱이 다른 앱에게 특정 데이터에 대한 **권한 기반 접근** 허용하는 메커니즘
> 
>	/
>3. Scoped Storage
>	- Android 10+ 강화된 보안 정책
>		- 직접 파일 경로 접근 차단
>			- 기존에는 `/sdcard/Pictures/photo.jpg` 식으로 직접 경로를 입력해서 파일에 접근할 수 있었지만 이제는 불가능
>		- MediaStore API 사용 강제
>			- 미디어 파일에 접근하려면 반드시 안드로이드가 제공하는 정해진 API 통해서만 가능
>		- SAF(Storage Access Framework) 활용
>			- 사용자가 직접 어떤 파일에 접근 허용할지 선택할 수 있게 하는 시스템


/ 참고 링크
https://developer.android.com/identity/data/autobackup?hl=ko


/안드로이드 키오스크로 넘어가면 관리가 달라짐
- 
-
---

### [Q28. 안드로이드 런타임(ART), Dalvik, Dex 컴파일러란 무엇인가요?]

> 안드로이드 애플리케이션은 기기에서 실행되기 위해 고유한 런타임 환경과 컴파일 프로세스에 의존
> 아래 3가지는 앱의 성능, 메모리 효율성 및 안드로이드 기기와의 호환성을 위해 최적화되도록 보장

/

> **안드로이드 런타임 (ART)**
	- 안드로이드 5.0 롤리팝 버전부터 기본 런타임으로 채택
	- 기존 Dalvik 을 대체하면서 앱 실행 환경에 큰 개선을 가져옴
			- AOT (Ahead-of-Time) 컴파일


- AOT 의 3가지 주요 특징
	- 1. 개선된 성능
		- AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄여줌
	- 2. GC
		- ART는 더 나은 메모리 관리를 위해 개선된 가비지 컬렉션 기술 도움
	- 3. 디버깅 및 프로파일링 지원
		- ART는 개발자를 위해 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 도구 제공

/
>**Dalvik**
	- ART 이전 안드로이드에서 사용된 런타임
	- JIT(Just In Time) 컴파일을 사용하여, 런타임에 바이트 코드를 기계 코드로 변환
	- 이 접근 방식은 앱 설치에 필요한 시간은 줄이지만, 즉석 컴파일로 런타임 오버헤드 증가

- 주요 특징
	- 컴팩트한 바이트코드 : 낮은 메모리 사용량과 빠른 실행을 위해 .dex 파일 사용
	- 레지스터 기반 VM : 스택 기간이 아닌 레지스터 기반이므로 명령어 효율성 향상


/
> **Dex 컴파일러**
	- Java/Kotlin 컴파일러에서 생성된 Java 바이트코드를 .dex (Dalvik Executable) 파일로 변환

- 주요 측면
	- 1. 멀티덱스 지원 : 64K 메서드 제한을 초과하는 애플리케이션의 경우, 
		  바이트코드를 여러 .dex 파일로 분할하는 것을 지원
			- dalvik 설계될 당시, 이 .dex 파일 하나가 참조할 수 있는 메소드의 총 개수가 65,536개(64k)로 제한되어있었음
		  안드로이드 생태계가 성장하며 앱 기능이 고도화되고 라이브러리 사용이 증가하며 .dex 파일 하나에 담을 수 없게 됨
		  
	- 2. 바이트코드 최적화 


---

### [Q29. APK 파일과 AAB 파일의 차이점은 무엇인가요?]

>  AAB 포맷은 구글 플레이가 사용자 기기에 필요한 리소스만 담아 최적화된 APK를 생성하게 하므로,
>  모든 리소스를 포함하는 기존 APK 방식보다 앱 용량을 줄이는 장점
>  

> **APK(Android Package)**
>  안드로이드 앱을 배포하고 설치하는 전통적인 포맷으로, 앱 실행 설치에 필요한 모든 것을 하나로 묶어놓은 설치패키지
> 
> 	- 모든 종류의 스마트폰과 태블릿을 위한 부품들이 전부 포함
> 	  ex. 저해상도 폰을 위한 이미지부터 고해상도 태블릿용 이미지 및 모든 지원 언어 리소스 등 
> 	  
> 	- 따라 테스트 빌드하거나 스토어 외부에서 앱을 배포해야 할 때 이 APK파일을 직접 공유해서 바로 설치 할 수 있었지만, 
> 	  불필요한 리소스 때문에 앱 전체 파일 크기가 커지는 문제


> **AAB(Android App Bundle)**
> 	- 모듈식 구조
> 	- 앱의 코드는 물론, 화면 크기별 이미지, CPU 아키텍처별 라이브러리 등 모든 리소스가 각각의 모듈, '부품'처럼 분리되어 있음
> 	- 구글 플레이는 사용자의 기기 정보를 확인하고, 그 기기에 필요한 부품만 골라 최적화된 APK 생성하여 전달

---

### [Q30. R8 최적화란 무엇인가요?]

> **사용하지 않는 코드와 리소스를 제거하고 → (축소), 
> 코드를 재구성하며 → (최적화), 
> 이름을 변경하여 → (난독화)
>  최종 앱의 크기는 줄이고, 런타임 성능은 향상시키는 도구**


> 작동 방식
> 	1. 코드 축소
> 	2. 최적화
> 	3. 난독화
> 	4. 리소스 최적화


> 주요 특징
> 	1. 죽은 코드 제거
> 	2. 인라이닝
> 	3. 클래스 병합
> 	4. 도달 불가능한 코드 제거
> 	5. 상수 폴딩 및 전파
> 	6. 난독화


> 구성
> 	1. 리플렉션을 위한 코드 보존
> 	2. 서드파티 라이브러리 제외

> 장점과 한계

- **실전 질문 1**: Q) R8 최적화는 앱 성능을 어떻게 개선하고, APK/AAB 용량을 어떻게
줄이나요?

- **실전 질문 2**: Q) R8은 ProGuard와 어떻게 다르며, 어떤 추가적인 장점을 제공하나
요?
