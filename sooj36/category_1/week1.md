# Q) 0. 안드로이드란 무엇인가요?

### <실전 질문>

**Q) 안드로이드 플랫폼 아키텍처는 Linux Kernel, Android Runtime
(ART), Hardware Abstraction Layer (HAL) 등 여러 계층으로 구성
됩니다. 이 구성 요소들이 애플리케이션 실행과 하드웨어와의 상호
작용을 위해 어떻게 작동하는지 설명해 주세요.**

### 1. 애플리케이션 실행 과정(앱을 터치하여 앱이 실행되는 과정)

## 첫 번째 : 개발 & 빌드 단계

1. 개발자가 Kotlin/Java 코드 작성 → 바이트코드(.dex)로 컴파일

## 두 번째 : 실행 요청 처리 단계

1. 사용자가 앱 아이콘 터치
2. **Android Framework의 ActivityManager**가 앱 실행 요청을 받음
3. **시스템이 앱 정보를 확인**하고 필요한 권한 검증(ex. 카메라 앱 -> 카메라 권한 확인, 위치 앱 -> 위치 권한 확인)

## 세 번째 : 런타임 실행 단계

1. *Android Runtime (ART)**이이 .dex 바이트코드를 받아 처리
    - **AOT 컴파일**: 설치 시 미리 기계 코드로 변환 (빠른 실행)
    - **JIT 컴파일**: 실행 중 자주 사용되는 코드를 동적 최적화
2. 동시에 **Core Libraries**가 데이터 구조, 파일 조작, 스레딩 등 필수 API 제공

## 네 번째 : 시스템 기반 관리 단계

1. **Linux Kernel**이 전체 과정의 기반 제공
    - **메모리 및 프로세스 관리**합니다. 앱이 사용할 메모리를 할당하고, 다른 앱들과 충돌하지 않도록 관리리
    - **보안 강화** (각 앱을 샌드박스라는 격리된 환경에서 실행시켜 서로 간섭하지 못하게 함)
    - **시스템 리소스 할당 및 제어**하여 CPU, 메모리, 배터리 등을 효율적으로 분배

### 2. 하드웨어와의 상호작용 과정(ex.앱에서 카메라 켜는 상황)

- 하드웨어 사용은 **HAL(하드웨어 추상화 계층)**과 리눅스 커널의 협업이 핵심
- 1단계 : Apps
    - 사용자가 카메라 앱에서 카메라 켜기 버튼 터치 -> 앱이 카메라 API 호출
- 2단계 : Android Framework
    - Camera Manager가 요청을 받고, Camera Service가 권한 검사 및 처리
    - Binder IPC로 시스템 서비스와 통신
- 3단계 : Native Libraries
    - C/C++ 라이브러리 호출
    - 카메라 관련 성능 집약적 작업 처리
- 4단계 : Android Runtime
    - ART가 필요한 바이트코드 실행 관리
    - 메모리 및 프로세스 최적화
- 5단계 : HAL/HDL
    - 표준 인터페이스로 하드웨어 제조사별 차이를 해결하고, Framework 명령을 하드웨어별 신호로 변환
- 6단계 : Linux Kernel
    - 카메라 드라이버가 HAL 명령을 받으면 실세 카메라 하드웨어 리스소 제어하며 카메라 센서와 렌즈 작동

---

# Q1) Intent 란 무엇인가요

### <실전 질문>

**Q) 명시적 인텐트와 암시적 인텐트의 차이점 및 각각 어떤 시나리오에 사용하는지 ?**

- '제어권'을 누가 가지는지
즉, 통신할 대상 컴포넌트를 직접 지정하는지 여부에 따라 구분
1. 명시적 인텐트
- 호출할 컴포넌트의 클래스 이름을 직접 지정하여 호출 대상을 명확히 함
- 시나리오 : 페이지 화면 전환
1. 암시적 인텐트
- 수행할 일반적인 작업(Action)을 선언.
안드로이드 시스템이 수행할 적절한 앱을 찾아서 실행
- 시나리오 : 다른 앱의 기능을 활용 시(ex. 브라우저 열기, 콘텐츠 공유)

**Q) 안드로이드 시스템에서 암시적 인텐트를 처리할 앱을 어떻게 결정하며, 적합한 애플리케이션을 찾지 못하면 어떻게 되는지?**

1. [결정 방식]
- 액션, 카테고리, 데이터 같은 속성을 확인 후, AndroidManifest.xml 파일에 선언된 intent filter와 이 속성들을 비교.
시스템은 인텐트의 속성과 일치하는 인텐트 필터를 가진 컴포넌트를 찾아 실행.
1. [인텐트를 처리할 앱을 찾지 못한 경우] startActivity()호출할 때 시스템은 ActivityNotFoundException 을 발생시키며 앱이 비정상 종료

그럴 때, startActivity()를 호출하기 전에, PackageManager의 resolveActivity()를 통해 이 인텐트를 처리할 앱이 최소 하나라도 있는지 확인하는 코드를 추가하는걸 지향
[ 참고 링크 : https://developer.android.com/guide/components/intents-common?hl=ko ]

### Tips) Intent Filters 란

- 어떤 종류의 암시적 인텐트에 응답할 수 있는지 시스템에 알려주는 선언
- 암시적 인텐트라는 막연한 요청에 응답하기 위해, 내 앱 컴포넌트가 어떤 일을 할 수 있는지 시스템에 공식적으로 등록하는 명세서같은 역할
- AndroidManifest.xml 에 등록
- 그림 설명 : Activity A와 B가 서로의 존재를 모르지만, Intent라는 요청서와 Intent Filter 라는 간판과 이를 연결해주는 안드로이드 시스템으로 협업 가능

---

# Q2) PendingIntent의 목적은 무엇인가요?

### <실전 질문>

**1. PendingIntent란 무엇이며 일반 Intent와 어떻게 다른가요? 사용이 필요한 시나리오는?**

- 미래의 특정 시점에 다른 앱이나 시스템 컴포넌트가 앱의 권한을 가지고 미리 정의된 Intent를 실행할 수 있도록 하는 위임장
- 차이점 : 실행의 '주체'와 '시점'
일반 Intent는 제어권을 넘겨주는 반면,
Pending Intent는 제어권 없이 실행 방아쇠만 넘겨주는 것이라 안전하기에 알림이나 알람 등 내 앱의 프로세스를 벗어나 다른 시스템 컴포넌트와 통신할 때 Pending Intent를 사용해야 함.
    - 왜 제어권 없이 넘겨 줄 수 있는지 ?
    PendingIntent는 실제 Intent를 한번 감싼 객체이기 때문에 전달 받은 시스템 컴포넌트는 원본 Intent를 바꿀 수 없고, 실행만 가능.
    보안을 위해 FLAG_IMMUTABLE 플래그를 사용하여 악의적이 앱이 기본 Intent를 수정하는 것을 방지해야 함.
- 시나리오 : 앱이 현재 실행 중이 아닐 때도 어떤 동작이 트리거 되어야 하는 경우 필수(ex. 알림, 알람, 앱 위젯)