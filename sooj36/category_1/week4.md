***
## Q17. Bundle의 사용 목적에 대해서 설명해 주세요.

- Bundle은 컴포넌트 간의 데이터를 전달하는 데 사용되는 키-값 쌍 데이터 구조로
일반적으로 앱 내에서 작은 용량의 데이터를 효율적으로 전송하는 데 사용

가볍고 안드로이드 운영 체제가 쉽게 관리하고 전송할 수 있는 형식으로 데이터를 직렬화하도록 설계되었음
```
##### Bundle 일반적인 사용 사례
- [(1). Activity 간 데이터 전달]
    ▷ 새 Activity 시작 시, Intent에 Bundle 담아서 대상 Activity에 데이터 전달할 수 있음

- [(2). Fragment 간 데이터 전달]
    ▷ Fragment 트랜잭션에서 Bundle은 setArguments() 및 getArguments()와 함께 전달되어 Fragment 간에 데이터를 보냄

- [(3). 인스턴스 상태 저장 및 복원]
    ▷ Bundle은 onSaveInstanceState() 및 onRestoreInstanceState()와 같은 생명주기 메서드에서 구성 변경 중에 임시 UI 상태를 저장하고 복원하는 데 사용

- [(4). Service에 데이터 전달]
    ▷ Service를 시작하거나 바인딩된 Service에 데이터를 전달할 때 Bundle을 통해 데이터 운반할 수 있음
```

### 실전 질문: 구성 변경 중 **onSaveInstanceState()는 UI 상태를 보존**하기 위해 Bundle을 어떻게 활용하며, Bundle에 어떤 유형의 데이터를 담을 수 있나요?
▷ 

***
## Q18. Activity 또는 Fragment 간에 데이터를 어떻게 전달하나요?
▷ Activity => Intent를 사용하여 PutExtra()로 데이터를 추가하고, 받는 쪽에서 getIntent()로 값을 가져옴

▷ Fragment =>
    (1). Bundle : argument 속성을 통해 Bundle에 데이터를 담아 전달
    (2). Jetpack Navigation : 타입 세이프(type-safe)방식으로 안전하게 인수 전달
    (3). Shared ViewModel : 동일한 Activity 내의 여러 Fragment 간의 데이터를 공유할 때 사용하며, 안드로이드 공식 문서에서도 권장하는 방식 중 하나
    (4). Fragment Result API : Fragment가 서로 직접 참조할 필요 없이 일회성으로 값을 전달할 때 사용

### 실전 질문: 동일한 Activity 내에서 Fragment 간 데이터를 주고받을 때 어떤 방법이 효과적인지 설명해 주시고, ViewModel을 활용한다면 Bundle이나 직접적인 Fragment 트랜잭션을 사용하는 것과 비교했을 때 어떤 이점이 있나요?
▷ Bundle이나 직접적인 Fragment 트랜잭션과 비교했을 때 Shared ViewModel을 사용하면
    ▶ (1) 의존성 분리(느슨한 결합)
        = Fragment 끼리 서로 직접 참조할 필요 없이, 공유된 ViewModel을 통해 통신하여 Fragment 간의 의존성이 생기는 것을 피할 수 있음

        반면, Bundle 사용 시 한 Fragment가 다른 Fragment로 데이터 직접 전달해야 함

    ▶ (2) 생명주기 인식 및 반응형 데이터 처리
        = Shared ViewModel을 사용하면, 데이터가 변경될 때마다 각 Fragment가 자신의 생명주기에 따라 안전하게 데이터를 수신하고 UI를 업데이트 할 수 있음

### Pro Tips for Mastery: Fragment Result API
▷ Fragment들이 서로를 직접 참조하지 않고도 **일회성으로 값을 전달**해야 할 때 사용.
ex. QR코드를 스캔하는 Fragment가 스캔된 데이터를 이전 Fragment로 다시 보내야 하는 상황에서 사용할 수 있음

    ▶ 작동 방식 : 
        이 API는 FragmentManager를 통해 작동하며, 데이터를 주고받기 위해 고유한 requestKey와 Bundle을 사용
            1. 결과 받기(수신자 Fragment A) : 먼저 결과를 받을 Fragment에서 parentFragment.setFragmentResultListener()를 사용해 리스너 등록 후, 이 리스너는 Fragment가 STARTED 상태가 되면 결과를 받게 됨

            2. 결과 보내기 (송신자 Fragment B) : 결과를 보내는 Fragment에서는 parentFragmentManager.setFragmentResult()를 호출하여 동일한 requestKey로 데이터를 전달함

***
## Q19. 화면 회전과 같은 구성 변경이 발생하면 Activity에 어떤 변화가 생기나요?
▷
- **Activity 종료 및 재시작** 
    => Activity를 종료(onDestroy())하고, 다시 시작(onCreate()) 됨
        이 과정에서 onPause(), onStop(), onDestroy()가 순서대로 호출

- **리소스 다시 로드**
    => 시스템은 변경된 구성에 맞게 리소스 다시 로드

- **데이터 손실 방지**
    => 개발자는 데이터 손실을 막기 위해 onSaveInstanceState()를 사용하거나 ViewModel을 활용하여 UI상태 저장하고 복원할 수 있음

▷ 재생성을 유발하는 구성 변경에는 
    1. 화면 변경, 2. 다크/라이트 테마 변경, 3. 글꼴 크기 변경, 4. 언어 변경

▷ **Activity 재생성 피하기 위해서**
    즉, 다시 시작하지 않고 구성 변경을 처리하려면 Manifest 파일에서 android:configChanges 속성을 추가하면 되는데
    ▶ 해당 방식은 변경 사항을 개발자가 수동적으로 처리하는 형태로 책임을 개발자에게 위임한다.

### 실전 질문: 구성 변경으로 인한 Activity 재생성 중 발생하는 데이터 손실을 어떻게 복원 및 보존할 수 있으며, UI 상태를 어떻게 복구시키는지 설명해 주세요.
    ▷ (1). 가장 기본적인 방법으로 onSaveInstanceState() 콜백 활용하는 것으로, 안드로이드 시스템은 구성 변경으로 Activity를 소멸시키기 직전에 이 메소드를 호출하여 UI상태를 저장할 기회를 준다.
        - [데이터 보존] : onSaveInstanceState() 메소드가 호출될 때, 파라미터로 넘어온 Bundle 객체에 보존하고 싶은 데이터를 키-값 쌍으로 저장한다
        
        - [데이터 복원] : Activity가 다시 생성될 때, 시스템은 데이터가 저장된 Bundle을 onCreate() 메소드의 파라미터(savedInstanceState)로 전달한다.
        개발자는 이 Bundle이 null이 아닌지 확인하고, getString()과 같은 메소드를 사용해 저장했더 데이터를 꺼내 UI에 다시 설정함으로써 상태를 복구할 수 있다.

    ▷ (2). ViewModel 활용
    구성변경과 같은 UI 컨트롤러의 생명주기를 넘어서도 데이터를 유지하도록 설계되어 있다.
    따라서 화면이 회전되어도 ViewModel 인스턴스는 소멸되지 않고 그대로 유지되므로, 복잡한 UI 데이터를 더 쉽고 효율적으로 보존할 수 있다.

***
## Q20. ActivityManager란 무엇인가요?
▷ 기기에서 실행중인 Activity, Task, Process에 대한 정보를 제공하고 관리하는 안드로이드 시스템 서비스로 개발자는 이를 통해 앱 생명주기, 메모리 사용량, 태스크 관리 등을 제어할 수 있다.

    ▶ 주요 기능
        1. **태스크 및 Activity 정보 제공**
            = 실행 중인 태스크나 Activity의 스택 상태 등을 추적할 수 있어, 앱 동작 및 시스템 리소스 사용량을 모니터링하는 데 도움

        2. **메모리 관리**
            = 앱의 메모리 소비량 및 시스템 전체의 메모리 상태에 대한 정보를 제공

        3. **앱 프로세스 관리**
            = 실행 중인 앱 프로세스나 서비스에 대한 정보를 조회할 수 있어,  앱 상태를 감지하거나 프로세스 수준의 변화에 응답할 수 있음

        4. **디버깅 및 진단**
            = 힙 덤프를 생성하거나 앱을 프로파일링하는 등 디버깅을 위한 도구를 제공

### 실전 질문: ActivityManager.getMemoryInfo()를 어떻게 앱 성능 최적화에 활용할 수 있으며, 시스템이 메모리 부족 상태에 들어가면 개발자는 어떤 조치를 취해야 하나요?
    1. 위 메소드를 호출하면, 시스템의 상시 메모리 정보를 얻을 수 있다. 여기에는 사용 가능한 메모리, 임계 메모리, 그리고 기기가 메모리 부족 상태인지 여부 등이 포함된다.

    2. 개발자는 이 정보들을 활용해 앱의 동작 상태를 최적화할 수 있다.
        예를 들어, 주기적으로 lowMemory 상태를 확인하여 시스템의 메모리가 부족해지기 시작하는 시점을 감지하고, 이에 맞춰 앱의 리소스 사용량을 조절하는 등 선제적인 대응이 가능하다.

    3. 메모리 부족 상태 시 개발자는 앱의 동작을 최적화해야 한다.
        ActivityManager의 기능 중 하나로 killBackgroundProcess()가 있는데, 이 메소드는 시스템 리소스를 확보하기 위해 지정된 앱의 백그라운드 프로세스를 종료시키는 역할을 한다. 따라서 메모리 부족 상황에서 시스템 자원을 확보하기 위한 조치 중 하나로 활용할 수 있다.

***
## Q21. SparseArray를 사용하면 어떤 이점이 있나요?
    ▷ [정의] SparseArray는 안드로이드 util 패키지에 포함된 데이터 구조로, 정수 키를 객체 값에 매핑하는 역할을 한다. 이는 Java나 Kotlin의 HashMap과 유사하지만, 정수 키를 사용하도록 특별히 최적화되어 있어 메모리 관리 측면에서 더 효율적이다.

    ▷ [주요 이점 : 메모리 효율성]
        1. AutoBoxing 방지 : HashMap<Integer, Object>는 기본 타입인 Int를 Integer 객체로 변환하는 '오토박싱' 과정에서 오버헤드가 발생한다. 하지만 SparseArray는 int 키로 직접 작동하여 이러한 메모리 및 계산 작업을 절약한다.

        2. 메모리 절약 : HashMap은 데이터를 저장하기 위해 여러 Entry 객체를 생성한다.
                        반면 SparseArray는 내부적으로 두 개의 배열을 사용하여 키와 값을 직접 저장하므로, 차지하는 메모리 공간이 훨씬 적다.

    ▷ [한계점]
        1. 성능 트레이드오프 : 요소에 접근할 때 키 조회를 위해 이진 탐색을 사용한다. 이로 인해 데이터셋이 매우 커지면, 평균적으로 더 빠른 HashMap보다 성능이 느려질 수 있다.

        2. 정수 키만 사용 가능 : 정수 키로 제한되어 있어, 다른 타입의 키가 필요한 경우 사용 불가

        3. Null 키 사용 불가 : 키 값이 기본 정수를 사용하므로 null 허용하지 않는다.

### 실전 질문: HashMap 대신 SparseArray를 사용하는 것이 어떤 시나리오에서 더 효율적이며, 성능 및 사용성 측면에서 트레이드오프(장단점)는 무엇인가요?
▷ SparseArray는 키(key)가 정수(integer)이고, 메모리 효율성이 중요할 때, HashMap보다 더 효율적. (부가 설명의 위의 주요 이점에서 설명)

***
## Q22. 런타임 권한(runtime permissions)을 어떻게 처리하나요?
▷ 안드로이드 6.0(API 레벨 23)부터는 사용자의 개인정보 보호를 위해, 설치 시가 아닌 앱 실행 중에 위험 권한(dangerous permissions)을 사용자에게 직접 요청해야 한다.

▷ [권한 처리 과정]
    1. 권한 선언 및 확인 
        : 먼저 AndroidManifest.xml 파일에 필요한 권한을 선언한 뒤, 권한이 필요한 기능을 사용하기 전에 ContextCompat.checkSelfPermission()를 사용해 권한이 부여되었는지 확인한다.

    2. 권한 요청
        : 권한이 없다면, ActivityResultLauncher API를 사용해 사용자에게 권한을 요청하고 시스템이 사용자에게 권한 허용/거부 다이얼로그를 보여준다.

    3. 요청 근거 제공
        : 만약 사용자가 이전에 권한 요청을 거부한 적이 있다면,
            shouldShowRequestPermissionRationale()을 통해 확인하고, 왜 이 권한이 필요한지 UI로 설명해주는 것이 좋다.

    4. 권한 거부 처리
        : 사용자가 권한을 영구적으로 거부한 경우, 앱은 더 이상 권한 요청을 할 수가 없게 된다. 이때는 기능이 제한됨을 알리고, 사용자를 직접 시스템 설정 화면으로 안내하여 권한을 켜도록 유도해야 한다.

### 실전 질문: 안드로이드의 런타임 권한 시스템은 사용자 개인 정보를 어떻게 보호하며, 민감한 권한을 요청하기 전에 앱은 어떤 시나리오를 고려해야 하나요?
▷ 런타임 권한 시스템의 핵심은 **사용자에게 데이터 접근 제어권을 직접 부여** 하는 것
    1. [필요 시점 권한 부여]  과거에는 앱을 설치할 때 모든 권한을 한꺼번에 동의해야 했지만, 런타임 권한 시스템에서는 앱이 실제로 해당 권한이 필요한 기능을 사용하려 할 순간에 사용자에게 권한을 요청한다.

    2. [일회성 권한] 안드로이드 11부터는 위치,카메라,마이크 같은 민감한 정보에 대해 '일회성 권한'을 부여할 수 있다. 사용자가 이 옵션을 선택하면, 앱을 사용하는 동안 임시로 접근 권한이 부여되고, 앱을 종료하면 권한 사라져 강력한 보호를 제공한다.
***
## Q23. Looper, Handler, HandlerThread의 역할은 무엇인가요?
▷ 안드로이드에서 스레드를 관리하고 비동기 통신을 처리하기 위해 작동하는 필수 컴포넌트
    1. [Looper] : 스레드의 메시지 큐를 계속 확인하며, 메시지나 작업을 순차적으로 처리하는 역할을 한다. 스레드를 살아있게 유지하는 메시지 처리의 **중추**이다.
        ▷ 사용법 : 메시지를 처리하는 모든 스레드는 Looper가 필요하다. 메인 스레드에는 기본적으로 Looper가 있지만, 우리가 직접 만든 워커 스레드에서는 명시적으로 준비해얗 한다.

        ▷ 초기화 : 워커 스레드에서는 Looper.prepare()를 호출하여 Looper를 연결하고, Looper.loop()를 호출하여 메시지 루프를 시작한다.

    2. [Handler] : Looper와 상호작용하며 다른 스레드에 메시지나 작업을 전달하고 처리하는 역할로 백그라운드 스레드에서 UI업데이트를 위해 메인 스레드로 작업을 보낼 때 사용된다.(**인터페이스**)
        ▷ 동작 : Handler가 생성될 때, 그 Handler는 생성된 스레드의 Looper에 연결된다. 그래서 Handler로 전송된 작업은 Looper에 연결된 해당 스레드에서 처리된다

    3. [HandlerThread] : 내부에 Looper가 이미 준비되어있는 특수 목적의 스레드이다.
                    Looper를 가진 워커 스레드 생성을 **단순화**하여, 해당 스레드에서 작업을 순차적으로 처리할 수 있게 한다. 
        ▷ 생명주기 : start()로 HandlerThread를 시작한 다음, getLooper()를 통해 Looper를 얻어와 Handler를 생성할 수 있다. 작업이 끝나면 리소스 해제를 위해 반드시 quit() 또는 quitSafely()를 호출하여 Looper를 종료해야 한다.

### 실전 질문: Handler는 Looper와 어떻게 작동하여 스레드 간 통신을 용이하게 하며, Handler의 일반적인 사용 사례를 말씀해주세요.
    ▷ Looper 역할 : Looper는 특정 스레드에 속해, 그 스레드의 메시지 큐를 무한히 반복하며 감시한다. 메시지 큐에 처리할 작업이 들어오면, Looper는 그 작업을 꺼내서 연결된 Handler에게 전달한다.

    ▷ Handler 역할 : 메시지 큐에 작업을 넣거나(post, sendMessage), Looper가 전달해 준작업을 처리하는 역할을 하며 Handler는 생성될 때 특정 스레드의 Looper와 연결된다.

    ▶ 상호 작용 : 다른 스레드에서 특정스레드로 작업을 보내고 싶을 때, 대상 스레드의 Looper에 연결된 Handler를 사용한다.

    Handler에 작업을 전달하면, 그 작업은은 대상 스레드의 메시지 큐에 들어가고, 해당 스레드의 Looper가 이를 발견하고 처리하게 된다. 

### 실전 질문: HandlerThread란 무엇이며, Looper.prepare()를 사용하여 수동으로 스레드를 생성하는 것과 비교하여 백그라운드 스레드 관리를 어떻게 단순화하나요?
    ▷ HandlerThread 는 이름 그대로, 내부에 Looper가 내장된 특수 목적의 스레드이다.
    목적은 자체 Looper를 가진 워커 스레드를 생성하여, 해당 스레드에서 작업을 순차적으로 처리할 수 있도록 하는 것이다.

    ▷ 1. 수동 방식의 번거로움을 해결 : 
        일반 스레드를 생성하여 메시지 큐를 처리하게 하려면, 스레드 내에서 Looper.prepare()를 호출하여 Looper를 만들고, Looper.loop()를 호출하여 메시지 루프를 시작하는 코드를 직접 작성해야 하지만,

        HandlerThread는 이러한 Looper 설정 과정을 내부적으로 모두 처리해주어, 개발자는 HandlerThread 객체를 생성하고 start() 메소드를 호출하기만 하면, 즉시 메시지를 처리할 준비가 된 스레드가 만들어져, 그 후 getLooper() 메소드를 통해 이 스레드의 Looper를 가져와 Handler를 생성하고 작업을 전달하면 된다.