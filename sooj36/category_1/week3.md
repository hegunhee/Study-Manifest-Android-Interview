***

## Q10. BroadcastReceiver란 무엇인가요?
▷ 안드로이드 운영 체제나 다른 앱에서 보내는 브로드캐스트 메시지를 앱이 수신하고 이에 반응할 수 있게 하는 구성요소

배터리 부족, 네트워크 연결 변경 같은 시스템 이벤트나 앱 내부의 커스텀 이벤트를 처리하는데 사용됨

이를 통해 앱이 백그라운드에서 계속 실행되지 않고도 주요 이벤트에 대응할 수 있어 리소스를 효율적으로 사용할 수 있음

#### 실전 질문
* 브로드캐스트의 유형에는 어떤 것이 있으며, 기능 및 사용 측면에서 시스템 브로드캐스트와 커스텀 브로드캐스트는 어떤 차이가 있나요?

▷ '시스템 브로드캐스트' , '커스텀 브로드캐스트'

가장 큰 차이점은 **발신 주체** 와 **목적**
    ▷ **'시스템 브로드캐스트'**는 시스템 상태 변화를 알리기 위해 보냄.
        (ex, 배터리 잔량 변경, 시간대 업데이트, 네트워크 연결 변경 등)

        **'커스텀 브로드캐스트'**는 특정 애플리케이션이 앱 내부의 다른 구성요소나 다른 앱에게 정보를 전달하기 위해 직접 생성하여 보냄


***

## Q11. ContentProvider의 목적은 무엇이며, 애플리케이션 간의 안전한 데이터 공유를 어떻게 용이하게 하나요?

▷ 애플리케이션 간의 **구조화된 데이터 공유를 관리**하고 **표준화된 인터페이스를 제공**하는 안드로이드 구성요소

다른 앱이 데이터를 안전하고 일관되게 쿼리, 삽입, 업데잍, 삭제할 수 있는 중앙 저장소 역할

▷ 주요 목적
    ▶ 데이터 접근 로직을 캡슐화하여 앱 간의 데이터 공유를 더 쉽고 안전하게 만드는 것
        SQLite DB나 파일 시스템 같은 내부 데이터 구조를 직접 노출하지 않고, 추상화된 통합 인터페이스를 통해 데이터 접근을 제어

#### 실전 질문
* ContentProvider URI의 주요 구성 요소는 무엇이며, ContentResolver는 데이터를 쿼리하거나 수정하기 위해 ContentProvider와 어떻게 상호 작용하나요?

▷ ContentProvider URI는 특정 데이터에 접근하기 위한 고유 주소 역할을 하며, 이 주소는 세 가지 주요 요소로 구성
    ▶ 권한 (Authority) : 어떤 ContentProvider에 접근할지를 알려주는 고유 식별자로 웹사이트의 도메인 주소와 같은 역할.
    [ ex : com.example.myapp.provider]

    ▶ 경로 (Path) : Provider 안에서 어떤 데이터의 유형에 접근할지를 지정. 웹사이트의 세부 경로처럼 특정 데이터 테이블이나 그룹을 가리킴.
    [ex : /users ]

    ▶ ID (선택 사항) : 데이터 집합 내에서 특정 한 개의 항목을 정확히 참조할 때 사용.

#### Pro Tips for Mastery
* 앱 시작 시 리소스나 초기 셋업을 위해 ContentProvider를 사용하는 사용 사례

▷ 일반적으로 라이브러리 초기화는 Application 클래스에서 많이 하지만, ContentProvider를 사용하면 더 깔끔하고 효율적 초기화 가능

가장 큰 이유는 실행순서에 있는데, 

ContentProvider의 onCreate() 메서드는 Application의 onCreate() 메서드보다 먼저 호출되기 때문에, 중요한 초기화 작업 처리에 좋은 진입점

▶ 사용 사례
    - Firebase SDK : FirebaseInitProvider라는 커스텀 ContentProvider를 사용하여 SDK를 자동으로 초기화함.
    
    이 덕에 개발자는 라이브러리 의존성만 추가하면 별도의 초기화 코드를 작성할 필요가 없어짐. 

    - Jetpack App Startup: ContentProvider를 내부적으로 활용하여, 지정된 컴포넌트들을 Application.onCreate()가 호출되기 전에 미리 초기화함

    즉, ContentProvider를 활용하면 초기화 로직을 분리하여, **모듈화된 설계 구현 가능**

***

## Q12. 구성 변경(configuration changes)을 어떻게 처리하나요?

#### 실전 질문
* 구성 변경(Configuration Change)을 처리하기 위한 전략에는 무엇이 있으며, ViewModel은 구성 변경으로부터 손실될 수 있는 UI 관련 데이터를 어떻게 보존하나요?
▷ 총 4가지 전략
    (1). onSaveInstanceState()를 이용해 UI 상태를 직접 저장하고 복원
    (2). UI 데이터를 ViewModel에 저장
    (3). AndroidManifest에서 구성 변경을 직접 처리하겠다고 선언
    (4). Jetpack Compose에서 rememberSavable 사용

▶ ViewModel은 액티비티보다 생명주기가 길기 때문에, 화면 회전으로 액티비티가 파괴되었다 다시 만들어져도, ViewModel은 살아남아 데이터를 그대로 간직하여 새로 만들어진 액티비티는 ViewModel의 데이터를 즉시 가져다 쓸 수 있음
//

* AndroidManifest 파일에서 android:configChanges 속성은 Activity 생명주기와 동작에 어떤 영향을 미치며, Activity 재시작에 의존하는 것이 아니라 onConfigurationChanged() 메서드를 사용해야 하는 시나리오의 예시를 들어주세요.
▶ AndroidManifest 파일에 android:configChanges 속성을 추가하면, 지정된 구성 변경이 발생해도 시스템이 Activity를 재시작하는 것을 막을 수 있음

Activity가 종료되는 대신, onConfigurationChanged()라는 메서드가 호출되어 개발자가 직접 변경 사항을 처리.

▶ Activity가 재시작되면 곤란한 경우 유용
ex. 동영상 플레이어
동영상을 보다 화면을 돌렸을 때, configChanges로 재시작을 막고 onConfigurationChanged()에서 화면만 다시 그려주면 됨.


***

## Q13. 안드로이드에서 메모리를 어떻게 효율적으로 관리하며, 메모리 누수(memory leaks)를 어떻게 방지하는지 설명해주세요.

#### 실전 질문
* 애플리케이션에서 메모리 누수의 일반적인 원인은 무엇이며, 이를 사전에 방지하기 위한 방법에는 어떤 것들이 있나요?

```
#### 메모리 누수의 원인
= 애플리케이션이 더 이상 필요하지 않은 객체에 대한 참조를 유지하여 GC이 메모리를 회수하지 못하게 할 때 발생

#### 사전 방지 (8가지)
(1). 생명주기를 인지하는 컴포넌트 사용
▷ ViewModel이나 LiveData 같은 생명주기 인식 컴포넌트는 UI컴포넌트의 생명주기를 스스로 감지하기 때문에 활성화 시 자동으로 데이터 관찰을 시작하고, 화면이 사라지거나 파괴되면 관찰을 중단하고 자원을 정리함 
//

(2). Context에 대한 오랜 참조 피하기
▷ 생명주기가 긴 객체가 짧은 Context를 참조하면, Activity가 종료되어도 메모리에서 해제되지 않기 때문에 Context에 대해 장기적인 참조가 필요하다면 Activity나 Fragment 생명주기와는 독립적인 ApplicationContext 사용하는 것이 좋음
//

(3). 리스터 및 콜백 등록 올바르게 해제
▷ onPause() 또는 onStop()에서 BroadcastReceiver 등록을 해제해야 앱이 백그라운드에 있을 때 참조를 유지하지 않음
//

(4). 중요하지 않은 객체는 WeakReference 사용
▷ 강력한 참조 또는 장기적 참조 보장이 필요한 객체가 아니면 WeakReference 사용 권장
WeakReference 로 참조하는 객체는 메모리가 필요할 때 GC은 해당 객체를 언제든지 회수 가능
//

(5). 누수 감지 툴 사용
▷ LeakCanary나 Android Studio Memory Profiler 같은 도구로 메모리 사용량 실시간 감시하여 어떤 객체에서 문제인지 알 수 있어 앱의 안정성 높힘

(* LeakCanary : 개발 중에 메모리 누수를 탐지하고 수정하기 위해 사용할 수 있는 도구)
//

(6). View에 대한 정적 참조 피하기
▷ static 필드의 생명주기가 앱 전체와 동일하기 때문에, 여기에 View를 담아두면 View와 연결된 Activity 전체가 메모리에서 해제되지 못하기 때문
//

(7). 리소스 닫기
▷ 파일 스트림, DB 연결, Cursor 등은 안드로이드 앱의 메모리뿐 아니라, 운영체제가 직접 관리하는 별도의 한정된 자원(파일 핸들, 네트워크 소켓)을 사용함

GC은 사용하지 않는 객체를 메모리에서 제거할 순 있지만, 그 객체가  사용하던 운영체제의 
자원까지 닫지 못함 

따라서 개발자가 close() 를 호출하여 직접 자원을 반납하라는 신호를 보내지 않으면, 앱이 종료될 때까지 계속 점유하게 됨
//

(8). Fragment와 Activity 현명하게 사용
▷ Fragment 생명주기와 View의 생명주기가 분리되어 있기 때문에,

사용자가 화면을 벗어나면 Fragment의 뷰가 파괴되어 onDestroyView()가 호출되지만, Fragment 객체 자체는 백 스택에 남아 살아있을 수 있음

만약 이때 Fragment 코드에 뷰에 대한 참조가 남아있다면, 살아있는 Fragment 객체가 이미 파괴된 뷰 객체를 계속 잡고 있어 GC이 파괴된 뷰와 관련 메모리를 회수하지 못하게 됨

따라 onDestoryView()에서 뷰에 대한 모든 참조를 명시적으로 제거(null처리)하는 작업이 필요.
//

```
***

## Q14. ANR 이란 무엇인지, ANR이 발생하는 주요 원인은 무엇이며, 어떻게 예방할 수 있는지 설명해주세요.

#### ANR (Application Not Responding) 정의 및 원인
▷ 메인 스레드가 5초 이상 응답하지 않을 때 발생하는 시스템 오류로 사용자에게 앱을 닫거나 응답을 기다리도록 안내

▷ 1. 메인 스레드에서 5초 이상 걸리는 무거운 작업
    2. 장시간 실행된느 네트워크 또는 DB 등의 I/O 작업
    3. UI 스레드에서의 동기 작업 같은 차단 작업

##### 예방법 7가지
▷ 
(1). 무거운 작업 백그라운드로
▶ 네트워크 요청이나 DB 쿼리 같은 무거운 작업은 코루틴 등을 이용해 메인 스레드 밖에서 처리

(2). WorkManager 사용
▶ 데이터 동기화처럼 장기적이고 보장되어야 하는 백그라운드 작업 시 예약하고 실행으로

(3). 데이터 불러오기 최적화
▶ 대규모 데이터는 Paging 기법으로 나눠 불러와 UI 과부하를 막음

(4). UI 작업 최소화
▶ ViewModel 사용해 UI 데이터 보존함으로써, 화면 회전 같은 구성 변경 시 불필요한 렌더링 피하기

(5). Android Studio 모니터링 및 프로파일링
▶ Android Studio Profiler로 CPU, 메모리 사용량을 감시해 성능 병목 현상 해결

(6). 블로킹 호출 피하기
▶ 메인 스레드에서 긴 루프나 동기 방식의 네트워킁 요청 등 UI 차단하는 작업 안하기 

(7). 가벼운 지연 작업에 Handler 사용
▶ Thread.sleep() 대신 Handler.postDelayed() 사용해 메인 스레드 차단않고 가벼운 지연 작업 처리 


***

## Q15. 딥 링크(deep links)를 어떻게 처리하는지 설명해주세요.
▷ 사용자가 URL 같은 외부 경로를 통해 앱 내의 특정 화면으로 직접 이동하게 하는 기능으로 크게 2단계로 나뉜다
```
[[1단계]. 매니페스트에서 딥 링크 정의]
▷ AnroidManifest.xml 파일에서 딥 링크를 받을 Activity에 <intent-filter> 를 선언해야 함. 해당 필터는 앱이 반응할 URL의 스키마, 호스트, 경로 등을 지정함

[[2단계]. Activity에서 딥 링크 데이터 처리]
▷ 딥 링크를 통해 실행된 Activity 내부에서 getIntent()를 통해 들어온 데이터(Uri)를 받아오고, 이 데이터를 파싱하여 쿼리 파라미터를 추출한 뒤 특정 작업을 수행

[[TEST]. 딥 링크 테스트]
▷ adb 명령어 사용하여 테스트 가능
```

#### 실전 질문
* 안드로이드에서 딥 링크를 어떻게 테스트하고, 다양한 기기와 시나리오에서 올바르게 작동하는지 확인하기 위해 사용하는 디버깅 기법이 있다면 설명해 주세요.

▷ Android Studio Deep Link Assistant 
    ▶ Android Studio에 내장된 도구로, URL을 추가하고 매니페스트 설정을 확인하며 앱을 실행하지 않고도 IDE 내에서 직접 테스트 가능


***

## Q16. 태스크(tasks)와 백 스택(back stack)이란 무엇인가요?
▷ 태스크(tasks)
    ▶ 사용자가 특정 목표 달성을 위해 상호 작용하는 Activity 집합

▷ 백 스택(back stack)
    ▶ 태스크 내 Activity 기록 관리 후입선출(LIFO) 구조

#### 실전 질문
* singleTask와 singleInstance의 차이점은 무엇이며, 각각 어떤 시나리오에서 사용해야 하나요?
▷ 가장 큰 차이점은 **Task를 다루는 방식**
    ▶ singleTask : 해당 액티비티의 인스턴스가 태스크 내에 **하나만 존재**하도록 보장함
    ▶ singleInstance : 액티비티가 다른 모든 액티비티와 분리된 고유한 태스크에 단독으로 배치되어 해당 태스크에는 다른 어떤 액티비티도 포함될 수 없음

▷ 사용 시나리오
    ▶ singleTask : 앱의 진입점 역할하는 액티비티에 유용
    ▶ singleInstance : 독립 실행이 필요한 액티비티에 사용될 수 있음

* Activity 런치 모드에는 각각 어떤 타입이 존재하며, 태스크 및 백 스택 동작에 어떤 영향을 미치나요?

▷ 액티비티 런치 모드 (4가지)
| 런치 모드 | 동작 방식 |
| :--- | :--- |
| **`standard`** | 기본 모드. 항상 **새로운 인스턴스**를 생성하여 백 스택에 추가 |
| **`singleTop`** | 스택 맨 위에 이미 있다면 **새로 생성하지 않고** 기존 인스턴스를 재사용 |
| **`singleTask`** | 태스크 내에 **단 하나의 인스턴스**만 존재하도록 보장하며, 기존에 있다면 재사용 |
| **`singleInstance`** | Activity를 **완전히 독립된, 별도의 태스크**에서 실행 |

