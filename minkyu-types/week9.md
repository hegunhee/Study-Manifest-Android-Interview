## Q52) DataBinding의 동작 원리에 대해서 설명해주세요
- DataBinding은 XML 레이아웃의 UI 컴포넌트를 앱의 데이터 소스에 직접 바인딩할 수 있는 안드로이드 라이브러리
- 보일러 플레이트 코드를 줄이고 UI <> 데이터 모델 간의 실시간 업데이트를 허용하여 UI 디자인에 선언적 프로그래밍을 부분적으로 적용시킴
- 또한 이 개념은 UI 로직과 비즈니스 로직 분리를 위한 디자인 패턴으로, MVVM 아키텍처에서 중심점 역할을 함
- <layout> 태그를 사용하는 각 XML 레이아웃에 대한 바인딩 클래스를 생성하며, 이를 통해 뷰에 직접적으로 접근하고 표현식을 사용하여 데이터를 바인딩할 수 있음

### DataBinding의 특징
(1) 양방향 데이터 바인딩
- UI와 기본 데이터 모델 간의 데이터 자동 동기화를 가능하게 함
- 입력 필드 값을 업데이트하는 등에 특히 유용함
(2) 바인딩 표현식
- 문자열 연결/조건문 같은 간단한 로직을 XML에서 직접 사용할 수 있음
(3) 생명주기 인식
- 생명주기가 적절한 상태일 때만 UI를 자동으로 업데이트함

### DataBinding의 장점
(1) 보일러플레이트 코드 감소: `findViewById()` 및 명시적인 UI 업데이트가 필요 없어짐
(2) 실시간 UI 업데이트: 데이터 변경 사항을 UI에 자동으로 반영함
(3) 선언적 UI: 로직을 XML로 이동하여 잘 사용하면 복잡한 레이아웃을 단순화할 수 있음
(4) 테스트 용이성 향상: UI와 코드를 분리하여 둘 다 독립적으로 테스트하기 쉽게 만듬

### DataBinding의 단점
- 성능 오버헤드: ViewBinding에 비해 더 많은 런타임 오버헤드가 발생함
- 복잡성: 작거나 간단한 프로젝트에는 불필요한 복잡성을 유발할 수 있음
- 러닝 커브: 바인딩 표현식 및 생명주기 관리에 대한 러닝 커브가 요구됨


## Q53) LiveData에 대해서 설명해 주세요
- LiveData는 AAC에서 제공하는 관찰 가능한 데이터 홀더 클래스
- 생명주기를 인식하므로 Activity/Fragment/View와 같이 연관된 안드로이드 컴포넌트의 생명주기에 따라 동작이 달라짐
- 주요 목적은 UI 컴포넌트가 데이터 변경 사항을 관찰하고 해당 데이터가 변경될 때마다 UI를 반응형으로 업데이트할 수 있도록 하는 것

### LiveData의 장점
(1) 생명주기 인식: LiveData는 컴포넌트의 생명주기를 관찰하고 컴포넌트가 활성 상태일 때만 데이터를 업데이트하여 크래시 및 메모리 누수 위험을 줄임

(2) 자동 정리: 컴포넌트에 연결된 관찰자는 주어진 생명주기가 소멸될 때 자동으로 제거되고 정리됨

(3) 관찰자 패턴: UI 컴포넌트는 관찰자를 활용하여 LiveData의 데이터가 변경될 때 자동으로 업데이트됨

(4) 스레드 안전성: LiveData는 스레드 안전하도록 설계되어 백그라운드 스레드에서 업데이트할 수 있음


### MutableLiveData와 LiveData의 차이
- MutableLiveData: `setValue()`, `postValue()`를 통해 데이터 수정을 허용함
  외부에서의 직접적인 수정을 방지하기 위해 ViewModel 내에서 프라이빗하게 유지함
- LiveData: 외부 컴포넌트가 데이터를 수정하는 것을 방지하는 읽기 전용 LiveData로, 더 나은 캡슐화를 보장함

### LiveData 사용 사례
(1) UI 상태 관리: 네트워크 응답, 데이터베이스와 같은 소스의 데이터를 담는 컨테이너 역할
(2) 옵저버 패턴 구현: LiveData는 발행자 역할을 하고 Observer 인터페잉스 구현이 구독자 역할을 하는 옵저버 패턴을 따름. LiveData 값이 변경될 될 때마다 구독자에게 실시간 업데이트를 용이하게 함
(3) 일회성 이벤트: 토스트, 스낵바나 화면 이동 같은 일화성 이벤트에도 사용될 수 있으나 이 때는 SingleLiveEvent 또는 유사하게 커스텀해서 처리해야 함

### Pro Tips for Mastery: LiveData에서 `setValue()`와 `postValue()` 메서드의 차이점은 무엇인가요?
- `setValue()`와 `postValue()`는 LiveData 객체가 보유한 데이터를 업데이트하는 데 사용되지만, 특히 스레딩 및 동기화 측면에서 다른 사용 사례와 동작을 가짐

#### `setValue()`
- 데이터를 동기적으로 업데이트하며 메인 스레드에서만 호출할 수 있음
- 값을 즉시 업데이트하고 변경 사항이 (동일한 프레임) 동안 관찰자에게 반영되도록 해야 할 때 사용됨
- 백그라운드 스레드에서 호출하면 예외가 발생함

#### `postValue()`
- 데이터를 비동기적으로 업데이트하는 데 사용됨
- 백그라운드 스레드에서 UI를 업데이트해야 하는 경우에 적합함
- 호출하면 메인 스레드에서 업데이트 발생하도록 예약하여 현재 스레드를 차단하지 않고 스레드 안전성을 보장함

```
protected void postValue(T value) {
    boolean postTask;
    synchronized (mDataLock) {
        postTask = mPendingData == NOT_SET; // 이전에 전달된 작업이 없는지 확인
        mPendingData = value; // 보류 중인 데이터 업데이트
    }
    if (!postTask) {
        return; // 이미 전달된 작업이 있으면 바환
    }
    // 메인스레드 실행자에 Runnable 실행
    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
}
```
(1) mDataLock에서 동기화하고 mPendingData를 업데이트하여 작업을 실행해야 하는지 확인
(2) 값이 이미 보류 중이면 중복 실행을 피함(return)
(3) 그렇지 않다면 mPostValueRunnable을 ArchTaskExecutor를 통해 메인스레드에서 실행되도록 예약하여 스레드 안전한 업데이트를 보장함


## Q54) Jetpack ViewModel에 대해 설명해 주세요
- Jetpack ViewModel은 생명주기를 인식하는 방식으로 UI 관련 데이터를 저장하고 관리하도록 설계된 AAC의 핵심 구성 요소
- 화면 회전과 같은 구성 변경 시에도 데이터가 유지되도록 보장하면서 UI 로직과 비즈니스 로직을 분리하여 개발자가 견고하고 유지 관리 가능한 앱을 만드는 데 도움을 줌
- 주요 목적은 구성 변경 중에 UI 관련 데이터를 보존하는 것

### ViewModel의 특징
(1) 생명주기 인식: ViewModel은 Activity/Fragment의 생명주기에 범위가 지정되어 해당 UI 컴포넌트가 더 이상 사용되지 않을 때 자동으로 소멸됨
(2) 구성 변경 간 지속성: 구성 변경 중에 소멸되고 다시 생성되는 Acctivity/Fragment와 달리 ViewModel은 상태를 유지하여 데이터 손실을 방지하고 데이터의 반복적인 재로드를 피함
(3) 관심사 분리: UI 로직과 비즈니스 로직을 분리하여 더 깔끔하고 유지 관리하기 쉬운 코드를 설계하는 데 도움이 됨

### ViewModel 생명주기
- ViewModel 인스턴스는 ViewModel 인스턴스의 생명주기를 관리하기 위한 메커니즘 역할을 하는 ViewModelStoreOwner에 스코프가 지정됨
- ViewModelStoreOwner는 Activity, Fragment, Navigation 그래프 또는 그래프 내 대상 등이 될 수 있음

### Pro Tips for Mastery: ViewModel의 생명주기는 어떻게 되나요?
- ViewModel의 생명주기는 ViewModelStoreOwner에 연결됨
- ViewModel은 ViewModelStoreOwner의 범위 내에서 존재하며, 화면 회전과 같은 구성 변경 시에도 데이터와 상태가 유지되도록 보장함

- ViewModelStoreOwner가 처음 생성될 때 ViewModel 인스턴스가 초기화됨
- ViewModelStoreOwner가 메모리에 남아 있는 한 동일한 ViewModel 인스턴스가 유지됨
- 기기 회전과 같은 구성 변경이 발생하면 ViewModelStoreOwner는 다시 생성되지만 기존 ViewModel 인스턴스가 재사용되어 데이터를 유지함
  -> 새로운 ViewModelStoreOwner가 생성될 때, 이전 ViewModelStoreOwner로부터 기존 ViewModel 객체의 정보를 가져오기 때문에 가능함
- `onDestroy()`가 구성 변경으로 인해 트리거되지 않은경우 ViewModelStore의 `clear()` 메서드가 호출됨

### Pro Tips for Mastery: AAC ViewModel과 MVVM ViewModel의 차이점에 대해서 설명해주세요
(1) AAC ViewModel
- 비즈니스 로직 또는 UI 상태 홀더 역항르 하도록 설계된 생명주기를 인식하는 컴포넌트
- 관련 비즈니스 로직을 캡슐화하면서 상태를 관리하고 UI에 제공함
- 상태를 보유하고 화면 회전과 같은 구성 변경 시에도 유지하는 장점이 있음

(2) MVVM ViewModel
- View와 Model 간의 다리 역할
- View가 상태 변경에 반응할 수 있도록 하는 바인딩 메커니즘을 강조하여 더 선언적이고 모듈화된 설계를 용이하게 함


## Q55) Jetpack Navigation 라이브러리란 무엇인가요?
- Jetpack Navigation 라이브러리는 앱 내 네비게이션을 단순화하고 표준화하기 위해 안드로이드에서 제공하는 프레임워크
- 개발자가 선언적으로 다양한 앱 화면 간의 네비게이션 경로와 전환을 정의할 수 있도록 하여 보일러 플레이트 코드를 줄이고 사용자 경험을 향상시킴

(1) 네비게이션 그래프
- 앱 대상 간의 흐름과 관계를 정의하는 XML 리소스
(2) NavHostFragment
- 네비게이션 그래프의 컨테이너 역할을 하여 대상을 호스팅하고 대상 간의 네비게이션을 관리
- 사용자가 탐색할 때 컨테이너 내에서 Fragment를 동적으로 교체함
(3) NavController
- 네비게이션 작업을 처리하고 백스택을 관리하는 역할
- 이를 사용하여 코드로 목적지 간에 이동하거나 전반적인 네비게이션 흐름을 컨트롤 할 수 있음
(4) SafeArgs
- 네비게이션 및 파라미터 전달 코드를 생성하는 Gradle 플러그인
- 대상 간 데이터를 전달할 때 수동으로 번들을 만들 필요가 없음
- 타입 안전성을 보장함
(5) Deep Linking
- 딥 링크를 지원하여 사용자가 URL이나 알림과 같은 외부 소스에서 특정 화면으로 직접 이동할 수 있도록 함

### Jetpack Navigation 라이브러리의 장점
(1) 중앙 집중식 네비게이션
- 모든 네비게이션 흐름을 하나의 XML 파일에서 관리
(2) 타입 안전성
- 생성된 Safe Args 클래스를 사용하여 대상 간에 데이터를 안전하게 전달
(3) 백스택 관리
- 백스택 동작을 자동을 처리
(4) 딥링크 지원
- 외부 네비게이션 요청을 원활하게 처리하여 사용자 경험을 향상시킴
(5) Jetpack 컴포넌트와의 통합
- 생명주기를 고려한 네비게이션을 보장

## Q56) Dagger2와 Hilt의 동작원리 및 차이점에 대해서 설명해주세요
- 안드로이드 개발을 위한 대표적인 DI 라이브러리로 Dagger2, Hilt가 있음

### Dagger2란?
- Dagger2는 안드로이드/JVm 환경을 위한 정적 컴파일 타임 기반의 DI 라이브러리
- 객체 생성을 관리하고 의존성을 자동으로 제공하여 모듈성 개선/테스트 용이 하도록 설계되었음
- 컴파일 타임에 코드를 생성하여 리플렉션에 기반한 DI 프레임워크에 비해 더 나은 성능을 보장
- `@Module`, `@Provides`, `@Inject` 와 같은 어노테이션을 사용하여 의존성을 선언하고 요청함

### Hilt란?
- Dagger2 위에 구축된 안드로이드 전용 DI 라이브러리
- Activity, Fragment, ViewModel과 같이 안드로이드 생명주기와 밀접한 관련이 있는 클래스에 스코프가 지정된 사전 정의된 컴포넌트를 제공하여 Dagger의 프로세스를 단순화하였음
- `@HiltAndroidApp`, `@AndroidEntryPoint`와 같은 어노테이션을 제공하여 DI 설정을 간소화함으로써 Dagger2에 필요한 많은 보일러플레이트 코드를 제거함
- `@Singleton`, `@ActivityScoped`와 같은 범위를 정의하여 의존성의 생명주기를 관리함

### Dagger2와 Hilt의 주요 차이점
(1) 통합 프로세스
- Dagger2는 컴포넌트/인젝터를 수동으로 정의해야 하므로 보일러플레이트 코드가 증가함
- Hilt는 사전 정의된 컴포넌트/생명주기에 스코핑된 어노테이션을 사용하므로 이를 단순화
(2) 안드로이드 생명주기 통합
- Hilt는 안드로이드에 특화되어 있어 안드로이드 컴포넌트에 대한 내장 지원을 제공함
- Dagger2는 더 범용적이며 수동 설정이 따로 필요함
(3) 스코핑
- Hilt는 안드로이드 생명주기 클래스와 밀접하게 통합된 사전 정의된 범위를 제공함
- Dagger2에서는 스코핑에 수동 설정 및 커스텀 어노테이션이 필요함
(4) 코드 단순성
- Hilt는 많은 보일러플레이트 코드를 추상화하여 DI 설정의 복잡성을 줄여 러닝커브가 완만함
- Dagger2는 유연하고 복잡한 구조에서 높은 자유도로 커스텀이 가능하나, 러닝커브가 가파름
(5) 사용 사례
- Dagger2는 복잡하고 커스텀된 DI 그래프가 필요한 프로젝트에 적합함
- Hilt는 안드로이드 프로젝트를 위해 맞춤 설계되어 안드로이드 컴포넌트와의 통합에 중점을 둠

#### Dagger2 기반 어노테이션
(1) `@Provides` : `@Module` 내에서 의존성 생성 메서드를 정의함

(2) `@Module` : 클래스를 의존성 제공자 컨테이너로 선언함. 모듈은 관련된 의존성 생성 로직을 그룹화

(3) `@Binds` : @Module 내에서 인터페이스를 구현체에 매핑하는 데 사용되어 의존성 정의 시 보일러플레이트 코드를 줄임

(4) `@Qualifier` : 커스텀 어노테이션을 사용하여 동일한 타입에 대해 여러 의존성 바인딩을 구별함(다양한 구현체를 인터페이스에 매핑할 떄 사용

(5) `@Scope` : 특정 의존성의 생명주기를 제어하기 위해 커스텀 스코핑 어노테이션을 정의할 수 있음

(6) `@Singleton` : 의존성이 해당 범위 내내 단일 공유 인스턴스를 가져야 함을 지정함

(7) `@Component` : 의존성 그래프의 인터페이스를 정의함. 모듈을 주입 대상에 연결하고 의존성 생명주기를 제어함

(8) `@Inject` : 의존성 주입을 위해 생성자, 필드, 메서드에 표시함

(9) `@Subcompnent` : 지정한 범위 내에서 의존성을 관리하기 위한 케이스를 위해 `@Component`에 더 작은 의존성 그래프를 생성함. 종종 자체 생명주기를 가진 자식 컴포넌트를 만드는 데 사용됨

#### Hilt 기반 어노테이션
(1) `@HiltAndroidApp` : Hilt를 부트스트랩하고 전체 앱에 대한 의존성 그래프를 생성하기 위해 사용됨. Hilt를 초기화하기 위한 필수 어노테이션

(2) `@AndroidEntryPoint` : 안드로이드 컴포넌트를 주입 대상으로 마크함

(3) `@InstallIn` : `@Module`이 설치되어야 하는 컴포넌트를 지정함

(4) `@EntryPoint` : Hilt에서 관리하는 안드로이드 컴포넌트가 아닌 외부에서 의존성에 접근하기 위한 진입점을 정의하는 데 사용됨

(5) `@HiltViewModel` : Jetpack ViewModel을 Hilt와 통합하기 위한 특수 어노테이션. ViewModel이 생명주기를 인식하면서 Hilt의 의존성 주입을 사용할 수 있도록 보장함. `@Inject`와 함께 사용해야 함

(6) `@Scope` 어노테이션들 : 사전 정의된 컴포넌트들로, 특정 생명주기에 의존성을 바인딩하는 프로세스를 단순화함


### Pro Tips for Mastery: 수동을 의존성 주입을 구현해 본 적이 있나요? <- 면접에 자주 나오는 질문이라고 함(제가 듣기로는)
- DI 프레임워크에 의존하지 않고 수동으로 의존성 주입을 구현할 수 있으며, 이는 구현체에 대한 세밀한 제어가 요구되는 경우 유용하다

(1) 수동 의존성 주입
- 런타임 기반이라고 가정함
- 객체의 전체 생명주기(스코핑, 그룹화, 메모리 누수 방지를 위한 리소스 정리 등)를 개발자가 수동으로 관리해야 하므로 상당한 리소스가 들어감
- 종종 많은 보일러플레이트 코드를 작성해야 하고
- 서비스 로케이터 패턴으로 전락하거나
- 전역적인 싱글톤 패턴에 의존하게 될 위험이 있음
- 중소 규모 프로젝트에 적합

(2) 자동 의존성 주입
- 반면 DI 라이브러리는 컴파일 타임의 어노테이션 프로세싱 및 코드 생성으로 인해 빌드 퍼포먼스가 떨어지지만, 개발자의 리소스를 절약할 수 있음
- 대규모 프로젝트에 적합(확장성, 효율성이 중요하므로)

### Pro Tips for Mastery: Dagger2/Hilt 이외에 알고 있는 DI 라이브러리가 있나요?
- Dagger2/Hilt는 구글에서 권장하지만, Koin/Anvil과 같이 다른 접근 방식으로 제공하는 라이브러리가 있음

(1) Koin
- 단순성을 염두에 두고 설계된 경량 DI 라이브러리
- 어노테이션, 컴파일 타임 코드 생성, 보일러플레이트 코드의 필요성을 없애고 Kotlin DSL을 사용하여 의존성 모듈을 정의하는 데 중점을 둠
- 특징
  - 어노테이션 프로세싱 없음, 의존성은 Kotlin 코드로 정의되어 빌드 퍼포먼스 향상
  - Kotlin 우선 접근 방식(DSL)을 사용하여 DI 구성을 직관적으로 만듬
  - 높은 사용 편의성. 설정이 빠르고 빠른 환경 셋업을 추구할 때 이상적
  - 동적 해결: 런타임 시 의존성이 결정되는 시나리오에서 유용함
- 현재 Dagger2/Hilt가 KMP를 지원하지 않아서 KMP에서 이상적

(2) Dagger2 vs Koin
- Jake Wharton은 Koin은 DI 솔루션이 아니라 수동으로 DI를 하기 위해 reified 트릭을 동반한 서비스 로케이터 패턴이라고 말함
  프로그램의 규모가 커질수록 보일러플레이트 코드가 불균형하게 확장될 것이다
  물론 Dagger에는 일정량의 고정 오버헤드가 있지만, 바인딩이 주입된 타입 전체에 자동으로 전파되므로 그래프 형태를 변경할 일이 거의 없음
  반면 Koin 등을 사용한 수동 DI를 위해서는 주입된 타입 전체에 수동으로 바인딩을 전파해야 함
- Koin은 작은 토이 프로젝트에 사용한다면 큰 상관이 없음
  근데 사실 안써도 되지 않음? 
  하지만 수백 개의 바인딩과 수많은 주입 타입, 깊은 의존성 그래프를 가진 중대형 프로그램을 개발한다면, Koin보다는 자동 DI 라이브러리를 사용하는 것이 좋음(생산성, 확장성)

(3) Koin은 서비스 로케이터 패턴인가?
- Koin 팀은 Koin이 DI + 서비스 로케이터 패턴을 모두 지원하여 개발자에게 유연성을 제공한다고 말함
  그러나 그 중에서도 의존성이 생성자 파라미터로 전달되는 DI(주입) 방식 사용을 강력히 권장함
  이로써 테스트 용이성을 높이고 코드 흐름 추적과 가독성을 높일 수 있음

### 번외: 의존성 주입 패턴의 장단점은? - 그냥 다들 쓰니까 당연한 듯이 사용해왔다면 한 번 생각해보자
(1) 장점
- 객체 내부에서 의존성을 생성하지 않고 외부에서 주입 받으므로 -> 클래스 간의 의존성이 줄어들고, Mock 객체로 쉽게 대체할 수 있어 테스트 용이성이 향상됨
  -> 결합도가 낮으므로 변경의 전파가 제한되어 변경에 강한 구조가 되고, 이는 곧 확장성과 유연성 향상으로 이어짐
- 내부에서 생성한다면 특정 인터페이스를 구현하는 구현체를 매핑해야 하지만, 주입받으면 구현체의 변경이 자유로우므로 재사용성이 향상됨
- 코드의 가독성과 유지보수성이 향상됨(사실 결합도 감소에서부터 확장성/유연성이 향상됐으므로 상위 개념인 유지보수성은 향상됐음)
- SOLID를 핵심적인 개념으로 운용해야 하며 DI를 활용해 DIP를 적용하는 클린 아키텍처나, 관심사 분리가 중요한 MVVM 패턴에서(ViewModel을 사용하는 MVI 또한 포함) 유용함 
(2) 단점
- 커스텀 스코프를 사용해야 하는 경우 Dagger2를 사용해야 하는데, Dagger2는 러닝커브가 가파름.(Hilt는 훨씬 쉬운 편이지만 DI가 생소하다면 어려울 수도?)
- DI 관련 코드가 프로덕트 코드보다 많아지는 경우가 있고, 초기 설정 비용이 추가로 들어간다(소규모 프로그램의 경우 오버 엔지니어링일 수 있다)
- 빌드 퍼포먼스가 떨어진다(Koin과 달리 컴파일 타임에 어노테이션 프로세싱과 코드 생성이 이루어지며 의존성 그래프가 생성되므로)
- 디버깅이 조금 어려울 수 있다(Hilt 오류 로그 가끔 이해가 어렵다)

## Q57) Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?
- 대규모 데이터셋을 청크/페이지 단위로 로드하고 표시하는 프로세스를 돕도록 설계된 AAC 요소
- DB나 API를 통해 데이터를 효율적으로 가져와야 하는 경우 유용하며, 메모리 사용량을 최소화하고 RecyclerView의 성능을 향상시킴
- 데이터를 점진적으로 로드하기 위해 데이터 캐싱/재시도 메커니즘/효율적인 메모리 사용 등과 같은 부분을 기본적으로 처리함

### 구성 요소
(1) PagingData
- 점진적으로 로드되는 데이터 스트림. `RecyclerView`에 사용 가능
(2) PagingSource
- 데이터 소스에서 데이터가 로드되는 방식을 정의하는 역할
- 위치/ID와 같은 키 값을 기반으로 데이터 페이지를 로드하는 `load()` 메서드를 제공함
(3) Pager
- PagingSource와 PagingData 간의 중개자 역할
- PagingData의 생명주기를 관리함
(4) RemoteMediator
- 로컬 캐싱과 원격 Api 데이터를 결합할 때 경계 조건을 구현하는 데 사용됨

### 작동 방식
- Paging 라이브러리는 데이터를 페이지로 분할하여 효율적인 데이터 로딩을 가능하게 함
- 이때 LiveData/Flow를 기본으로 지원하여 데이터 변경 사항을 관찰하고 UI 업데이트할 수 있도록 함
(1) PagingSource를 사용해 데이터 가져오는 방법을 지정
(2) Pager를 사용해서 PagingData의 Flow를 생성
(3) ViewModel에서 PagingData를 관찰하고 RecyclerView에 렌더링하기 위해 PagingDataAdapter에 submit

### 실전 질문
(1) Paging 라이브러리는 데이터 로딩 중 오류를 어떻게 처리하며, 페이지네이션된 데이터 흐름에서 오류 처리 및 재시도 메커니즘을 구현하기 위해 사용해 본 전략은 무엇인가요?


## Q58) Baseline Profile은 앱의 성능에 어떤 이점을 가져다주나요?
- Baseline Profiles는 앱 시작 시간과 런타임 실행을 최적화하기 위한 플러그인
- 미리 컴파일된 코드 정보를 제공함으로써 코드 해석 및 JIT 컴파일 단계를 우회하고 더 빠른 앱 실행을 가능하게 함
- 앱의 첫 실행에 대해서 20~30%의 속도 향상을 기대할 수 있고,더 부드럽고 효율적인 UX를 제공할 수 있음
- ART는 이런 프로파일을 사용하여 앱 설치 중에 중요한 코드 경로를 식별하고 미리 컴파일하여 응답성을 개선하고 앱 시작 지연 시간을 줄임
- Baseline Profiles는 제공된 프로파일에 정확한 코드 경로를 정의하기 위해 AOT 컴파일을 활용함
- 생성된 Profile에는 ART가 설치 단계 중에 컴파일하는 클래스 및 메서드의 정보가 포함됨

### Baseline Profiles 작동 방식
(1) 중요한 코드 경로 정의
- 개발자는 주요 실행 경로를 프로파일링 하거나 일반적인 사용자의 앱 사용 패턴을 기반으로 성능에 중요한 메서드/클래스를 정의할 수 있음

(2) 프로파일 생성
- 프로파일은 Jetpck Macrobenchmark 라이브러리 같은 도구를 사용해 생성됨
- 이를 통해 앱 동작을 기록/테스트하여 중요한 코드 경로를 식별할 수 있음

(3) 프로파일 전파
- 생성된 Baseline Profile은 APK/AAB와 함께 번들로 제공되어 최종 사용자에게 전파되어 배포됨

(4) 설치 중 최적화
- 앱이 사용자 기기에 설치될 때 ART는 프로파일을 사용하여 미리 정의해두었던 메서드/클래스를 네이티브 코드로 미리 컴파일






















