# Q17) Bundle의 사용 목적에 대해 설명해주세요
- Activity, Fragment, Service와 같은 컴포넌트 간에 데이터를 전달하는 데 사용되는 키-값 쌍 데이터 구조
- 일반적으로 앱 내에서 작은 용량의 데이터를 효율적으로 전송하는 데 사용됨
- 가볍고 안드로이드 OS가 쉽게 관리하고 전송할 수 있는 형식으로 데이터를 직렬화하도록 설계됨

### 일반적인 사용 사례
- Activity 간 데이터 전달
- Fragment 간 데이터 전달
- 인스턴스 상태 저장 및 복원
- Service에 데이터 전달

### Bundle 작동 방식
- 데이터를 키-값 구조로 직렬화하여 작동
- 키는 String, 값은 기본 타입/Serializable/Parcelable 객체 또는 다른 Bundle 객체를 담을 수도 있음
- Activity
  - Intent.putExtra()를 통해 내부적으로 Bundle에 패키징
- Fragment
  - arguments를 통해 내부적으로 Bundle에 패키징
- 상태 저장 및 복원
  - onSaveInstanceState, onRestoreInstanceState에서 put/set 메서드를 통해 Bundle 타입의 outState에 패키징하여
    구성 변경으로부터 사용자가 입력했던 값이 보존되도록 함

# Q18) Activity 또는 Fragment 간에 데이터를 어떻게 전달하나요?
### Activity 간 데이터 전달 
- 가장 일반적인 메커니즘인 Intent를 통해 데이터를 전달
- 키-값 쌍의 형태로 Intent에 추가되고, 수신 Activity는 getIntent()를 사용해서 해당 값을 가져옴

### Fragment 간 데이터 전달
- 발신 Fragment는 키-값 쌍의 형태로 Bundle을 생성하고 argument를 통해 수신 Fragment로 전달

### Jetpack Navigation 라이브러리로 Fragment 간 데이터 전달
- Safe args 플러그인을 사용하면 타입-안전한 방식으로 아규먼트를 전달할 수 있음
- Direction, Argument 클래스가 컴파일 타임에 자동으로 생성되어 런타임-안전함

### SharedViewModel 사용하기
- 동일한 Activity 내에서 Fragment 간에 통신이 필요한 경우 공유 뷰모델 사용을 고려할 수 있음
- androidx.fragment:fragment-ktx 패키지에서 제공하는 activityViewModel() 메서드를 사용하여 구현
- 이 방법을 통해 Fragment 끼리 의존성이 생기는 것을 피하고, 공유 뷰모델을 통해 반응형으로 상호작용할 수 있음

### Pro Tips for Mastery: Fragment Result API
- 상황에 따라 Fragment에서 다른 Fragment나 Activity에 값을 일회성으로 전달해야 하는 경우가 있음
- 예를 들면 QR 코드 스캔을 수행하는 Fragment가 스캔된 데이터를 이전 Fragment로 다시 보내야 하는 상황
- Fragment 버전 1.3.0 이상에서는 각 FragmentManager가 FragmentResultOwner를 구현하므로
  Fragment가 서로 직접 참조할 필요 없이 결과 리스너를 통해 통신할 수 있음(느슨한 결합)

- 주의할 점
  - 키-리스너의 1:1 관계: 각 키는 한 번에 하나의 리스너와 결과만 가질 수 있음
  - 보류 중인 결과는 덮여쓰여짐: 리스너가 활성화되기 전에 여러 결과가 설정되면 최신 결과만 저장됨
  - 결과는 소비 후 삭제됨: 결과를 수신하고 처리하면 결과는 FragmentManager에서 제거됨
  - 백 스택의 프래그먼트는 결과를 받지 못함: Framgent는 결과를 받으려면 백스택에서 pop되고 STARTED 상태여야 함
  - STARTED 상태의 리스너는 즉시 트리거됨: Fragment B가 결과를 설정할 떄 Fragment A가 이미 활성 상태라면 리스너는 즉시 실행됨

# Q19) 화면 회전과 같은 구성 변경이 발생하면 Activity에 어떤 변화가 생기나요?
- 화면 회전, 테마 변경, 글꼴 크기 변경, 언어 변경 등의 구성 변경이 발생하면
  시스템은 변경 사항을 적용하기 위해 현재 Activity를 종료하고 다시 실행함

### 구성 변경 중 기본 동작
- Activity 종료 및 재시작
  - 시스템이 현재 실행중인 Activity의 onPause, onStop, onDestroy 메서드를 호출
- 리소스 다시 로드하기
  - 새 구성에 따라 리소스를 다시 로드하여 앱에 변경 사항이 반영되도록 함
- 데이터 손실 방지
  - 재생성 중 데이터 손실을 방지하기 위해 onSaveInstance(), onRestoreInstanceState 메서드를 사용하거나
    ViewModel을 사용해서 인스턴스 상태를 저장하고 복원

### 재생성을 유발하는 구성 변경
- 화면 회전
- 시스템 테마 변경
- 글꼴 크기 변경
- 언어 변경

### Activity 재생성 피하기
- 매니페스트 파일에서 android:configChanges 속성을 추가
- 구성 변경 사항을 개발자가 수동으로 처리하는 형태로 개발자에게 위임함
  - 안드로이드 시스템이 Activity를 소멸시키고 다시 생성하지 않음
  - 대신 onConfigurationChanged() 메서드가 호출되어 개발자가 변경 사항을 수동으로 처리할 수 있음

# Q20) ActivityManager란 무엇인가요?
- 기기에서 실행중인 Activity, Task, Process에 대한 정보를 제공하고 관리하는 안드로이드 시스템 서비스
- 안드로이드 프레임워크의 일부로, 개발자가 앱 생명주기/메모리 사용량/테스크 관리를 할 수 있게 함
- 테스크 및 Activity 정보
  - 실행중인 테스크, Activity 및 해당 스택 상태에 대한 세부 정보를 추적할 수 있음
  - 개발자가 앱 동작 및 시스템 리소스 사용량을 모니터링하는 데 도움이 됨
- 메모리 관리
  - 앱의 메모리 소비 및 시스템 전체 메모리 상태를 포함하여
    시스템 전체의 메모리 사용량에 대한 정보를 제공함
  - 개발자는 이를 통해 앱 성능을 최적화하고 메모리 부족 상태를 처리할 수 있음
- 앱 프로세스 관리
  - 실행중인 앱 프로세스 및 Service에 대한 세부 정보를 쿼리할 수 있음
- 디버깅 및 진단
  - 힙 덤프 생성/앱 프로파일링과 같이 디버깅을 위한 도구를 제공
  - 이를 통해 성능 병목 현상이나 메모리 누수를 식별하는 데 도움이 됨

### ActivityManager에서 제공하는 메서드
- getRunningAppProcesses()
  - 기기에서 현재 실행 중인 프로세스 목록을 반환
- getMemoryInfo()
  - 사용 가능한 메모리, 임계 메모리, 기기가 메모리 부족 상태인지 여부 등 
  - 시스템에 대한 자세한 메모리 정보를 검색
- killBackgroundProcesses()
  - 시스템 리소스를 확보하기 위해 지정된 앱의 백그라운드 프로세스를 종료함
  - 리소스 집약적인 앱을 테스트하거나 관리하는 데 유용함
- isLowRamDevice()
  - 기기가 저사양 RAM으로 분류되는지 확인하여 앱이 저메모리 기기에 대한 리소스 사용량을 최적화하는 데 도움을 줌
- appNotResponding()
  - 테스트 목적으로 ANR 이벤트를 시뮬레이션할 때 사용됨
- clearApplicationUserData()
  - 파일, DB 및 SharedPreferences를 포함하여 애플리케이션과 관련된 모든 사용자별 데이터를 삭제함
  - 공장초기화나 앱을 기본 상태로 재설정하는 경우에 종종 사용함

# Q21) SparseArray를 사용하면 어떤 이점이 있나요?
- HashMap과 유사하게 정수 키를 객체 값에 매핑하는 안드로이드 최적화된 데이터 구조
- 정수 키를 사용할 때 일반적으로 사용하는 Map/HashMap보다 메모리 관리 효율이 좋고 상황에 따라 성능도 더 좋음

### SparesArray의 주요 특징
- 메모리 효율성
  - 키-값 매핑을 위해 HashTable을 사용하는 HashMap과 달리
  - 오토박싱(기본 int를 Integer로 변환)을 피하고
  - Entry 객체와 같은 추가 데이터 구조에 의존하지 않음
  - 이로 인해 훨씬 적은 메모리를 소비함
- 성능
  - 매우 큰 데이터 셋의 경우 HashMap만큼 빠르지는 않지만,
  - 중간 크기의 데이터 셋의 경우 메모리 최적화 덕분에 더 나은 성능을 제공함
- Null 키 값 사용 불가

### SparseArray 사용의 이점
- 오토박싱 방지
  - HashMap<Integer, Object>에서는 키가 Integer 객체로 저장되므로
    박싱/언박싱 작업으로 인한 오버헤드가 발생함
  - 하지만 SparseArray는 int 키로 직접 작동하여 메모리와 계산 작업을 절약함
- 메모리 절약
  - 내부적으로 기본 배열을 사용하여, Entry와 같은 여러 객체를 생성하는 HashMap 구현에 비해
  - 메모리 차지 공간을 줄였음
- 컴팩트한 데이터 저장에 효율적
  - 적은 수의 카-값 쌍이 있는 밀도가 낮은(sparse) 데이터 셋이나
  - 키가 넓은 정수 범위에 걸쳐 드문드문 분포된 데이터 셋에 적합함
- 안드로이드 특화
  - 제한된 리소스 시나리오 대처를 위해 안드로이드 특화된 구조로 설계되었음
  - 안드로이드 UI 컴포넌트에서 View ID를 객체에 매핑하는 등의 시나리오에 효과적

### SparseArray의 한계
- 성능 트레이드 오프
  - SparseArray의 요소 접근은 키 조회를 위해 이진 탐색을 사용하므로
  - 매우 큰 데이터 셋의 경우 HashMap보다 느림
- 정수 키만 사용 가능

# Q22) 런타임 권한을 어떻게 처리하나요?
- 런타임 권한은 원활한 사용자 경험을 보장하고, 사용자 데이터에 접근하는 데 필수적임
- 안드로이드 6.0부터 런타임에 위험 권한을 명시적으로 요청해야 함으로써 사용자 개인 정보 보호를 강화

### 권한 요청하기
- 권한 처리를 단순화하는 ActivityResultLauncher API 사용

### 권한 근거 제공하기
- 경우에 따라 시스템은 shouldShowRequestPermissionRationale()을 사용해야 함
- 이를 통해 권한을 요청하기 전에 해당 기능을 사용하기 위해 권한이 필요한 근거를 표시하기를 권장함
- 이로써 사용자 경험을 개선하고 권한 획득 가능성을 높임(거부할 경우 설정으로 이동해서 허용해줘야 하므로)

### 권한 거부 처리하기
- 사용자가 권한을 여러 번 거부하면 안드로이드는 이를 영구 거부로 처리하여 앱이 다시 요청할 수 없게 됨
- 이 때 앱은 사용자에게 기능 제한 가능성에 대해 알리고, 필요한 경우 시스템 설정으로 안내해야 함

### 위치 권한 처리하기
- 위치 권한은 포그라운드/백그라운드 접근으로 분류됨
- 포그라운드 위치 접근에는 ACCESS_FINE_LOCATION 또는 ACCESS_COARSE_LOCATION
- 백그라운드 위치 접근에는 추가적으로 ACCESS_BACKGROUND_LOCATION 권한이 필요함
- 안드로이드 10(API 29)부터 백그라운드 위치를 요청하는 앱은 먼저 포그라운드 접근 권한을 요청한 다음
  별도로 백그라운드 권한을 요청해야 함

### 일회성 권한
- 안드로이드 11(API 30)은 위치,카메라,마이크에 대해 일회성 권한을 도입했음

# Q23) Looper, Handler, HandlerThread의 역할은 무엇인가요?
- 스레드를 관리하고 비동기 통신을 처리하기 위해 함께 작동하는 컴포넌트
- 백그라운드 스레드에서 작업을 수행하면서 UI 업데이트를 위해 메인 스레드와 상호 작용하기 위한 필수적인 컴포넌트

### Looper
- 스레드를 살아있게 유지하여 메시지/작업 큐를 순차적으로 처리하는 스레딩 모델의 일부

- 목적
  - 메시지큐를 지속적으로 모니터링하고
  - 메시지나 작업(runnable)을 적절한 Handler에 가져와 디스패치
- 사용법
  - 메시지를 처리하는 모든 스레드에는 Looper가 필요함
  - 메인스레드에는 자동으로 Looper가 있지만, 워커 스레드의 경우 명시적으로 준비해야 함
- 초기화
  - Looper.prepare()를 사용하여 스레드에 Looper를 연결하고
  - Looper.loop()를 사용하여 루프를 시작

### Handler
- 스레드의 메시지 큐 내에서 메시지나 작업을 보내고 처리하는 데 사용

- 목적
  - 한 스레드에서 다른 스레드로 작업이나 메시지를 전달
- 동작
  - Handler가 생성될 때, 생성된 스레드 및 해당 스레드의 Looper에 연결됨
  - Handler로 전송된 작업은 해당 스레드에서 처리됨

### HandlerThread
- 내장된 Looper를 가진 특수한 Thread
- 작업 또는 메시지 큐를 처리할 수 있는 백그라운드 스레드를 생성하는 과정을 단순화

- 목적
  - 자체 Looper를 가진 워커 스레드를 생성하여 해당 스레드에서 작업을 순차적으로 처리할 수 있도록 함
- 생명주기
  - start()로 시작한 다음, getLooper()를 사용하여 Looper를 얻음
  - 리소스를 해제하려면 quit() 또는 quitSafely()를 사용하여 Looper를 종료

### 주요 차이점 및 관계
- Looper
  - 메시지 처리의 중추
  - 스레드를 살아있게 유지하고 메시지 큐를 처리
- Handler
  - Looper와 상호작용하여 메시지와 작업을 큐에 넣거나 처리
- HandlerThread
  - 자동 Looper 설정으로 백그라운드 스레드 생성을 단순화

### 사용 사례
- Looper
  - 메인 스레드 또는 워커 스레드에서 연속적인 메시지 큐를 관리하는 데 사용
- Handler
  - 스레드 간 통신에 이상적(백그라운드에서 UI 업데이트)
- HandlerThread
  - 데이터 처리나 네트워크 요청과 같이 전용 스레드가 필요한 백그라운드 작업에 적합





