# Q31) 애플리케이션 용량을 어떻게 줄이나요?
앱 용량을 줄이는 것은 저장 공간이 제한적이고 인터넷 연결이 느린 사용자의 경험을 개선하는 데 필수적이다.
하지만 이 과정에서 애플리케이션의 기능과 동작을 손상시키지 않으면서 용량을 줄이기 위해 여러 전략을 사용할 수 있다.

1. 사용하지 않는 리소스 제거하기
- 이미지/레이아웃/문자열과 같이 사용되지 않는 리소스는 불필요하게 APK/AAB 크기를 증가시킨다.
- Lint를 통해 사용되지 않는 리소스를 식별 및 제거하고, build.gradle 파일에서 shrinkResource를 활성화하여 빌드 프로세스 중에 사용되지 않는 리소스를 자동으로 제거해야 한다.
   
2. R8로 코드 축소 활성화하기
- R8은 사용되지 않는 클래스와 메서드를 제거하며, 코드를 난독화하여 더 컴팩트하게 만듬

3. 리소스 최적화 사용하기
- 이미지 및 XML 파일과 같은 리소스를 최적화하면 앱 용량을 크게 줄일 수 있음
- 벡터 드로어블: 확장 가능한 그래픽을 위해 레스터 이미지 대신 용량을 덜 차지하는 벡터 드로어블로 대체함
- 이미지 압축: TinyPNG 또는 ImageMagick과 같은 도구를 사용하여 눈에 띄는 품질 손상 없이 레스터 이미지를 압축
- WebP 형식: 이미지를 PNG/JPEG보다 압축률이 좋은 WebP 형식으로 변환하기

💡 레스터 이미지란?

4. Android App Bundles(AAB) 사용하기
- AAB 형식으로 변환하면 구글 플레이가 개별 기기에 맞는 최적화된 APK를 제공할 수 있음
- 특정 구성(화면 밀도, CPU 아키텍처, 언어)에 필요한 리소스와 코드만 포함하여 앱 용량을 줄임

5. 불필요한 의존성 제거하기
- 안드로이드 스튜디오의 Gradle dependency analyzer를 사용하여 무거운 라이브러리/전이 의존성을 식별할 수 있음

6. 네이티브 라이브러리 최적화하기
- 사용하지 않는 아키텍처 제외: build.gradle 파일의 abiFilters 옵션을 사용하여 필요한 ABI만 포함
- 디버그 심볼 제거: stripDebugSymbols를 사용하여 네이티브 라이브러리에서 디버깅 심볼을 제거

7. Proguard 규칙을 구성하여 디버그 정보 줄이기
- 디버깅 메타데이터는 최종 APK/AAB에 불필요한 무게를 더하므로 proguard 설정을 통해 이러한 정보를 제거

8. 동적 기능 사용하기
- 자주 사용되지 않는 기능을 주문형 모듈(필요한 경우 설치)로 분리하여 앱을 모듈화할 수 있음
- 이를 통해 초기 다운로드 용량을 줄이는 도움이 됨

9. 앱 내 대용량 에섯 피하기
- 비디오/고해상도 이미지와 같은 대용량 에셋은 CDN(콘텐츠 전송 네트워크)에 호스팅하고 런타임에 동적으로 로드
- 미디어 콘텐츠는 앱과 함께 번들링하는 대신 스트리밍을 사용하기

### 실전 질문
#### 앱에 APK/AAB 크기를 크게 증가시키는 고해상도 이미지가 포함되어 있습니다. 시각적 품질을 유히자면서 이미지 리소스를 어떻게 최적화하고, 최대 효율성을 위해 어떤 이미지 포맷을 사용할 수 있을까요?

### 실전 질문
#### 애플리케이션은 보통 여러 기능들이 포함되어 있지만 그 중 일부는 사용자가 자주 사용하지 않습니다. 해당 기능을 필요할 때부터 사용할 수 있도록 하여 초기 앱 용량을 줄이는 방법에는 무엇이 있을까요?


# Q32) 안드로이드 애플리케이션의 프로세스란 무엇이며, 안드로이드 운영체제는 이를 어떻게 관리하나요?
- 안드로이드에서 프로세스는 애플리케이션이 실행되는 환경
- 각 안드로이드 앱은 다른 앱과 격리된 자체 프로세스에서 단일 실행 스레드로 작동하여 시스템 보안, 메모리 관리, 내결함성을 보장함
- 안드로이드 프로세스는 리눅스 커널을 사용하여 운영 체제에 의해 관리되며 엄격한 생명주기 규칙을 따름
- 기본적으로 동일한 애플리케이션의 모든 컴포넌트는 메인 스레드라는 동일한 프로세스 및 스레드에서 실행됨

### 안드로이드에서 프로세스 작동 방식
- 안드로이드 애플리케이션이 시작되면 운영 체제는 리눅스 `fork()` 시스템 함수를 호출하여 해당 앱을 위한 새 프로세스를 생성
- 각 프로세스는 Dalvik/ART 가상 머신의 고유 인스턴스에서 실행되어 안전하고 독립적인 실행을 보장함
- 안드로이드는 각 프로세스에 고유한 리눅스 사용자 ID(UID)를 할당하여 권한 제어 및 파일 시스템 격리를 포함한 엄격한 보안 경계를 적용함

### 애플리케이션 컴포넌트와 프로세스 연결
- 개발자는 AndroidManifest.xml 파일의 android:process 속성을 사용하여 프로세스 할당을 커스텀할 수 있음
- 이 속성은 <activity>, <service>, <receiver>, <provider>와 같은 컴포넌트에 적용될 수 있어 컴포넌트가 별도의 프로세스에서 실행되거나 선택적으로 프로세스를 공유할 수 있음
- <application> 태그도 이 속성을 지원하여 모든 컴포넌트의 기본 프로세스를 정의함
- 만약 애플리케이션의 컴포넌트가 동일한 리눅스 사용자 ID를 가지고 동일한 인증서로 서명된 경우 동일한 프로세스를 공유할 수 있음
- 안드로이드는 시스템 리소스 요구에 따라 프로세스를 동적으로 관리하므로, 필요 시에 우선순위가 낮은 프로세스를 종료할 수 있음
  -> 더 이상 보이지 않는 Activity를 호스팅하는 프로세스는 우선순위가 낮으므로 종료될 가능성이 더 높음

### 프로세스와 앱 생명주기
- 안드로이드는 시스템 메모리와 앱의 현재 상ㅌ채를 기반으로 프로세스 및 앱 생명주기를 관리하며, 엄격한 우선순위 계층을 따름

1. 포그라운드 프로세스
- 사용자와 활발하게 상호 작용하며 실행중인 프로세스
- 가장 우선순위가 높은 프로세스이며, 거의 종료되지 않음
2. 보이는 프로세스
- 사용자에게 보이지만 활발하게 상호 작용하지 않는 프로세스(ex: 다이얼로그 뒤의 Activity)

3. 서비스 프로세스
- 데이터 동기화/음악 재생과 같은 작업을 수행하는 백그라운드를 실행하는 프로세스

4. 캐시된 프로세스
- 더 빠른 재실행을 위해 메모리에 유지되는 유휴 프로세스
- 우선순위가 가장 낮으며, 메모리가 부족할 때 가장 먼저 종료됨

### 보안 및 권한
- 각 안드로이드 프로세스는 리눅스 보안 모델을 사용하여 샌드박스 처리되어 엄격한 권한 기반 접근 제어를 시행함
- 이런 격리는 안드로이드 권한 시스템을 통해 명시적으로 권한이 부여되지 않는 한 애플리케이션이 다른 프로세스의 데이터에 접근할 수 없도록 보장함
- 이 보안 모델은 안드로이드의 멀티태스킹 환경의 기본이며, 시스템 안정성과 데이터 개인 정보 보호를 모두 지원함ㅂ

### 실전 질문
#### 서로 다른 안드로이드 컴포넌트들을 별도의 프로세스에서 실행해야 하는 애플리케이션을 개발중이라고 해봅시다. AndroidManifest에서 이를 어떻게 구성하며, 여러 프로세스를 사용할 때의 잠재적인 단점은 무엇인가요?


#### 안드로이드는 메모리가 부족할 때 어떤 프로세스를 종료할지 결정하기 위해 우선순위 기반 프로세스 관리 시스템을 사용합니다. 시스템이 프로세스 우선순위를 어떻게 정하는지, 그리고 중요한 프로세스가 종료되는 것을 방지하기 위해 개발자가 따라야 할 전략은 무엇인지 설명해 주세요.

### Pro Tips for Mastery: Activities, Services, Broadcast Receivers, Content Providers가 안드로이드의 4대 주요 컴포넌트라고 불리는 이유는 무엇인가요?


# Q33) View 생명주기를 설명해주세요
- 안드로이드에서 View 생명주기는 View가 생성되고, Activity나 Fragment에 연결되고, 화면에 표시되고, 최종적으로 소멸되거나 분리되는 동안 거치는 생명주기 이벤트를 나타냄
- 이 생명주기의 이해를 통해 View의 초기화/렌더링/소멸을 관리하고, 사용자 작업 또는 시스템 이벤트에 응답하여 View 생명ㅈ우기에 따라 커스텀 뷰를 구현하며, 적절한 시점에 리소스를 폐기하는 데 도움이 됨
<img width="518" height="759" alt="스크린샷 2025-08-08 오후 8 17 27" src="https://github.com/user-attachments/assets/b86923bb-f64e-4e02-84b1-83865bd1541e" />

1. View 생성(onAttachToWindow)
- View가 인스턴스화되거나 XML 레이아웃에서 인플레이션되는 단계
- 리스너 설정 및 데이터 바인딩과 같은 초기 설정 작업이 여기서 수행됨
- `onAttachToWindow()` 메서드는 View가 부모 View에 추가되고 화면 렌더링을 할 준비를 마쳤을 때 트리거됨

2. Layout 단계(onMeasure, onLayout)
- View의 크기와 위치를 측정함
- `onMeasure()` 메서드는 레이아웃 매개변수와 부모 제약 조건에 따라 View의 너비와 높이를 결정함
- 측정된 후 onLayout() 메서드는 View를 부모 내에 배치하여 화면에 표시될 위치를 최종 결정함

3. Drawing 단계
- 크기와 위치가 최종 결정된 후, `onDraw()` 메서드는 텍스트/이미지와 같은 View의 내용을 Canvas에 렌더링
- 커스텀 View는 해당 메서드를 재정의하여 커스텀 드로잉 로직을 구현할 수 있음

4. Event 처리
- 상호 작용하는 View는 이 단계에서 터치 이벤트, 클릭, 제스처 같은 사용자 상호 작용을 처리함
- `onTouchEvent()` 및 `onClick()`과 같은 메서드는 이러한 이벤트를 처리하고 사용자 입력에 대한 View의 응답을 정의하는 데 사용됨

5. View 분리(onDetachedFromWindow)
- View가 화면과 부모 ViewGroup에서 제거될 때, `onDetachedFromWindow()` 메서드가 호출됨
- 이 단계는 리소스를 정리하거나 리스너를 분리하는 데 이상적임

6. View 소멸
- View가 더 이상 사용되지 않으면 GC됨
- 개발자는 메모리 누수를 방지하고 성능을 최적화하기 위해 이벤트 리스너나 백그라운드 작업과 같은 모든 리소스가 적절하게 해제되었는지 확인해야 함

### 실전 질문
#### 이미지 로딩이나 애니메이션 설정과 같이 비용이 많이 드는 기능을 포함하는 커스텀 View를 만든다고 가정해 봅시다. View 생명주기의 어느 시점에서 이러한 리소스 및 기능을 초기화해야 하며, 메모리 누수를 어떻게 방지할 수 있나요?

#### 애플리케이션에 성능 문제가 발생하는 동적으로 생성된 View를 포함하는 복잡한 레이아웃이 있습니다. 적절한 응답성을 유지하면서 렌더링 효율성을 향상시키기 위해 `onMeasure()` 및 `onLayout()` 메서드를 어떻게 최적화할 수 있을까요?

### Pro Tips for Mastery: View의 `findViewTreeLifecycleOwner()` 함수는 어떤 역할을 하나요?
- View 클래스의 확장 함수임
- View 트리 계층을 거슬러 올라가 View 트리에 연결된 가장 가까운 LifecycleOwner를 찾아 반환함
- LifecycleOwner는 일반적으로 Activity/Fragment/LifecycleOwner를 구현하는 커스텀 컴포넌트와 같은 호스팅 컴포넌트의 생명주기 범위를 나타냄 -> 무슨말임?

#### `findViewTreeLifectcleOwner()`를 사용하는 이유
- 이 함수는 LiveData, ViewModel 또는 LifecycleObserver와 같은 생명주기 인식 요소와 상호 작용해야 하는 커스텀 View나 서드파티 컴포넌트로 작업할 때 특히 유용함
- 이를 통해 View는 호스팅 Activity/Fragment에 대한 명시적인 의존성 없이 연관된 생명주기에 접근할 수 있음

- 보장되는 것들
  - 생명주기를 인식하는 컴포넌트가 올바른 생명주기에 제대로 바인딩됨
  - 생명주기가 끝나면 관찰자가 정리되도록 하여 메모리 누수를 방지할 수 있음

- 주요 사용 사례
  - 커스텀 뷰: 커스텀 뷰 내의 생명주기 인식 컴포넌트가 생명주기 관찰자를 관찰하거나 리소스를 관리할 수 있음
  - 서드파티 라이브러리: 재사용 가능한 UI 컴포넌트가 명시적 생명주기 관리 없이 생명주기 인식 리소스와 상호작용할 수 있음
  - 로직 결합도 분리: View가 View 트리에서 자체 LifecycleOwner를 독립적으로 획득하도록 하여 부모 클래스와의 결합도 감소

- 한계
  - View 트리에 LifecycleOwner가 존재해야 함
  - LifecycleOwner가 제공하는 소유자가 없으면 함수는 null을 반환하므로 크래시나 에상치 않은 동작이 발생할 수 있음


# Q34) View와 ViewGroup의 차이점은 무엇인가요?
- 둘 다 android.view 패키지의 일부이지만, UI 계층 구조에서 다른 목적을 가짐

### View란?
- 화면에 표시되는 직사각형 형태의 UI를 구현하는 최소 단위의 단일 컴포넌트
- Button, TextView, ImageView, EditText와 같은 모든 UI 컴포넌트의 기본 클래스가 됨
- 각 View는 화면에 렌더링되면 터치/키 이벤트와 같이 애플리케이션 사용자와의 상호 작용을 처리




### ViewGroup이란?
- 


# Q35) ViewStub이란 무엇이고, 이를 사용하여 UI 성능을 최적화해 본 경험이 있나요?



# Q36) 커스텀 뷰는 어떻게 구현하나요?



# Q37) Canvas란 무엇이며 어떻게 활용하나요?



