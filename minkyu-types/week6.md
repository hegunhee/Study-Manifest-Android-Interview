# Q31) 애플리케이션 용량을 어떻게 줄이나요?
앱 용량을 줄이는 것은 저장 공간이 제한적이고 인터넷 연결이 느린 사용자의 경험을 개선하는 데 필수적이다.
하지만 이 과정에서 애플리케이션의 기능과 동작을 손상시키지 않으면서 용량을 줄이기 위해 여러 전략을 사용할 수 있다.

1. 사용하지 않는 리소스 제거하기
- 이미지/레이아웃/문자열과 같이 사용되지 않는 리소스는 불필요하게 APK/AAB 크기를 증가시킨다.
- Lint를 통해 사용되지 않는 리소스를 식별 및 제거하고, build.gradle 파일에서 shrinkResource를 활성화하여 빌드 프로세스 중에 사용되지 않는 리소스를 자동으로 제거해야 한다.
   
2. R8로 코드 축소 활성화하기
- R8은 사용되지 않는 클래스와 메서드를 제거하며, 코드를 난독화하여 더 컴팩트하게 만듬

3. 리소스 최적화 사용하기
- 이미지 및 XML 파일과 같은 리소스를 최적화하면 앱 용량을 크게 줄일 수 있음
- 벡터 드로어블: 확장 가능한 그래픽을 위해 레스터 이미지 대신 용량을 덜 차지하는 벡터 드로어블로 대체함
- 이미지 압축: TinyPNG 또는 ImageMagick과 같은 도구를 사용하여 눈에 띄는 품질 손상 없이 레스터 이미지를 압축
- WebP 형식: 이미지를 PNG/JPEG보다 압축률이 좋은 WebP 형식으로 변환하기

💡 레스터 이미지란?

4. Android App Bundles(AAB) 사용하기
- AAB 형식으로 변환하면 구글 플레이가 개별 기기에 맞는 최적화된 APK를 제공할 수 있음
- 특정 구성(화면 밀도, CPU 아키텍처, 언어)에 필요한 리소스와 코드만 포함하여 앱 용량을 줄임

5. 불필요한 의존성 제거하기
- 안드로이드 스튜디오의 Gradle dependency analyzer를 사용하여 무거운 라이브러리/전이 의존성을 식별할 수 있음

6. 네이티브 라이브러리 최적화하기
- 사용하지 않는 아키텍처 제외: build.gradle 파일의 abiFilters 옵션을 사용하여 필요한 ABI만 포함
- 디버그 심볼 제거: stripDebugSymbols를 사용하여 네이티브 라이브러리에서 디버깅 심볼을 제거

7. Proguard 규칙을 구성하여 디버그 정보 줄이기
- 디버깅 메타데이터는 최종 APK/AAB에 불필요한 무게를 더하므로 proguard 설정을 통해 이러한 정보를 제거

8. 동적 기능 사용하기
- 자주 사용되지 않는 기능을 주문형 모듈(필요한 경우 설치)로 분리하여 앱을 모듈화할 수 있음
- 이를 통해 초기 다운로드 용량을 줄이는 도움이 됨

9. 앱 내 대용량 에섯 피하기
- 비디오/고해상도 이미지와 같은 대용량 에셋은 CDN(콘텐츠 전송 네트워크)에 호스팅하고 런타임에 동적으로 로드
- 미디어 콘텐츠는 앱과 함께 번들링하는 대신 스트리밍을 사용하기

### 실전 질문
#### 앱에 APK/AAB 크기를 크게 증가시키는 고해상도 이미지가 포함되어 있습니다. 시각적 품질을 유히자면서 이미지 리소스를 어떻게 최적화하고, 최대 효율성을 위해 어떤 이미지 포맷을 사용할 수 있을까요?

### 실전 질문
#### 애플리케이션은 보통 여러 기능들이 포함되어 있지만 그 중 일부는 사용자가 자주 사용하지 않습니다. 해당 기능을 필요할 때부터 사용할 수 있도록 하여 초기 앱 용량을 줄이는 방법에는 무엇이 있을까요?


# Q32) 안드로이드 애플리케이션의 프로세스란 무엇이며, 안드로이드 운영체제는 이를 어떻게 관리하나요?
- 안드로이드에서 프로세스는 애플리케이션이 실행되는 환경
- 각 안드로이드 앱은 다른 앱과 격리된 자체 프로세스에서 단일 실행 스레드로 작동하여 시스템 보안, 메모리 관리, 내결함성을 보장함
- 안드로이드 프로세스는 리눅스 커널을 사용하여 운영 체제에 의해 관리되며 엄격한 생명주기 규칙을 따름
- 기본적으로 동일한 애플리케이션의 모든 컴포넌트는 메인 스레드라는 동일한 프로세스 및 스레드에서 실행됨

### 안드로이드에서 프로세스 작동 방식
- 안드로이드 애플리케이션이 시작되면 운영 체제는 리눅스 `fork()` 시스템 함수를 호출하여 해당 앱을 위한 새 프로세스를 생성
- 각 프로세스는 Dalvik/ART 가상 머신의 고유 인스턴스에서 실행되어 안전하고 독립적인 실행을 보장함
- 안드로이드는 각 프로세스에 고유한 리눅스 사용자 ID(UID)를 할당하여 권한 제어 및 파일 시스템 격리를 포함한 엄격한 보안 경계를 적용함

### 애플리케이션 컴포넌트와 프로세스 연결
- 개발자는 AndroidManifest.xml 파일의 android:process 속성을 사용하여 프로세스 할당을 커스텀할 수 있음
- 이 속성은 <activity>, <service>, <receiver>, <provider>와 같은 컴포넌트에 적용될 수 있어 컴포넌트가 별도의 프로세스에서 실행되거나 선택적으로 프로세스를 공유할 수 있음
- <application> 태그도 이 속성을 지원하여 모든 컴포넌트의 기본 프로세스를 정의함
- 만약 애플리케이션의 컴포넌트가 동일한 리눅스 사용자 ID를 가지고 동일한 인증서로 서명된 경우 동일한 프로세스를 공유할 수 있음
- 안드로이드는 시스템 리소스 요구에 따라 프로세스를 동적으로 관리하므로, 필요 시에 우선순위가 낮은 프로세스를 종료할 수 있음
  -> 더 이상 보이지 않는 Activity를 호스팅하는 프로세스는 우선순위가 낮으므로 종료될 가능성이 더 높음

### 프로세스와 앱 생명주기
- 안드로이드는 시스템 메모리와 앱의 현재 상ㅌ채를 기반으로 프로세스 및 앱 생명주기를 관리하며, 엄격한 우선순위 계층을 따름

1. 포그라운드 프로세스
- 사용자와 활발하게 상호 작용하며 실행중인 프로세스
- 가장 우선순위가 높은 프로세스이며, 거의 종료되지 않음
2. 보이는 프로세스
- 사용자에게 보이지만 활발하게 상호 작용하지 않는 프로세스(ex: 다이얼로그 뒤의 Activity)

3. 서비스 프로세스
- 데이터 동기화/음악 재생과 같은 작업을 수행하는 백그라운드를 실행하는 프로세스

4. 캐시된 프로세스
- 더 빠른 재실행을 위해 메모리에 유지되는 유휴 프로세스
- 우선순위가 가장 낮으며, 메모리가 부족할 때 가장 먼저 종료됨

### 보안 및 권한
- 각 안드로이드 프로세스는 리눅스 보안 모델을 사용하여 샌드박스 처리되어 엄격한 권한 기반 접근 제어를 시행함
- 이런 격리는 안드로이드 권한 시스템을 통해 명시적으로 권한이 부여되지 않는 한 애플리케이션이 다른 프로세스의 데이터에 접근할 수 없도록 보장함
- 이 보안 모델은 안드로이드의 멀티태스킹 환경의 기본이며, 시스템 안정성과 데이터 개인 정보 보호를 모두 지원함ㅂ

### 실전 질문
#### 서로 다른 안드로이드 컴포넌트들을 별도의 프로세스에서 실행해야 하는 애플리케이션을 개발중이라고 해봅시다. AndroidManifest에서 이를 어떻게 구성하며, 여러 프로세스를 사용할 때의 잠재적인 단점은 무엇인가요?


#### 안드로이드는 메모리가 부족할 때 어떤 프로세스를 종료할지 결정하기 위해 우선순위 기반 프로세스 관리 시스템을 사용합니다. 시스템이 프로세스 우선순위를 어떻게 정하는지, 그리고 중요한 프로세스가 종료되는 것을 방지하기 위해 개발자가 따라야 할 전략은 무엇인지 설명해 주세요.

### Pro Tips for Mastery: Activities, Services, Broadcast Receivers, Content Providers가 안드로이드의 4대 주요 컴포넌트라고 불리는 이유는 무엇인가요?


# Q33) View 생명주기를 설명해주세요
- 안드로이드에서 View 생명주기는 View가 생성되고, Activity나 Fragment에 연결되고, 화면에 표시되고, 최종적으로 소멸되거나 분리되는 동안 거치는 생명주기 이벤트를 나타냄
- 이 생명주기의 이해를 통해 View의 초기화/렌더링/소멸을 관리하고, 사용자 작업 또는 시스템 이벤트에 응답하여 View 생명ㅈ우기에 따라 커스텀 뷰를 구현하며, 적절한 시점에 리소스를 폐기하는 데 도움이 됨
<img width="518" height="759" alt="스크린샷 2025-08-08 오후 8 17 27" src="https://github.com/user-attachments/assets/b86923bb-f64e-4e02-84b1-83865bd1541e" />

1. View 생성(onAttachToWindow)
- View가 인스턴스화되거나 XML 레이아웃에서 인플레이션되는 단계
- 리스너 설정 및 데이터 바인딩과 같은 초기 설정 작업이 여기서 수행됨
- `onAttachToWindow()` 메서드는 View가 부모 View에 추가되고 화면 렌더링을 할 준비를 마쳤을 때 트리거됨

2. Layout 단계(onMeasure, onLayout)
- View의 크기와 위치를 측정함
- `onMeasure()` 메서드는 레이아웃 매개변수와 부모 제약 조건에 따라 View의 너비와 높이를 결정함
- 측정된 후 onLayout() 메서드는 View를 부모 내에 배치하여 화면에 표시될 위치를 최종 결정함

3. Drawing 단계
- 크기와 위치가 최종 결정된 후, `onDraw()` 메서드는 텍스트/이미지와 같은 View의 내용을 Canvas에 렌더링
- 커스텀 View는 해당 메서드를 재정의하여 커스텀 드로잉 로직을 구현할 수 있음

4. Event 처리
- 상호 작용하는 View는 이 단계에서 터치 이벤트, 클릭, 제스처 같은 사용자 상호 작용을 처리함
- `onTouchEvent()` 및 `onClick()`과 같은 메서드는 이러한 이벤트를 처리하고 사용자 입력에 대한 View의 응답을 정의하는 데 사용됨

5. View 분리(onDetachedFromWindow)
- View가 화면과 부모 ViewGroup에서 제거될 때, `onDetachedFromWindow()` 메서드가 호출됨
- 이 단계는 리소스를 정리하거나 리스너를 분리하는 데 이상적임

6. View 소멸
- View가 더 이상 사용되지 않으면 GC됨
- 개발자는 메모리 누수를 방지하고 성능을 최적화하기 위해 이벤트 리스너나 백그라운드 작업과 같은 모든 리소스가 적절하게 해제되었는지 확인해야 함

### 실전 질문
#### 이미지 로딩이나 애니메이션 설정과 같이 비용이 많이 드는 기능을 포함하는 커스텀 View를 만든다고 가정해 봅시다. View 생명주기의 어느 시점에서 이러한 리소스 및 기능을 초기화해야 하며, 메모리 누수를 어떻게 방지할 수 있나요?

#### 애플리케이션에 성능 문제가 발생하는 동적으로 생성된 View를 포함하는 복잡한 레이아웃이 있습니다. 적절한 응답성을 유지하면서 렌더링 효율성을 향상시키기 위해 `onMeasure()` 및 `onLayout()` 메서드를 어떻게 최적화할 수 있을까요?

### Pro Tips for Mastery: View의 `findViewTreeLifecycleOwner()` 함수는 어떤 역할을 하나요?
- View 클래스의 확장 함수임
- View 트리 계층을 거슬러 올라가 View 트리에 연결된 가장 가까운 LifecycleOwner를 찾아 반환함
- LifecycleOwner는 일반적으로 Activity/Fragment/LifecycleOwner를 구현하는 커스텀 컴포넌트와 같은 호스팅 컴포넌트의 생명주기 범위를 나타냄 -> 무슨말임?

#### `findViewTreeLifectcleOwner()`를 사용하는 이유
- 이 함수는 LiveData, ViewModel 또는 LifecycleObserver와 같은 생명주기 인식 요소와 상호 작용해야 하는 커스텀 View나 서드파티 컴포넌트로 작업할 때 특히 유용함
- 이를 통해 View는 호스팅 Activity/Fragment에 대한 명시적인 의존성 없이 연관된 생명주기에 접근할 수 있음

- 보장되는 것들
  - 생명주기를 인식하는 컴포넌트가 올바른 생명주기에 제대로 바인딩됨
  - 생명주기가 끝나면 관찰자가 정리되도록 하여 메모리 누수를 방지할 수 있음

- 주요 사용 사례
  - 커스텀 뷰: 커스텀 뷰 내의 생명주기 인식 컴포넌트가 생명주기 관찰자를 관찰하거나 리소스를 관리할 수 있음
  - 서드파티 라이브러리: 재사용 가능한 UI 컴포넌트가 명시적 생명주기 관리 없이 생명주기 인식 리소스와 상호작용할 수 있음
  - 로직 결합도 분리: View가 View 트리에서 자체 LifecycleOwner를 독립적으로 획득하도록 하여 부모 클래스와의 결합도 감소

- 한계
  - View 트리에 LifecycleOwner가 존재해야 함
  - LifecycleOwner가 제공하는 소유자가 없으면 함수는 null을 반환하므로 크래시나 에상치 않은 동작이 발생할 수 있음


# Q34) View와 ViewGroup의 차이점은 무엇인가요?
- 둘 다 android.view 패키지의 일부이지만, UI 계층 구조에서 다른 목적을 가짐

### View란?
- 화면에 표시되는 직사각형 형태의 UI를 구현하는 최소 단위의 단일 컴포넌트
- Button, TextView, ImageView, EditText와 같은 모든 UI 컴포넌트의 기본 클래스가 됨
- 각 View는 화면에 렌더링되면 터치/키 이벤트와 같이 애플리케이션 사용자와의 상호 작용을 처리

### ViewGroup이란?
- 여러 View 또는 다른 ViewGroup 요소를 포함하는 일종의 컨테이너
- LinearLayout, RelativeLayout, ContraintLayout, FrameLayout과 같은 레이아웃의 기본이 되는 클래스
- ViewGroup은 자식 View의 레이아웃과 위치를 관리하며 화면에서 자식 View들의 사이즈가 측정되고 그려지는 방식을 정의함

#### Additional Tips
- ViewGroup 클래스는 View를 확장하고 ViewParent 및 ViewManager 인터페이스를 모두 구현함
- 다른 View 객체를 위한 컨테이너 역할을 하므로 독립형 View보다 더 복잡하고 리소스 집약적
- ViewGroup 인스턴스의 과도한 중첩은 렌더링 성능에 부정적인 영향을 미칠 수 있음
- ViewParent 인터페이스는 View 객체의 부모 역할을 담당하며, 레이아웃 측정, 터치 이벤트 처리 및 렌더링 순서 관리
- ViewManager 인터페이스는 ViewGroup 계층 내에서 자식 View를 동적으로 추가하고 제거하는 메서드를 제공

### View와 ViewGroup의 주요 차이점
- 목적
  - View는 콘텐츠를 표시하거나 사용자와 상호 작용하도록 설계된 단일 UI 요소
  - ViewGroup은 여러 자식 View를 구성하고 관리하기 위한 컨테이너
- 계층
  - View는 UI 계층 구조의 리포 노드(다른 View를 포함할 수 없음)
  - ViewGroup은 여러 자식 뷰 또는 다른 ViewGroup 요소를 포함할 수 있는 브랜치 노드
- 레이아웃 동작
  - View는 레이아웃 매개변수에 의해 정의된 자체적인 크기와 위치를 가짐
  - ViewGroup은 Linear/ConstraintLayout과 같이 정의된 레이아웃 규칙을 사용하여 자식 View의 크기와 위치를 결정
- 상호작용 핸들링
  - View는 터치 및 키 이벤트를 처리할 수 있음
  - ViewGroup은 onInterceptTouchEvent와 같은 메서드를 사용하여 자식의 이벤트를 가로채고 관리할 수 있음
- 성능
  - ViewGroup은 계층 구조로 인해 렌더링에 복잡성을 더함

# Q35) ViewStub이란 무엇이고, 이를 사용하여 UI 성능을 최적화해 본 경험이 있나요?
- ViewStub은 명시적으로 필요할 때까지 레이아웃의 인플레이션을 지연시키는 데 사용되는 가볍고 보이지 않는 플레이스 홀더 뷰
- 앱 생명주기 동안 지금 당장 필요하지 않은 뷰를 필요한 시기에 적절하게 인플레이션하여 오버헤드를 피함으로써 성능을 개선

### ViewStub의 주요 특징
- 가벼움
  - ViewStub은 인플레이션될 때까지 레이아웃 공간을 차지하거나 리소스를 소비하지 않으므로 메모리 공간이 최소화된 매우 가벼운 뷰
- 인플레이션 지연
  - ViewStub에 지정된 실제 레이아웃은 inflate() 메서드가 호출되거나 ViewStub이 보이게 될 때만 인플레이션됨
- 일회성
  - 한 번 인플레이션되면 ViewStub은 뷰 계층 구조에서 인플레이션된 레이아웃으로 대체되며 재사용이 불가능

### ViewStub의 일반적인 사용 사례
- 조건부 레이아웃
  - ViewStub은 오류 메시지, 진행률 표시줄 또는 선택적 UI 요소와 같이 조건부로 표시되는 레이아웃에 이상적
- 초기 렌더링 시간 절감
  - 복잡하거나 리소스 집약적인 뷰의 인플레이션을 지연시킴으로써 Activity/Fragment의 초기 렌더링 시간을 개선하는 데 도움이 됨
- 동적 UI
  - 필요할 때만 화면에 동적으로 콘텐츠를 렌더링하는 데 사용될 수 있어 메모리 사용량 최적화
 
### ViewStub의 장점
- 최적화된 성능
  - 늦게 초기화 해도 되는 View 생성을 지연시켜 메모리 사용량을 줄이고 초기 렌더링 성능을 개선
- 쉬운 레이아웃 관리
  - View를 수동으로 추가하거나 제거하지 않고도 UI 요소를 선택적으로 렌더링하여 쉽게 관리
- 쉬운 사용성
  - API 사용이 간단하고 XML 통합이 쉬워 개발자가 쉽게 활용할 수 있음

### ViewStub의 한계
- 일회성
  - 일단 인플레이션되면 ViewStub은 View 계층 구조에서 제거되며 재사용할 수 없음
- 제한된 컨트롤
  - 플레이스홀더이므로 인플레이션될 때까지 사용자 상호 작용을 처리하거나 복잡한 작업을 수행할 수 없음

# Q36) 커스텀 뷰는 어떻게 구현하나요?
- 여러 화면에서 재사용해야 하는 특정 스펙과 동작을 가진 UI 컴포넌트를 사용자 정의할 때 필수적인 요소
- 커스텀 뷰를 활용하면 개발자는 애플리케이션 전체에서 일관성과 유지 관리성을 보장하면서 시각적 표현과 상호 작용 로직을 모두 맞춤설정할 수 있음
- 복잡한 UI 로직을 캡슐화하고 재사용성을 높이며 프로젝트 내 다른 레이어의 구조를 단순화할 수 있음
- 표준 UI 컴포넌트로 달성할 수 없는 디자인 요청사항을 구현해야 하는 경우 커스텀 뷰 개발이 필수적

### 커스텀 View 클래스 생성하기
- 기본 View 클래스(View, ImageView, TextView)를 확장하는 새 클래스를 정의
- 구현하려는 동작에 따라 `onDraw()`, `onMeasure()`, `onLayout()`과 같은 생성자/메서드를 오버라이드

### XML 레이아웃에서 커스텀 View 사용하기
- 커스텀 View 클래스를 생성한 후 XML 레이아웃 파일에서 직접 참조할 수 있음

### 커스텀 속성 추가하기(선택)
- res/values 폴더에 attrs.xml 파일을 만들어 커스텀 속성을 정의할 수 있으며 이를 통해 뷰 속성 커스텀 가능
- 커스텀 View 클래스에서 `context.obtainStyledArrtibutes()`를 사용하여 커스텀 속성 값을 가져올 수 있음

### 레이아웃 측정 처리하기(선택)
- 커스텀 View가 크기를 측정하는 방식을 수동으로 처리하고 싶고, 표준 View와 다르게 동작해야 하는 경우 `onMeasure()` 메서드를 재정의하여 구현

### Pro Tips for Mastery: 커스텀 View의 기본 생성자에서 @JvmOverloads를 사용할 때 왜 주의해야 하나요?
- Kotlin의 `@JvmOverloads` 어노테이션은 Kotlin 함수/클래스에 대해 여러 오버로드된 메서드/생성자를 자동으로 생성하여 Kotlin<>Java 간의 상호 운용성을 단순하는 기능
- Java가 기본 인수를 기본적으로 지원하지 않기 때문에 Kotlin의 기본 인수가 관련된 경우 특히 유용함
- @JvmOverloads를 사용하면 Kotlin 컴파일러는 컴파일된 바이트코드에서 기본 값을 가진 매개변수의 모든 가능한 조합을 나타내기 위해 여러 메서드 또는 생성자 시그니처를 컴파일 타임에 자동적으로 생성
- 신중하게 사용하지 않으면 의도치 않게 기본 View 스타일을 재정의하여 의도된 스타일링이 손실될 수 있음
- Button/TetxView와 같이 미리 정의된 스타일이 있는 안드로이드 View를 확장하는 커스텀 View를 만들 때 문제가 됨

# Q37) Canvas란 무엇이며 어떻게 활용하나요?
- Canvas는 커스텀 드로잉을 위한 핵심 구성 요소
- 화면/Bitmap과 같은 다른 드로잉이 가능한 표면에 직접 그래픽을 렌더링하기 위한 인터페이스를 제공함
- 개발자에게 드로잉 프로세스에 대한 완전한 제어를 제공하여 커스텀 View, 애니메이션 및 시각 효과를 만드는 데 활용됨

### Canvas 작동 방식
- 도형, 텍스트, 이미지 및 기타 콘텐츠를 그릴 수 있는 2D 드로잉 표면을 나타냄
- 그려진 콘텐츠가 어떻게 보여야 하는지(색상, 스타일, 스트로크 등) 정의하는 Paint 클래스와 긴밀하게 상호 작용
- 커스텀 View의 `onDraw()`메서드를 재정의하면 Canvas 객체가 전달되어 무엇을 그릴 지 정의할 수 있음

### Canvas의 일반적인 작업
- 도형
  - drawCircle(), drawRect(), drawLine()과 같은 메서드를 사용하여 원, 사각형, 선 같은 도형을 그릴 수 있음
- 텍스트
  - drawText() 메서드는 지정된 좌표와 모양으로 텍스트를 렌더링함
- 이미지
  - drawBitmap()을 사용하여 이미지를 렌더링
- 커스텀 패스
  - Path 객체와 drawPath()를 결합하여 복잡한 모양을 그릴 수 있음

### 변환
- Canvas는 크기 조절, 회전, 이동과 같은 변환을 지원함
- Canvas의 좌표계를 수정하여 복잡한 장면을 더 쉽게 그릴 수 있음
- 이동
  - canvas.translate(dx, dy)를 사용하여 Canvas 원점을 새 위치로 이동
- 크기 조절
  - canvas.scale(sx, sy)를 사용하여 드로잉 크기를 배율로 조절
- 회전
  - canvas.rotate(degrees)를 사용하여 지정된 각도로 캔버스를 회전

### 사용 사례
- Canvas는 다음과 같이 고급 커스텀 그래픽이 필요한 시나리오에서 유용함
- Custom Views
  - 표준적으로 제공되는 컴포넌트로 달성할 수 없는 고유한 UI 컴포넌트 만들기
- Games
  - 정밀한 제어로 게임 그래픽을 렌더링하는 경우
- Charts and Diagrams
  - 커스텀 형식으로 데이터를 시각화해야 하는 경우
- Image Processing
  - 프로그래밍 방식으로 이미지 수정 또는 결합이 필요한 경우





























