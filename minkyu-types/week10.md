### Q59) 장기적으로 실행되는 백그라운드 작업을 어떻게 관리하나요?
#### WorkManager
- 앱이 닫히거나 기기 재부팅 후에도 실행되어야 하는 작업은 WorkManager가 공식적으로 권장되는 솔루션
- 백그라운드 작업을 관리하고, 네트워크 가용성/충전 상태와 같은 제약 조건 하에서 작업이 실행되도록 보장함
- 로그 업로드, 데이터 동기화, 비디오 파일 업로드 등이 일반적인 사용 사례

#### Service
- 음악 재생/위치 추적과 같이 지속적이고 오랜 실행이 필요한 작업에는 Service가 이상적
- Service는 UI와 독립적으로 실행되며, 앱이 백그라운드에 있을 때도 계속 실행될 수 있음
- 만약 작업이 알림과 함께 사용자가 인지할 수 있는 상황에서 실행되어야 하는 경우에는 Foreground Service를 사용함

#### Kotlin Coroutines/Dispatchers
- 앱 생명주기에 연결된 작업은 Coroutines를 사용하며, 언어 수준에서 깔끔하고 구조화된 접근 방식을 제공함
- 무거운 작업을 오프로드하려면 Dispatchers.IO를 사용하고, CPU 집약적인 계산에는 Dispatchers.Default를 사용함
- 이 방식은 앱이 닫힌 후에도 유지될 필요가 없는 작업에 이상적

##### "CPU 집약적"은 무엇일까?
- 오해: I/O 작업보다 훨씬 무겁고 CPU를 많이 사용해야할 것 처럼 생각되지만, 실제로는 그렇지 않음
- CPU 집약적인 작업은 연산적인 능력을 요구하며, 사용 가능한 CPU 코어 수에 의해 제약을 받음
- 즉, 디바이스에서 사용가능한 코어의 수만큼만 쓰레드를 생성하여 작업을 수행함
- 예를 들어 암호화/이미지 처리/비디오 인코딩/데이터 분석과 같은 작업이 있음
- 이러한 작업들은 전적으로 CPU에 의존하기 때문에 사용 가능한 코어 수보다 많은 스레드를 추가하면 성능 향상보다는 스레드 경합이 발생하는 경우가 많음
- 반면, I/O 관련 작업은 CPU 코어 수보다 많은 스레드를 사용함으로써 여러 I/O 작업이 CPU 경합을 일으키지 않고 동시에 실행될 수 있도록 함

#### JobScheduler
- 작업이 기기 전체 작업과 관련되고, 특정 조건(충전 중에만 실행되는 등)이 필요한 경우 적합함
- 즉시 실행이 필요하지 않은 작업에 적합함(WorkManager는 내부적으로 JobScheduler를 활용함)

##### 실전 질문
- 안드로이드 앱에서 백엔드 서버로부터 대용량 파일(수백 MB)을 다운로드하는 기능을 구현해야 합니다. 다운로드는 앱이 닫혀도 계속되어야 하며, 성능/네트워크 조건 측면에서 효율적이어야 합니다. 어떤 것을 선택하여 구현하실 건가요?

### Q60) Json 형식을 객체로 어떻게 직렬화하나요?
- 최신 안드로이드 앱은 원격 서버와 자주 상호 작용하기 때문에 JSON을 객체로 직렬화하는 것이 일반적임
- 일반적으로 JSON 형식으로 데이터를 자주 교환하는데, 가볍고 가독성이 좋으며 플랫폼 독립적이기 때문임
- Kotlin 객체를 JSON으로 직렬화하여 데이터를 백엔드로 보내고, JSON 응답을 받으면 다시 객체로 역직렬화해야 함

#### 직렬화 & 역직렬화란?
- 직렬화: 객체/데이터 구조를 나중에 쉽게 저장/전송/재구성할 수 있는 형식으로 변환하는 프로세스
- 역직렬화: 직렬화된 데이터를 가져와 애플리케이션에서 작업할 수 있는 메모리 내 객체로 다시 재구성하는 역 프로세스

### kotlinx.serialization
- 어노테이션을 사용하여 직렬화 동작을 정의하고, JSON 뿐 아니라 ProtoBuf와 같은 다른 형식과도 원활하게 동작함
- Kotlin 컴파일러 플러그인을 사용하여 Kotlin 객체를 JSON 문자열로 직렬화하고, JSON 문자열을 다시 Kotlin 객체로 역직렬화하는 타입 안전성을 보장하며, 내부적으로 리플렉션을 사용하지 않으므로 런타임 성능이 저하되지 않음
- Moshi/Gson처럼 리플렉션으로 인한 런타임 성능 저하 없이 효율적인 직렬화를 수행할 수 있다는 장점이 있음
- Moshi
  - Kotlin 지원 강조(null 가능성/기본 파라미터 기능 지원), 타입 안전성 보장
  - 리플렉션 기반/코드 생성 기반 2가지 방식을 지원함
  - 리플렉션 기반은 빠른 셋업 환경을 제공하지만, 런타임 성능 오버헤드 발생함
  - 코드생성 기반은 컴파일 타임에 어댑터를 생성하여 더 나은 성능을 제공함
- Gson
  - JVM 기반으로 동작함
  - 컴파일 타임 안전성을 제공하지 않음(런타임 오류로 크래시 발생)

#### 실전 질문
- API의 JSON 응답이 주어졌을 때, 이를 Kotlin 데이터 클래스로 어떻게 역직렬화하시겠습니까? Kotlin을 사용하는 프로젝트에서 어떤 라이브러리를 선택할 것이고, 그 이유는 무엇인가요

-  Kotlin 데이터 클래스에 정의되지 않은 누락되거나 추가적인 필드가 있는 JSON 문자열을 역직렬화해야 하는 경우 어떻게 처리하실 건가요
  - 기본 파라미터를 지원하는 Moshi나 serialization을 사용하겠습니다.

### Q61) 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?
- Retrofit은 선언적 인터페이스를 제공하여 Api 상호작용을 단순화함
- OkHttp는 기본적인 HTTP 클라이언트 역할을 하여 연결 풀링/캐싱/효율적인 통신을 제공함
- Retrofit은 내부적으로 OkHttp를 HTTP 클라이언트로 사용하며, 인터셉터를 추가하여 로깅/인증/캐싱과 같은 OkHttp의 동작을 커스텀할 수 있음

#### 실전 질문
- 앱에서 동시에 여러 API 요청을 수행하고 UI를 업데이트하기 전에 결과를 결합해야 한다고가정해봅시다.Retrofit과 코루틴을 사용하여 이를 효율적으로 구현하려면 어떻게 해야 하나요?
- API 응답 실패 시 어떻게 처리하고, 재시도 메커니즘은 어떻게 구현하나요?

#### Pro Tips for Mastery: OkHttp Authenticator 및 Interceptor를 사용하여 OAuth 토큰 갱신하기


### Q62) 대규모 데이터 셋을 효율적으로 로드하는 데 왜 페이징 기법이 필요하고, RecyclerView로 구현해 본 경험이 있나요?
- 페이징 시스템은 대규모 데이터 셋을 처리할 때 데이터 로드/화면 렌더링 하는 방식을 최적화함
- 데이터를 더 작고 관리가 쉬운 청크 단위로 가져옴으로써 앱 성능과 사용자 경험을 향상시킴
- 작은 페이지로 로드하면 메모리 사용량이 줄어들어 잠재적 메모리 부족 문제를 방지할 수 있고, 필요한 데이터만 렌더링하므로 초기 로드 시간 또한 단축됨

#### 실전질문
Q) 앱이 1000개의 데이터 셋을 가져와 리스트에 표시해야 한다고 가정해 봅시다. 원활한 스크롤을 보장하고 메모리 사용량을 줄이기 위해 효율적인 페이징 시스템을 어떻게 구현하시겠습니까?

Q) RecyclerView로 직접 페이징 시스템을 구현할 때 발생할 수 있는 문제는 무엇이며, 원활한 사용자 경험을 제공하기 위해 어떻게 해결할 수 있나요?

### Q63) 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?
- 이미지 로딩 시스템은 네트워크 요청/이미지 크기 조절/캐싱/렌더링/효율적인 메모리 관리 등과 같은 복잡한 기능을 구현해야 함
- Glide, Coil. Fresco와 같은 라이브러리를 활용하는 것이 일반적

#### Glide
- 캐싱/플레이스홀더/이미지 변환과 같은 복잡한 시나리오를 처리하는 데 이상적
- 자동으로 이미지를 캐싱하여 네트워크 호출을 최적화하고 성능을 향상시킴

#### Coil
- KMP로 설계된 Kotlin 기반의 이미지 로딩 라이브러리
- 내부적으로 Coroutines를 활용하고 Jetpack Compose와 같은 최신 기능을 지원함
- Kotlin/Compose와 원활하게 통합되며, 이미지 변환/애니메이션 GIF/SVG 렌더링/비디오 프레임 추출과 같은 유용한 기능을 제공함
- 현재 Coil이 가장 활발하게 관리되고 있으며, Compose/KMP 및 여러 최신 안드로이드 솔루션에 대한 다양한 지원을 제공함

#### Fresco
- Meta에서 개발한 이미지 로딩 라이브러리
- 이미지를 디코딩하고 표시하기 위해 자체 파이프라인을 사용하는 접근 방식을 사용함
- 큰 이미지 처리/점진적 렌더링/고급 캐싱 전략에 매우 효율적이어서 메모리 제약이 있는 애플리케이션에 특히 유용함
  - 하지만 안드로이드 4.x 이하에서만 해당되므로 이점이 거의 사라졌음

#### 라이브러리 비교
- Glide: 유연하고 쉬운 처리가 가능하지만, Compose 지원 버전이 여전히 베타 상태로 남아있음 ㅠㅠ
- Coil: Kotlin 중심적이고 가벼우며 Compose/KMP를 지원함! 가장 활발히 업데이트되고 있음
- Fresco: 메모리 집약적인 시나리오에 적합함

#### 실전 질문
Q) 앱이 백엔드 서버에서 고해상도 이미지를 로드하여 RecyclerView에서 부드러운 스크롤을 제공해야 합니다. 어떤 이미지 로딩 라이브러리를 선택할 것이고, UI 지연을 방지하기 위해 성능을 어떻게 최적화하시겠습니까?


### Q64) 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해 주세요
- 안드로이드는 경량화된 카-값 기반의 데이터 저장, 구조화된 DB 구축 및 쿼리, 로컬 파일 처리 등 각 시나리오에 적합한 데이터 저장 메커니즘을 제공함

#### SharedPreferences
- 앱 내 설정, 사용자 환경 설정과 같은 가벼운 값에 가장 적합한 키-값 쌍 형태의 데이터 저장 메커니즘
- 원시 타입을 저장하고 앱 재시작 시에도 유지할 수 있음
- 하지만 동기적으로 작동하여 메인스레드를 차단하는 문제점이 있고, 이를 개선한 DataStore의 등장으로 잘 사용되지 않음

(1) Datastore
- Jetpack DataStore는 키-값 저장을 위한 PreferencesDataStore와 구조화된 객체 값 저장을 위한 ProtoDataStore의 두 가지 유형을 제공함
- 비동기적으로 작동하므로 메인 스레드를 차단하는 잠재적 문제를 방지할 수 있음

(2) Room DB
- 구조화된 관계형 데이터를 처리하기 위해 설계된 SQLite를 추상화한 솔루션
- 어노테이션/컴파일 타임 검사/반응형 프로그래밍을 위한 LiveData/Flow를 지원하여 DB 관리를 단순화함

(3) File Storage
- 안드로이드 바이너리/커스텀 데이터의 경우에 내부/외부 저장소에 파일을 저장할 수 있도록 함
- 내부 저장소는 앱 간 접근이 불가능하며, 외부 저장소는 다른 앱과 공유할 수 있음
- 파일 I/O 작업은 이미지/비디오/커스텀 직렬화된 데이터 저장과 같은 작업에 사용할 수 있음

#### 실전 질문
Q) 오프라인 접근을 위해 네트워크 API에서 받은 대용량 JSON 응답을 저장해야 하는 시나리오에서 어떤 로컬 저장 메커니즘을 사용할 것이고, 그 이유는 무엇인가요?


### Q65) 오프라인 우선 아키텍처를 어떻게 설계하실 건가요?
- 인터넷 연결이 좋지 않거나 간헐적으로 인터넷이 끊기는 시나리오에서 사용자 경험을 향상시킬 수 있음

#### 핵심 개념
(1) 로컬 데이터 지속성
- 신뢰할 수 있는 오프라인 우선 전략은 로컬 데이터 저장소에서 시작됨
- Room DB를 사용
(2) 데이터 동기화
- 로컬 데이터/원격 데이터 간의 동기화는 일관성을 보장함
- WorkManager를 사용
(3) 캐시 및 가져오기 정책
- 캐싱 데이터 읽기: 앱이 먼저 로컬 DB에서 데이터를 가져오고, 필요할 때만 네트워크에 새로운 데이터를 요청
- 캐싱 데이터 쓰기: 로컬 소스와 원격 소스 간의 데이터를 동기화할 때 충돌 해결 전략을 구현해야 함
(4) 충돌 해결
- 최신 데이터 우선: 가장 최근 변경 사항을 우선시 해야 함
- 사용자 정의: 사용자가 수동으로 충돌을 해결하거나 도메인별 규칙을 적용하도록 허용

#### 실전 질문
Q) 네트워크가 자주 끊기는 국가 및 지역에서도 원활한 사용자 경험을 보장하기 위해 오프라인 우선 기능을 어떻게 설계하시겠습니까?
Q) 로컬 Room 데이터베이스 변경 사항을 백엔드 서버의 최신 데이터와 동기화하는 데 어떤 전략을 사용할 것이고, 로컬 및 백엔드 데이터가 모두 변경되었을 때 충돌을 어떻게 해결하시겠습니까?

### Q66) 초기 데이터 로딩을 위한 작업을 Compose의 LaunchedEffect와 ViewModel.init() 중 어디에서 하는 것이 가장 이상적인가요?
- 공식 안드로이드 문서에서는 일반적으로 구성변경 시 더 나은 생명주기 관리 및 데이터 지속성을 위해 `ViewModel.init()`에서 데이터를 로드할 것을 예시로 보여줌
- 어떤 개발자의 이유 설명
  - Compose UI를 애플리케이션의 상태 또는 데이터의 시각적 표현으로 간주한다면,
    앱에 무엇을 해야할 지 지시하기 위해 UI에 의존하는 것은 사실 설계 결함으로 볼 수 있음
    따라서 ViewModel.init()을 사용하는 것이 더 관심사를 잘 분리할 수 있음
- 그에 반대되는 의견에 대한 다른 개발자의 이유 설명
  - ViewModel.init()에만 의존하면 특정 동작이 트리거되는 시점에 대한 제어가 어려워지고 유닛 테스트가 복잡해질 수 있음
    대신 ViewModel 내에서 이벤트 기반 흐름을 관찰하여 트리거되고 지연 초기화될 수 있는 독립적인 함수를 정의하는 것을 선호함
- 하지만 그에 대한 Google Android toolkit 팀의 팀원의 설명은...
  - ViewModel.init()에서 초기 데이터를 로드하면 ViewModel 생성 중에 의도치 않은 사이드 이펙트가 발생하고, UI 상태 관리라는 의도된 역할에서 벗어나 생명주기 처리를 복잡하게 만들 수 있음













