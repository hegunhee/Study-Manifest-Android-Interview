### Q59) 장기적으로 실행되는 백그라운드 작업을 어떻게 관리하나요?
#### WorkManager
- 앱이 닫히거나 기기 재부팅 후에도 실행되어야 하는 작업은 WorkManager가 공식적으로 권장되는 솔루션
- 백그라운드 작업을 관리하고, 네트워크 가용성/충전 상태와 같은 제약 조건 하에서 작업이 실행되도록 보장함
- 로그 업로드, 데이터 동기화, 비디오 파일 업로드 등이 일반적인 사용 사례

#### Service
- 음악 재생/위치 추적과 같이 지속적이고 오랜 실행이 필요한 작업에는 Service가 이상적
- Service는 UI와 독립적으로 실행되며, 앱이 백그라운드에 있을 때도 계속 실행될 수 있음
- 만약 작업이 알림과 함께 사용자가 인지할 수 있는 상황에서 실행되어야 하는 경우에는 Foreground Service를 사용함

#### Kotlin Coroutines/Dispatchers
- 앱 생명주기에 연결된 작업은 Coroutines를 사용하며, 언어 수준에서 깔끔하고 구조화된 접근 방식을 제공함
- 무거운 작업을 오프로드하려면 Dispatchers.IO를 사용하고, CPU 집약적인 계산에는 Dispatchers.Default를 사용함
- 이 방식은 앱이 닫힌 후에도 유지될 필요가 없는 작업에 이상적

##### "CPU 집약적"은 무엇일까?
- 오해: I/O 작업보다 훨씬 무겁고 CPU를 많이 사용해야할 것 처럼 생각되지만, 실제로는 그렇지 않음
- CPU 집약적인 작업은 연산적인 능력을 요구하며, 사용 가능한 CPU 코어 수에 의해 제약을 받음
- 즉, 디바이스에서 사용가능한 코어의 수만큼만 쓰레드를 생성하여 작업을 수행함
- 예를 들어 암호화/이미지 처리/비디오 인코딩/데이터 분석과 같은 작업이 있음
- 이러한 작업들은 전적으로 CPU에 의존하기 때문에 사용 가능한 코어 수보다 많은 스레드를 추가하면 성능 향상보다는 스레드 경합이 발생하는 경우가 많음
- 반면, I/O 관련 작업은 CPU 코어 수보다 많은 스레드를 사용함으로써 여러 I/O 작업이 CPU 경합을 일으키지 않고 동시에 실행될 수 있도록 함

#### JobScheduler
- 작업이 기기 전체 작업과 관련되고, 특정 조건(충전 중에만 실행되는 등)이 필요한 경우 적합함
- 즉시 실행이 필요하지 않은 작업에 적합함(WorkManager는 내부적으로 JobScheduler를 활용함)

##### 실전 질문
- 안드로이드 앱에서 백엔드 서버로부터 대용량 파일(수백 MB)을 다운로드하는 기능을 구현해야 합니다. 다운로드는 앱이 닫혀도 계속되어야 하며, 성능/네트워크 조건 측면에서 효율적이어야 합니다. 어떤 것을 선택하여 구현하실 건가요?

### Q60) Json 형식을 객체로 어떻게 직렬화하나요?
- 최신 안드로이드 앱은 원격 서버와 자주 상호 작용하기 때문에 JSON을 객체로 직렬화하는 것이 일반적임
- 일반적으로 JSON 형식으로 데이터를 자주 교환하는데, 가볍고 가독성이 좋으며 플랫폼 독립적이기 때문임
- Kotlin 객체를 JSON으로 직렬화하여 데이터를 백엔드로 보내고, JSON 응답을 받으면 다시 객체로 역직렬화해야 함

#### 직렬화 & 역직렬화란?
- 직렬화: 객체/데이터 구조를 나중에 쉽게 저장/전송/재구성할 수 있는 형식으로 변환하는 프로세스
- 역직렬화: 직렬화된 데이터를 가져와 애플리케이션에서 작업할 수 있는 메모리 내 객체로 다시 재구성하는 역 프로세스

### kotlinx.serialization
- 어노테이션을 사용하여 직렬화 동작을 정의하고, JSON 뿐 아니라 ProtoBuf와 같은 다른 형식과도 원활하게 동작함
- Kotlin 컴파일러 플러그인을 사용하여 Kotlin 객체를 JSON 문자열로 직렬화하고, JSON 문자열을 다시 Kotlin 객체로 역직렬화하는 타입 안전성을 보장하며, 내부적으로 리플렉션을 사용하지 않으므로 런타임 성능이 저하되지 않음
- Moshi/Gson처럼 리플렉션으로 인한 런타임 성능 저하 없이 효율적인 직렬화를 수행할 수 있다는 장점이 있음
- Moshi
  - Kotlin 지원 강조(null 가능성/기본 파라미터 기능 지원), 타입 안전성 보장
  - 리플렉션 기반/코드 생성 기반 2가지 방식을 지원함
  - 리플렉션 기반은 빠른 셋업 환경을 제공하지만, 런타임 성능 오버헤드 발생함
  - 코드생성 기반은 컴파일 타임에 어댑터를 생성하여 더 나은 성능을 제공함
- Gson
  - JVM 기반으로 동작함
  - 컴파일 타임 안전성을 제공하지 않음(런타임 오류로 크래시 발생)

#### 실전 질문
- API의 JSON 응답이 주어졌을 때, 이를 Kotlin 데이터 클래스로 어떻게 역직렬화하시겠습니까? Kotlin을 사용하는 프로젝트에서 어떤 라이브러리를 선택할 것이고, 그 이유는 무엇인가요

-  Kotlin 데이터 클래스에 정의되지 않은 누락되거나 추가적인 필드가 있는 JSON 문자열을 역직렬화해야 하는 경우 어떻게 처리하실 건가요
  - 기본 파라미터를 지원하는 Moshi나 serialization을 사용하겠습니다.

### Q61) 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?
- Retrofit은 선언적 인터페이스를 제공하여 Api 상호작용을 단순화함
- OkHttp는 기본적인 HTTP 클라이언트 역할을 하여 연결 풀링/캐싱/효율적인 통신을 제공함
- Retrofit은 내부적으로 OkHttp를 HTTP 클라이언트로 사용하며, 인터셉터를 추가하여 로깅/인증/캐싱과 같은 OkHttp의 동작을 커스텀할 수 있음

#### 실전 질문
- 앱에서 동시에 여러 API 요청을 수행하고 UI를 업데이트하기 전에 결과를 결합해야 한다고가정해봅시다.Retrofit과 코루틴을 사용하여 이를 효율적으로 구현하려면 어떻게 해야 하나요?
- API 응답 실패 시 어떻게 처리하고, 재시도 메커니즘은 어떻게 구현하나요?

#### Pro Tips for Mastery: OkHttp Authenticator 및 Interceptor를 사용하여 OAuth 토큰 갱신하기


### Q62) 대규모 데이터 셋을 효율적으로 로드하는 데 왜 페이징 기법이 필요하고, RecyclerView로 구현해 본 경험이 있나요?


### Q63) 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?


### Q64) 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해 주세요


### Q65) 오프라인 우선 아키텍처를 어떻게 설계하실 건가요?


### Q66) 초기 데이터 로딩을 위한 작업을 Compose의 LaunchedEffect와 ViewModel.init() 중 어디에서 하는 것이 가장 이상적인가요?

