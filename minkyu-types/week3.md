# Q10) BroadcastReceiver란 무엇인가요?
- 안드로이드 운영 체제 전체의 브로드캐스트 메시지나 앱의 특정 브로드캐스트를 수신하고 응답할 수 있도록 하는 컴포넌트
- 안드로이드 시스템이나 다른 애플리케이션에 의해 트리거되어 배터리 상태 변경, 네트워크 상태 변경, 커스텀 인텐트와
  같은 다양한 이벤트를 알리는 역할을 한다

## BroadcastReceiver의 목적
- Activity/Service의 생명주기에 직접적으로 연결되지 않을 수 있는 이벤트를 처리하는 데 사용함
- 이를 통해 앱이 백그라운드에서 실행되지 않은 상태에서도 변경 사항에 반응할 수 있도록 하는 메시징 시스템 역할을 하여 리소스를 절약

## BroadcastReceiver의 유형
- 시스템 브로드캐스트
- 커스텀 브로드캐스트

## BroadcastReceiver 사용 시 주의할 점
- 매니페스트 파일을 통해 동적으로 등록하는 경우, 메모리 누수를 방지하기 위해 unregisterReceiver를 사용해서 해제해야 함
- API 26부터 백그라운드 앱은 브로드캐스트 수신에 제한을 받음 -> Context.registerReceiver, JobScheduler 사용
- 민감한 정보가 포함된 브로드캐스트는 무단 접근을 방지하기 위해 권한으로 보호해야 함

## BroadcastReceiver 사용 예시
- 네트워크 연결 상태 변경 모니터링
- SMS/전화 이벤트
- 충전 상태와 같은 시스템 이벤트에 대한 UI 업데이트
- 커스텀 브로드캐스트로 작업/알람 예약

# Q11) ContentsProvider의 목적은 무엇이며, 애플리케이션 간의 안전한 데이터 공유를 어떻게 용이하게 하나요?
- 구조화된 데이터에 대한 접근을 관리하고, 애플리케이션 간 데이터 공유를 위한 인터페이스를 제공하는 컴포넌트
- 다른 앱이나 컴포넌트가 데이터를 CRUD하는 데 사용할 수 있는 중앙 저장소 역할
- 앱 간의 안전하고 일관된 데이터 공유를 보장
- 여러 앱이 동일한 데이터에 접근해야 하거나, DB/내부 저장소 구조를 노출하지 않고 다른 앱에 데이터를 제공하는 경우 유용하게 사용됨

## ContentsProvider의 목적
- 데이터 접근 로직을 캡슐화하여 앱 간 데이터 공유를 더 쉽고 안전하게 만듬

## ContentProvider의 주요 구성 요소
- 데이터 접근 주소로 URI를 사용함
- URI는 다음으로 구성됨
  - Authority: ContentProvider를 식별함(고유함)
  - Path: 데이터 유형을 지정함(/users, /products)
  - ID(선택): 데이터 셋 내의 특정 항목을 참조함

## ContentsProvider 사용하기
1. 메서드 오버라이드 
2. 매니페스트 파일에 선언 (Authority 속성은 고유 식별자)
3. 다른 앱에서 ContentProvider와 상호 작용하려면 ContentsResolver를 사용해야 함

## ContentProvider 사용 사례
- 다른 애플리케이션 간의 데이터 공유
- 앱 시작 시 컴포넌트/리소스 초기화
- 연락처/미디어 파일/앱 별 데이터 같은 구조화된 데이터에 대한 접근 제공
- 연락처 앱/파일 앱과 같은 안드로이드 시스템 기능과의 통합

# Q12) 구성 변경을 어떻게 처리하나요?
- 화면 회전, 언어 변경, 다크/라이트 모드 전환, 글꼴 크기/두께 조정 같은 앱 설정이 변경되었을 때
  사용자 경험을 유지하는 데 중요한 역할을 함
- 안드로이드 시스템은 구성 변경이 발생할 때 Activity를 다시 시작하며(파괴 후 재생성)
  이로 인해 일시적으로 UI 상태가 손실될 수 있음

#### UI 상태 저장 및 복원
- onSaveInstanceState(), onRestoreInstanceState() 메서드를 오버라이드하여 Activity 재생성 중 UI 상태를 보존/복원

#### Jetpack ViewModel
- 구성 변경에도 유지되어야 하는 UI 관련 데이터를 저장
- ViewModel 객체는 Activity 생명주기보다 길게 유지되므로 데이터 보존/복원에 이상적인 요소

#### 구성 변경을 수동으로 처리
- 애플리케이션이 특정 구성 변경 중에 리소스를 업데이트하지 않아도 되고, Activity 재시작을 피하고 싶을 경우
  매니페스트 파일에서 Activity가 처리할 구성 변경 사항을 android:configChanges 속성을 사용해 선언하고,
  onConfigurationChange() 메서드를 오버라이드하여 해당 변경사항이 발생했을 때 수동으로 관리

#### Compose의 rememberSavable
- onSaveInstanceState()와 유사하게 동작하지만 Compose에 특화되어 Composable 상태를 유지하는 데 도움이 됨

## 추가 팁
- Navigation 컴포넌트를 사용하여 구성 변경 시 네비게이션 백 스택이 보존됨
- 앱 구성(설정)에 의존적인 값을 UI 계층에 직접 저장하지 말고, ViewModel을 사용할 것

# Q13) 안드로이드는 메모리를 어떻게 효율적으로 관리하며, 메모리 누수를 어떻게 방지하는지 설명해주세요
- 안드로이드는 사용되지 않는 메모리를 자동으로 회수하여 활성화된 애플리케이션/서비스에게 효율적인 메모리 할당을 보장하는
  가비지 컬렉션 메커니즘을 통해 메모리를 관리함
- 관리형 메모리 환경에 의존하기 때문에, C++과 같은 언어에서처럼 메모리를 수동으로 할당하고 해제할 필요가 없음
- 시스템 메모리가 부족할 경우, 포그라운드 어플리케이션의 원활한 작동을 우선시하며,
  백그라운드 프로세스를 종료하기 위해 low-memory-killer를 사용함
- 따라서 개발자는 시스템 성능에 미치는 영향을 최소화하기 위해 앱이 리소스를 효율적으로 사용하도록 해야 함

## 안드로이드에서 메모리 누수의 원인
- 애플리케이션이 더 이상 필요하지 않은 객체에 대한 참조를 유지해서 가비지 컬렉터가 메모리를 회수하지 못할 때 발생함
- 일반적으로 잘못된 생명주기 관리, 정적 참조 또는 Context에 대한 장기 참조 유지 등이 원인

## 메모리 누수를 피하기 위한 모범 사례
- 생명주기를 감지하는 컴포넌트 사용
  - Flow/LiveData와 같은 생명주기를 인지하는 컴포넌트를 활용하면 생명주기에 따라 리소스가 적절하게 해제됨
- Context에 대한 장기 참조 지양하기
  - 정적 필드/싱글톤과 같이 오래 지속되는 객체에서 Activity/Context에 대한 참조를 유지하면 안됨
  - Context에 대한 장기 참조가 필요할 경우, ApplicationContext를 사용할 것
- 리스너/콜백 등록을 올바르게 해제하기
  - 적절한 생명주기에서 리스너/옵저버/콜백 등록을 해제해야 함
  - onPause()/onStop()에서 BroadcastReceiver 등록을 해제해야 앱이 백그라운드에 있을 때 참조를 유지하지 않음
- 중요하지 않는 객체에 대해서 WeakReference를 사용할 것
  - 강한 참조가 필요하거나, 장기적으로 참조되어야하는 객체가 아니라면 WeakReference를 사용하는 것이 좋음
  - 약한 참조 상태의 객체는 메모리가 필요할 때 가비지 컬렉터가 해당 객체의 메모리를 회수할 수 있음
- 누수 감지 툴 사용
  - LeakCanary 같은 툴을 사용해서 메모리 누수 발생을 감지하고 추적해서 메모리 효율성을 높일 수 있음
- View에 대한 정적 참조 피하기
  - View는 Activity 컨텍스트에 대한 참조를 유지하여 메모리 누수를 유발할 수 있으므로 정적 필드에 저장해서는 안됨
- 리소스 닫기
  - 파일 스트림/커서/DB 연결 등과 같은 리소스는 더 이상 필요하지 않을 때 명시적으로 해제해야 함

# Q14) ANR이란 무엇인지, ANR이 발생하는 주요 원인은 무엇이며, 어떻게 예방할 수 있는지 설명해주세요
- Application Not Responding
- 앱의 메인 스레드가 너무 오랫동안, 통상적으로 5초 이상 차단될 때 발생하는 안드로이드 시스템 오류
- ANR 발생 시 안드로이드는 사용자에게 앱을 종료하거나 응답을 기다리도록 안내함
- 발생하는 경우
  - 메인 스레드에서 5초 이상 걸리는 무거운 작업
  - 장시간 실행되는 네트워크/DB 등의 I/O 작업
  - UI 스레드 차단 작업(동기 작업)

## ANR 예방 방법
- 무겁거나 장시간 소요되는 작업을 오프로드하여 메인 스레드의 응답성을 유지하는 것이 중요함
- 무거운 작업을 메인 스레드 밖으로 이동
  - 파일 I/O, 네트워크 요청, 데이터베이스 쿼리 같은 무거운 작업을 처리할 때 코루틴의 Dispathers.IO를 사용
- WorkManager 사용하기
  - 데이터 동기화와 같이 백그라운드에서 실행되어야 하는 장기적인 작업에는 WorkManager를 사용
- 데이터 불러오기 최적화
  - 대규모 데이터 셋을 효율적으로 처리하기 위해 페이징을 구현하여 데이터를 작고 관리 가능한 청크로 가져와
    UI 과부하를 방지하고 성능을 향상시킬 수 있음
- 구성 변경 시 UI 작업 최적화
  - ViewModel을 활용하여 UI 관련 데이터를 유지하고, 화면 회전과 같은 구성 변경 중에 불필요한 UI 렌더링을 지양해야 함
- Android 스튜디오로 모니터링 및 프로파일링
  - CPU/메모리 및 네트워크 사용량을 모니터링하여 ANR을 유발할 수 있는 성능 병목 현상을 식별하고 해결
- 블로킹 호출 피하기
  - 메인 스레드에서 긴 푸르, sleep 호출, 네트워크 요청을 동기로 수행하지 않아야 함
- 가벼운 지연 작업에 Handler 사용
  - Thread.sleep() 대신 Handler.postDelayed()를 사용하여 메인 스레드를 차단하지 않고 가벼운 지연 작업을 처리하기

# Q15) 딥 링크를 어떻게 처리하는지 설명해주세요
- 사용자가 URL이나 알림과 같은 외부 소스에서 앱 내의 특정 화면이나 기능으로 직접 이동할 수 있도록 함
- 딥 링크를 처리하려면 매니페스트 파일에서 이를 정의하고, 해당 Activity/Fragment에서 들어오는 Intent를 처리해야 함

## 딥 링크 사용 방법
- 매니페스트에서 딥 링크 정의하기
  - 딥 링크를 처리해야하는 Activity에 대해 매니페스트 파일에서 intent filter를 선언함
  - intent filter는 앱이 응답하는 URL 구조 또는 스키마를 지정함
    - android:scheme -> URL 스키마를 지정(https)
    - android:host -> 도메인을 지정(example.com)
    - android:pathPrefix -> URL의 경로를 지정(/deepLink)
  - 이 설정을 통해 특정 URL이 해당 Activity를 열도록 허용
- Activity에서 딥 링크 처리하기
  - Activity 내부에서 들어오는 Intent 데이터를 검색하고 처리하여 적절한 화면으로 이동하거나 작업을 수행함
- 딥 링크 테스트하기

## 추가 고려 사항
- 커스텀 스키마
  - 앱 내부적으로 실행하는 딥링크에 대해서는 커스텀 싀마를 사용할 수 있지만,
    호환성을 위해 HTTP/HTTPS URL이 선호됨
- 네비게이션
  - 딥 링크 데이터를 기반으로 앱 내의 다른 Activity/Fragment로 이동하기 위해 Intent를 사용
- 폴백 처리
  - 앱이 딥 링크 데이터가 유효하지 않거나 불완전할 경우를 처리하여 더 나은 사용자 경험을 제공할 수 있음
- App Links
  - HTTP/HTTPS 딥 링크가 브라우저 대신 앱에서 직접 열리도록 하려면 App Links를 설정해야 함


# Q16) 테스크와 백스택이란 무엇인가요?
- 테스크는 사용자가 특정 목표를 달성하기 위해 상호 작용하는 Activity의 집합
- 테스크는 백 스택으로 구성되며, 이는 Activity가 시작될 떄 추가되고 뒤로 이동하거나 리소스를 회수할 때 제거되는 후입선출(LIFO) 스택 구조

## 테스크
- 런처나 Intent를 통해 Activity가 실행될 때 시작됨
- 예를 들어 이메일 앱에서 링크를 클릭하면 동일한 테스크의 일부로 브라우저가 열릴 수 있음
  테스크는 연관된 Activity가 소멸될 때까지 활성 상태를 유지함

## 백 스택
- 백 스택은 테스크 내 Activity의 기록을 유지함
- 사용자가 새 Activity로 이동하면 현재 Activity가 스택에 push됨
- 뒤로가기 버튼을 누르면 스택의 맨 위 Activity가 pop되어 그 아래 Activity가 재개됨
- 테스크와 백 스택은 Intent flag와 Activity launch mode의 영향을 받음
  - 테스크/백 스택 내부의 Activity의 동작을 제어하는 데 사용되는 메커니즘
- 이를 통해 개발자는 Activity가 어떻게 시작되고, 다른 Activity와 어떻게 상호 작용하는지 정의할 수 있음

## 런치 모드
- Activity가 어떻게 인스턴스화되고 백 스택에서 처리되는지를 결정함
- standard
  - 기본 런치 모드
  - 인스턴스가 이미 존재할 경우에도 Activity가 시작될 때마다 새 인스턴스가 추가되어 백 스택에 추가됨
- singleTop
  - Activity의 인스턴스가 이미 백 스택의 맨 위에 있는 경우 새 인스턴스가 생성되지 않음
  - 대신 기존 인스턴스가 onNewIntent()에서 Intent를 처리하게 됨
- singleTask
  - 테스크 내에 Activity의 인스턴스가 하나만 존재함
  - 인스턴스가 이미 존재하는 경우 맨 앞으로(최상단으로) 가져오고 onNewIntent()가 호출됨
  - 앱의 진입점 역할을 하는 Activity에 유용함
- singleInstance
  - singleTask와 유사하지만, Activity가 다른 Activity와 분리된 고유한 테스크에 배치됨
  - 동일한 테스크에 다른 Activity가 포함될 수 없도록 보장함

## 인텐트 플래그
- Intent가 전송될 때 Activity가 시작되는 방식이나 백 스택의 동작을 수정하는 데 사용됨
- FLAG_ACTIVITY_NEW_TASK
  - 새 테스크에서 Activity를 시작하거나,
  - 테스크가 이미 존재하는 경우 해당 테스크를 맨 앞으로 가져옴
- FLAG_ACTIVITY_CLEAR_TOP
  - Activity가 이미 백 스택에 존재하는 경우,
  - 그 위에 있는 모든 Activity가 날아가고 기존 인스턴스가 Intent를 처리함
- FLAG_ACTIVITY_SINGLE_TOP
  - Activity가 백 스택의 맨 위에 있는 경우 새 인스턴스가 생성되지 않도록 보장함
  - 종종 다른 플래그와 함께 사용됨
- FLAG_ACTIVITY_NO_HISTORY
  - Activity가 백 스택에 추가되는 것을 방지하여 종료 후에도 유지되지 않도록 함

## 사용 사례
- 런치 모드는 주로 AndroidManfiest.xml 파일의 <activity> 태그 아래에 선언되어
  개발자가 Activity의 기본 동작을 설정할 수 있도록 함
- 인텐트 플래그는 Intent를 생성할 때, 개발자가 유동적으로 플래그를 설정할 수 있는 방식으로 작동하여
  특정 시나리오에 대해 더 많은 유연성을 제공함