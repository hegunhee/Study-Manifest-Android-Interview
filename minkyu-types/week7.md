### Q38. View 시스템의 무효화(invalidation)란 무엇인가요?
- 무효화는 View를 다시 그려야 함을 표시하는 프로세스를 의미함
- 변경사항이 발생할 때 UI를 업데이트하기 위해 안드로이드 View 시스템에서 사용되는 기본 메커니즘
- Vewi가 무효화되면 시스템은 다음 드로잉 주기 동안 화면의 해당 부분을 새로 고쳐야 함을 인지하고 새롭게 그림

#### 무효화 작동 방식
- View에서 `invalidate()` 또는 `postInvalidate()` 같은 메서드를 호출하면 무효화 프로세스가 트리거됨
- 시스템은 View를 "Dirty"로 플래그 지정하며, 이는 다시 그려야 함을 의미함
- 다음 프레임 동안 시스템은 View를 드로잉 패스에 포함시켜 시각적 표현을 업데이트

#### 무효화 프로세스가 필요한 이유
- View가 변화할 때마다, 새롭게 View를 다시 렌더링하는 것이 아니라, 개발자/시스템에 의해 적절한 순간에 업데이트되도록 제한함으로써 성능을 개선할 수 있음
- 그렇지 않고 자동적으로 View가 업데이트된다면, 무분별한 렌더링으로 앱의 전반적인 성능이 크게 떨어질 수 있음
- Jetpack compose에는 이런 무효화 프로세스가 없고 상태에 따라 자동적으로 UI가 업데이트되므로 성능에 더 각별한 주의가 필요함

#### 무효화를 위한 주요 메서드
(1) invalidate()
- 단일 View를 무효화하는 데 사용함
- View를 더티로 표시하여 시스템이 다음 레이아웃 패스 중에 다시 그리도록 신호를 보냄
- View를 즉시 다시 그리는 것이 아니라 다음 프레임을 위해 예약
(2) invalidate(Rect dirty)
- 다시 그려야 하는 View 내의 특정 직사각형 영역을 지정할 수 있음
- 더 작은 부분으로 다시 그리기를 제한하여 성능을 최적화
(3) postInvalidate()
- UI 스레드가 아닌 다른 스레드에서 View를 무효화하는 데 사용함
- 무효화 요청을 메인 스레드에 게시하여 스레드 안정성을 보장함

#### 무효화 모범 사례
- View의 특정 영역만 다시 그려야 할 때 부분 업데이트를 위해 invalidate(Rect dirty)를 사용함으로써 변경되지 않은 영역의 불필요한 다시 그리기를 피하여 성능을 향상시킴
- 애니메이션이나 복잡한 레이아웃에서 성능 병목 현상을 방지하기 위해 `invalidate()`를 자주 또는 불필요하게 호출하지 않아야 함
- 백그라운드 스레드에서 무효화 요청에는 postInvalidate()를 사용하여 업데이트가 메인 스레드에서 안전하게 발생하도록 보장함

#### 실전 질문
(1) invalidate() 메서드는 어떻게 작동하며 postInvalidate()와 어떻게 다른가요? 각각이 적합한 실제 사용 사례를 제시해주세요
(2) 백그라운드 스레드에서 UI 요소를 업데이트해야 하는 경우, 다시 그리기 작업이 메인 스레드에서 안전하게 수행되도록 어떻게 보장할 수 있나요?

### Q39. ConstraintLayout이란 무엇인가요?
- ConstraintLayout은 여러 레이아웃을 중첩하지 않고 복잡하고 반응성이 뛰어난 사용자 인터페이스를 만들기 위해 안드로이드에서 도입된 레이아웃
- 다른 뷰나 부모 컨테이너에 상대적인 제약 조건을 사용하여 뷰의 위치/크기를 정의할 수 있음
- 중첩된 뷰 계층 구조가 필요 없어 성능과 코드 가독성이 향상됨

#### 주요 특징
(1) 제약 조건을 이용한 위치 지정
- 정렬, 중앙 배치 및 앵커링을 위한 제약 조건을 사용하여 형제 뷰/부모 레이아웃에 상대적으로 위치를 지정할 수 있음
(2) 유연한 크기 제어
- 고정 크기와 같은 옵션을 제공하여 반응형 레이아웃을 쉽게 디자인할 수 있음(0dp + 제약 조건, constraintRatio 등)
(3) 체인 및 가이드라인 지원
- 체인을 사용하여 뷰를 동일한 간격으로 가로 또는 세로로 그룹화할 수 있음
- 가이드라인을 사용하여 고정/백분율 기반 위치에 정렬할 수 있음
(4) 베리어 및 그룹핑
- 베리어는 참조된 뷰의 크기에 따라 동저긍로 조정됨
- 그룹핑은 여러 뷰의 가시성 변경을 단순화함
(5) 성능 향상
- 여러 중첩 레이아웃의 필요성을 줄여 레이아웃 렌더링 속도를 높이고 앱 성능을 향상시킴

#### 장점
(1) 플랫 뷰 계층 구조
- 플랫 계층 구조를 가능하게 하여 렌더링 성능 향상/레이아웃 관리 단순화
(2) 반응형 디자인
(3) 내장 도구
(4) 고급 기능

#### 한계
(1) 단순 레이아웃에 대한 복잡성
- LinearLayout/FrameLayout으로 충분한 레이아웃에 사용하기엔 과할 수 있음
(2) 러닝 커브

#### 사용 사례
(1) 반응형 UI
- 다양한 화면 크기에서 정밀한 정렬과 적응성이 필요한 디자인에 이상적
(2) 복잡한 레이아웃
- 여러 겹치는 요소나 복잡한 위치 지정 요구사항이 있는 UI에 적합
(3) 성능 최적화

#### 실전 질문
(1) ConstraintLayout은 중첩된 LinearLayout 및 RelativeLayout과 비교하여 성능을 어떻게 향상시키나요? ConstraintLayout 사용이 더 효율적인 시나리오를 말씀해주세요.
(2) ConstraintLayout에서 match_constraint (0dp) 동작이 어떻게 작동하는지 설명해주세요. wrap_content 및 match_parent와 어떻게 다르며, 어떤 상황에서 사용해야 하나요?

### Q40. SurfaceView 대신 TextureView는 언제 사용해야 하나요?
- SurfaceView는 별도의 스레드에서 렌더링이 처리되는 시나리오를 위해 설계된 특수한 View로, 전용 드로잉 표면을 제공함
- 일반적으로 성능이 중요한 비디오 재생, 커스텀 그래픽 렌더링 또는 게임과 같은 작업에 사용됨
- 메인 UI 스레드 외부에 별도의 표면을 생성하여 다른 UI 작업을 차단하지 않고 효율적인 렌더링을 가능하게 함
- 표면은 SurfaceHolder 콜백 메서드를 통해 생성 및 관리되며, 필요에 따라 렌더링을 시작하고 중지할 수 있음
- SurfaceView는 연속적인 렌더링(비디오 재생 등)에 효율적이라 크기 조절/회전과 같은 변환에는 제한이 있음
- 따라서 고성능 사용 사례에는 적합하나, 동적인 상호 작용이 요구되는 UI에는 덜 유연하고 적합하지 않음
  
- 반면 TextureView는 콘텐츠를 오프스크린으로 렌더링하는 또 다른 방법을 제공하면서, SurfaceView와 달리 UI 계층 구조에 원활하게 통합됨
- TextureView는 회전/크기 조절/알파 블렌딩과 같은 기능을 허용하여 변환하거나 애니메이션화할 수 있음
- 라이브 카메라 피드 표시, 커스텀 변환으로 비디오를 렌더링하는 등의 작업에 자주 사용됨
- SurfaceView와 달리 TextureView는 메인 스레드에서 작동함
- 이 떄문에 연속 렌더링에서는 성능적으로 덜 효율적이지만, 다른 UI 컴포넌트와의 더 나은 상호작용을 가능하게 하고 실시간 변환을 지원함

#### SurfaceView와 TextureView의 차이점
- SurfaceView는 별도의 Window를 생성하여 성능을 보장하지만, 변환이나 애니메이션화되는 능력은 제한됨
- 반면 TextureView는 다른 UI 컴포넌트와 동일한 Window를 공유하여 크기 조절/회전/애니메이션이 가능하므로 UI 관련 사용 사례에 더 유연하게 사용할 수 있음

#### 실전 질문
(1) 효율적인 리소스 관리 및 메모리 누수 방지를 위해 SurfaceView의 생명주기를 어떻게 적절하게 관리해야 하나요?
(2) 카메라 미리보기를 회전 및 크기 조절과 같은 UI 변환과 함께 표시해야 하는 요구 사항이 주어졌을 때, SurfaceView와 TextureView 중 어떤 컴포넌트를 선택하는 것이 적합한가요

### Q41. RecyclerView는 내부적으로 어떻게 작동하나요?


### Q42. Dp와 Sp의 차이점은 무엇인가요?


### Q43. 나인패치 이미지의 용도는 무엇인가요?


### Q44. Drawable이란 무엇이며, UI 개발에서 어떻게 사용되나요?


