### Q38. View 시스템의 무효화(invalidation)란 무엇인가요?
- 무효화는 View를 다시 그려야 함을 표시하는 프로세스를 의미함
- 변경사항이 발생할 때 UI를 업데이트하기 위해 안드로이드 View 시스템에서 사용되는 기본 메커니즘
- Vewi가 무효화되면 시스템은 다음 드로잉 주기 동안 화면의 해당 부분을 새로 고쳐야 함을 인지하고 새롭게 그림

#### 무효화 작동 방식
- View에서 `invalidate()` 또는 `postInvalidate()` 같은 메서드를 호출하면 무효화 프로세스가 트리거됨
- 시스템은 View를 "Dirty"로 플래그 지정하며, 이는 다시 그려야 함을 의미함
- 다음 프레임 동안 시스템은 View를 드로잉 패스에 포함시켜 시각적 표현을 업데이트

#### 무효화 프로세스가 필요한 이유
- View가 변화할 때마다, 새롭게 View를 다시 렌더링하는 것이 아니라, 개발자/시스템에 의해 적절한 순간에 업데이트되도록 제한함으로써 성능을 개선할 수 있음
- 그렇지 않고 자동적으로 View가 업데이트된다면, 무분별한 렌더링으로 앱의 전반적인 성능이 크게 떨어질 수 있음
- Jetpack compose에는 이런 무효화 프로세스가 없고 상태에 따라 자동적으로 UI가 업데이트되므로 성능에 더 각별한 주의가 필요함

#### 무효화를 위한 주요 메서드
(1) invalidate()
- 단일 View를 무효화하는 데 사용함
- View를 더티로 표시하여 시스템이 다음 레이아웃 패스 중에 다시 그리도록 신호를 보냄
- View를 즉시 다시 그리는 것이 아니라 다음 프레임을 위해 예약
(2) invalidate(Rect dirty)
- 다시 그려야 하는 View 내의 특정 직사각형 영역을 지정할 수 있음
- 더 작은 부분으로 다시 그리기를 제한하여 성능을 최적화
(3) postInvalidate()
- UI 스레드가 아닌 다른 스레드에서 View를 무효화하는 데 사용함
- 무효화 요청을 메인 스레드에 게시하여 스레드 안정성을 보장함

#### 무효화 모범 사례
- View의 특정 영역만 다시 그려야 할 때 부분 업데이트를 위해 invalidate(Rect dirty)를 사용함으로써 변경되지 않은 영역의 불필요한 다시 그리기를 피하여 성능을 향상시킴
- 애니메이션이나 복잡한 레이아웃에서 성능 병목 현상을 방지하기 위해 `invalidate()`를 자주 또는 불필요하게 호출하지 않아야 함
- 백그라운드 스레드에서 무효화 요청에는 postInvalidate()를 사용하여 업데이트가 메인 스레드에서 안전하게 발생하도록 보장함

#### 실전 질문
(1) invalidate() 메서드는 어떻게 작동하며 postInvalidate()와 어떻게 다른가요? 각각이 적합한 실제 사용 사례를 제시해주세요
(2) 백그라운드 스레드에서 UI 요소를 업데이트해야 하는 경우, 다시 그리기 작업이 메인 스레드에서 안전하게 수행되도록 어떻게 보장할 수 있나요?

### Q39. ConstraintLayout이란 무엇인가요?
- ConstraintLayout은 여러 레이아웃을 중첩하지 않고 복잡하고 반응성이 뛰어난 사용자 인터페이스를 만들기 위해 안드로이드에서 도입된 레이아웃
- 다른 뷰나 부모 컨테이너에 상대적인 제약 조건을 사용하여 뷰의 위치/크기를 정의할 수 있음
- 중첩된 뷰 계층 구조가 필요 없어 성능과 코드 가독성이 향상됨

#### 주요 특징
(1) 제약 조건을 이용한 위치 지정
- 정렬, 중앙 배치 및 앵커링을 위한 제약 조건을 사용하여 형제 뷰/부모 레이아웃에 상대적으로 위치를 지정할 수 있음
(2) 유연한 크기 제어
- 고정 크기와 같은 옵션을 제공하여 반응형 레이아웃을 쉽게 디자인할 수 있음(0dp + 제약 조건, constraintRatio 등)
(3) 체인 및 가이드라인 지원
- 체인을 사용하여 뷰를 동일한 간격으로 가로 또는 세로로 그룹화할 수 있음
- 가이드라인을 사용하여 고정/백분율 기반 위치에 정렬할 수 있음
(4) 베리어 및 그룹핑
- 베리어는 참조된 뷰의 크기에 따라 동저긍로 조정됨
- 그룹핑은 여러 뷰의 가시성 변경을 단순화함
(5) 성능 향상
- 여러 중첩 레이아웃의 필요성을 줄여 레이아웃 렌더링 속도를 높이고 앱 성능을 향상시킴

#### 장점
(1) 플랫 뷰 계층 구조
- 플랫 계층 구조를 가능하게 하여 렌더링 성능 향상/레이아웃 관리 단순화
(2) 반응형 디자인
(3) 내장 도구
(4) 고급 기능

#### 한계
(1) 단순 레이아웃에 대한 복잡성
- LinearLayout/FrameLayout으로 충분한 레이아웃에 사용하기엔 과할 수 있음
(2) 러닝 커브

#### 사용 사례
(1) 반응형 UI
- 다양한 화면 크기에서 정밀한 정렬과 적응성이 필요한 디자인에 이상적
(2) 복잡한 레이아웃
- 여러 겹치는 요소나 복잡한 위치 지정 요구사항이 있는 UI에 적합
(3) 성능 최적화

#### 실전 질문
(1) ConstraintLayout은 중첩된 LinearLayout 및 RelativeLayout과 비교하여 성능을 어떻게 향상시키나요? ConstraintLayout 사용이 더 효율적인 시나리오를 말씀해주세요.
(2) ConstraintLayout에서 match_constraint (0dp) 동작이 어떻게 작동하는지 설명해주세요. wrap_content 및 match_parent와 어떻게 다르며, 어떤 상황에서 사용해야 하나요?

### Q40. SurfaceView 대신 TextureView는 언제 사용해야 하나요?
- SurfaceView는 별도의 스레드에서 렌더링이 처리되는 시나리오를 위해 설계된 특수한 View로, 전용 드로잉 표면을 제공함
- 일반적으로 성능이 중요한 비디오 재생, 커스텀 그래픽 렌더링 또는 게임과 같은 작업에 사용됨
- 메인 UI 스레드 외부에 별도의 표면을 생성하여 다른 UI 작업을 차단하지 않고 효율적인 렌더링을 가능하게 함
- 표면은 SurfaceHolder 콜백 메서드를 통해 생성 및 관리되며, 필요에 따라 렌더링을 시작하고 중지할 수 있음
- SurfaceView는 연속적인 렌더링(비디오 재생 등)에 효율적이라 크기 조절/회전과 같은 변환에는 제한이 있음
- 따라서 고성능 사용 사례에는 적합하나, 동적인 상호 작용이 요구되는 UI에는 덜 유연하고 적합하지 않음
  
- 반면 TextureView는 콘텐츠를 오프스크린으로 렌더링하는 또 다른 방법을 제공하면서, SurfaceView와 달리 UI 계층 구조에 원활하게 통합됨
- TextureView는 회전/크기 조절/알파 블렌딩과 같은 기능을 허용하여 변환하거나 애니메이션화할 수 있음
- 라이브 카메라 피드 표시, 커스텀 변환으로 비디오를 렌더링하는 등의 작업에 자주 사용됨
- SurfaceView와 달리 TextureView는 메인 스레드에서 작동함
- 이 떄문에 연속 렌더링에서는 성능적으로 덜 효율적이지만, 다른 UI 컴포넌트와의 더 나은 상호작용을 가능하게 하고 실시간 변환을 지원함

#### SurfaceView와 TextureView의 차이점
- SurfaceView는 별도의 Window를 생성하여 성능을 보장하지만, 변환이나 애니메이션화되는 능력은 제한됨
- 반면 TextureView는 다른 UI 컴포넌트와 동일한 Window를 공유하여 크기 조절/회전/애니메이션이 가능하므로 UI 관련 사용 사례에 더 유연하게 사용할 수 있음

#### 실전 질문
(1) 효율적인 리소스 관리 및 메모리 누수 방지를 위해 SurfaceView의 생명주기를 어떻게 적절하게 관리해야 하나요?
(2) 카메라 미리보기를 회전 및 크기 조절과 같은 UI 변환과 함께 표시해야 하는 요구 사항이 주어졌을 때, SurfaceView와 TextureView 중 어떤 컴포넌트를 선택하는 것이 적합한가요

### Q41. RecyclerView는 내부적으로 어떻게 작동하나요?


### Q42. Dp와 Sp의 차이점은 무엇인가요?
- 안드로이드 사용자 인터페이스를 디자인할 때, UI 컴포넌트가 다양한 화면 크기와 해상도에 어떻게 적응하는지 고려해야 함
- 이를 위해 필수적으로 사용되는 개념에는 Dp(Density-Independent Pixels)와 Sp(Scale-Independent Pixels)가 있음

#### Dp란 무엇인가?
- Dp는 패딩, 마진, 너비와 같은 UI 요소의 측정 단위
- 다양한 화면 밀도를 가진 기기에서 UI 컴포넌트의 일관된 물리적 크기를 제공하도록 설게되었음
- 1dp는 160DPI 화면의 물리적 픽셀 1개와 같으며, 안드로이드는 기기 밀도에 맞게 Dp를 자동으로 조절함

#### Sp란 무엇인가?
- Sp는 텍스트 크기에만 사용됨
- Dp와 유사하게 작동하지만 사용자의 글꼴 크기 환경 설정을 추가로 고려함
- Sp는 화면 밀도와 기기 접근성 설정 모두를 기반으로 텍스트 크기를 조절하므로 읽기 쉽고 접근 가능한 텍스트를 보장하는 데 이상적

#### Dp와 Sp의 주요 차이점
- 목적: Dp는 크기에 사용하고 Sp는 텍스트 크기에 사용
- 사용자 정의 환경: Sp는 사용자가 정의한 글꼴 크기 환경 설정을 반영하지만 Dp는 그렇지 않음
- 밀도 보장성: 둘 다 화면 밀도에 따라 크기가 조절되지만, Sp는 모든 사용자가 텍스트를 접근 가능하고 읽을 수 있도록 보장함

#### Pro Tips for Mastery: Sp 단위를 사용할 때 화면 깨짐을 어떻게 처리하나요?
- Sp를 사용하는 건 화면 밀도와 사용자 글꼴 환경 설정에 따라 크기가 조절되므로 중요함
- 하지만 사용자가 정의한 큰 글꼴 크기로 인한 과도한 크기 조절은 UI 컴포넌트가 겹치거나 화면을 벗어나는 레이아웃 깨짐 문제로 이어질 수 있음

##### 화면 깨짐 방지 전략
- 사용자가 시스템 글꼴 크기를 크게 늘리면 텍스트 요소가 의도한 경계를 넘어 커질 수 있음

(1) 콘텐츠를 적절하게 감싸기(Wrap content)
- TextView나 Button과 같은 텍스트 기반 컴포넌트의 크기가 wrap_content로 설정되었는 지 확인
(2) TextView에 minLines 또는 maxLines 사용하기
- 오버플로우를 올바르게 처리하려면 ellipsize와 결합해야 함
(3) 중요한 UI 컴포넌트에 고정 크기 사용하기
- 일관된 크기가 필수적인 경우, 버튼과 같은 중요한 컴포넌트에 Dp 사용을 고려해야 함
(4) 극단적인 글꼴 크기로 테스트하기
- 항상 기기 설정에서 사용할 수 있는 가장 큰 시스템 글꼴 크기로 앱을 테스트하는 방법
(5) 제약 조건을 사용한 동적 크기 조절 고려하기
- ConstraintLayout을 사용하여 컴포넌트 위치 지정 및 크기 조절에 유연성을 더하는 방법
(6) Sp 대신 Dp 크기 사용하기

#### 실전 질문
(1) 텍스트 크기에 Sp를 사용할 때 발생할 수 있는 잠재적인 레이아웃 깨짐 문제를 경험해 보거나 해결해 본 적이 있나요?

### Q43. 나인패치 이미지의 용도는 무엇인가요?
- 나인패치 이미지는 시각적 품질을 잃지 않고 늘리거나 크기를 조절할 수 있는 특수 형식의 PNG 이미지
- 안드로이드에서 유연하고 적응 가능한 UI 컴포넌트를 만드는 데 필수적
- 버튼, 배경, 컨테이너와 같이 다양한 화면 크기 및 콘텐츠 크기에 맞게 동적으로 크기를 조절해야 하는 요소에 사용됨

#### 주요 특징
(1) 늘어나는 영역
- 이미지의 나머지 부분의 무결성을 유지하면서 늘릴 수 있는 영역을 정의함
- 이미지의 가장 바깥쪽 1픽셀 테두리에 있는 검은색 선을 사용하여 정의할 수 있음
(2) 콘텐츠 영역 정의
- 검은색 선은 이미지 내부에서 늘어날 수 있는 콘텐츠 영역을 지정하여 이미지 내 텍스트 또는 기타 UI 요소의 적절한 정렬을 보장함
(3) 동적 크기 조절
- 비례적으로 크기가 조절되어 다양한 화면 크기를 가진 기기에서도 UI 컴포넌트가 깨지지 않고 모양을 유지하도록 보장함

#### 한계
(1) 수동 생성
- 적절한 크기 조절 및 정렬을 보장하기 위해 수동적으로 이미지 리소스를 생성해야 하고, 실제로 잘 동작하는지 테스트가 필요함
(2) 제한된 사용 사례
- 직사각형 또는 정사각형 형태의 요소(채팅 말풍선 등)에 가장 적합하며, 복잡하거나 불규칙한 모양에는 덜 효과적

#### 실전 질문
(1) 나인패치 이미지는 일반 PNG 이미지와 어떻게 다르며, 어떤 시나리오에서 나인패치 이미지를 사용해야 하나요?

### Q44. Drawable이란 무엇이며, UI 개발에서 어떻게 사용되나요?
- Drawable은 화면에 그릴 수 있는 모든 것에 대한 추상화 개념
- 이미지, 벡터 그래픽, 특정 모양 기반 요소와 같은 다양한 유형의 그래픽 콘텐츠의 기본 클래스 역할
- 배경, 버튼, 아이콘, 커스텀 뷰를 포함한 UI 컴포넌트에서 널리 사용됨

(1) BitmapDrawable
- PNG, JPG, PIF 같은 래스터 이미지를 표시하는 데 사용
- 비트맵 이미지의 크기 조절, 타일링, 필터링을 허용함
- ImageView 컴포넌트에서 이미지 표시 또는 배경으로 사용됨

(2) VectorDrawable
- XML 경로를 사용하여 확장 가능한 벡터 그래픽을 나타냄
- 비트맵과 달리 벡터는 어떤 해상도에서도 품질을 유지함
- 아이콘, 로고, 확장 가능한 UI 요소에 이상적

(3) NinePatchDrawable
- 모서리나 패딩과 같은 특정 영역을 보존하면서 크기를 조절할 수 있는 특수 유형의 비트맵
- 채팅 말풍선, 버튼과 같이 특정 영역에 있어서 늘어나는 UI 컴포넌트를 만드는 데 유용함
- 나인패치 이미지(.9.png)에는 늘어나는 영역과 고정 영역을 정의하는 추가 1픽셀 테두리가 포함됨

(4) ShapeDrawable
- XML에서 정의되며 이미지를 사용하지 않고 둥근 사각형, 타원 또는 기타 단순한 모양을 만드는 데 사용할 수 있음
- 버튼, 배경 및 커스텀 UI 컴포넌트에 유용함

(5) LayerDrawable
- 여러 Drawable을 단일 계층 구조로 결합하는 데 사용되며 복잡한 UI 배경에 유용함
- 오버레이 효과 및 쌓인 시각 효과를 만드는 데 유용함함

#### 실전 질문
(1) Drawable만 사용하여 사용자 상호 작용에 따라 모양과 색상이 변경되는 동적 배경을 가진 버튼을 어떻게 만들 수 있나요?






