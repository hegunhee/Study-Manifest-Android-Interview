# Q24) 예외를 어떻게 추적하나요?
- Logcat을 이용한 예외 로깅
- try/catch를 이용한 예외 처리
- 전역 예외 핸들러 사용하기 -> 로깅 특화
- Firebase Crashlytics -> 프로덕션 환경에서 예외 추적, 커스텀 예외 기록 등
- 브레이크포인트를 이용한 디버깅 -> 코드 실행을 일시 중지하고 검사
- 버그 리포트 캡처

### 실전 질문) Logcat을 사용해 개발 환경에서 예외를 디버깅하는 것과 Firebase Crashlytics를 사용해 프로덕션 환경에서 예외를 처리하는 것의 차이점은? 로컬 환경에서 추적된 예외와 프로덕션에서 추적된 예외를 각각 어떻게 처리하는지?

# Q25) 빌드 변형과 플레이버란 무엇인가요?
- 단일 코드베이스에서 애플리케이션의 다양한 버전을 생성하는 유연한 방법을 제공함
- 동일한 프로젝트 내에서 개발/프로덕션 빌드 또는 무료/유료 버전과 같은 여러 구성을 효율적으로 관리할 수 있음

### 빌드 변형
- 특정 빌드 타입과 제품 플레이버를 결합한 결과
- 디버그
  - 개발 중에 사용되는 빌드 구성
- 릴리스
  - 배포에 최적화된 구성
  - 리소스 최적화 및 최소화, 난독화가 적용되며, 스토어 게시를 위해 별도의 릴리스 키로 서명해야 함
- 제품 플레이버
  - 무료/유료 버전이나 us/eu와 같은 지역별 버전 등 앱의 다양한 변형을 정의할 수 있음

### 빌드 변형 및 플레이버 사용의 이점
- 효율적인 구성
  - 중복 코드를 줄이고 단일 코드베이스에서 여러 빌드를 처리할 수 있음
- 커스텀 동작
  - 유료 버전에서 프리미엄 기능을 활성화하거나
  - 디버그/릴리스 빌드에서 각각 다른 API를 사용하는 등 앱 동작을 맞춤 설정할 수 있음
- 자동화
  - 빌드 변형에 따라 APK 서명, 최적화 및 난독화 같은 작업을 자동화함

### 실전 질문) 빌드 타입과 제품 플레이버의 차이점은 무엇이며, 빌드 변형을 생성하기 위해 그 두 가지가 어떤 식으로 함게 작동하나요?


# Q26) 접근성을 어떻게 보장하나요?
- 시각, 청각 또는 신체 장애가 있는 사람들을 포함하여 모든 사람이 애플리케이션을 사용할 수 있도록 보장하는 것
- 사용자 경험이 향상되고 WCAG와 같은 글로벌 접근성 표준 준수를 보장할 수 있음

### 콘텐츠 설명 활용하기
- UI 컴포넌트에 텍스트 레이블을 제공하여 Talkback과 같은 스크린 리더가 시각 장애가 있는 사용자에게 해당 컴포넌트를 알릴 수 있도록 함
- 버튼, 이미지, 아이콘과 같이 상호 작용하거나 정보를 제공하는 컴포넌트에는 android:contentDescription 속성을 사용함

### 동적 글꼴 크기 지원하기
- 앱이 기기 설정에서 사용자가 설정한 글꼴 크기 환경 설정을 따르도록 보장함
- 접근성 설정에 따라 자동으로 크기가 조정되도록 텍스트 크기에는 sp 단위를 사용함

### 포커스 관리 및 탐색
- 커스텀 뷰, 다이얼로그의 경우 포커스 동작을 적절하게 관리해야 함
- android:nextFocusDown, android:nextFocusUp 및 관련 속성을 사용함

### 색상 대비 및 시각적 접근성
- 저시력자, 색맹 사용자의 가독성을 향상시키기 위해 텍스트/배경색 간에 충분한 대비를 제공해야 함

### 커스텀 뷰 및 접근성
- AccessibilityDelegate를 구현하여 스크린 리더가 커스텀 UI 컴포넌트와 상호 작용하는 방식을 정의할 수 있음

### 접근성 테스트하기
- Accessibility Scanner 및 Layout Inspector와 같은 도구를 사용하여 접근성 문제를 식별하고 수정함

### 실전 질문) 동적인 글꼴 사이즈를 지원하기 위한 모범 사례는 무엇이고, 텍스트 크기에 dp 단위보다 sp 단위를 사용하는 것이 선호되는 이유는 무엇인가요?

### 실전 질문) 개발자는 보조 기술에 의존하는 사용자를 위해 적절한 포커스 관리 및 탐색을 어떻게 보장할 수 있으며, 접근성 문제를 테스트하는 데 도움이 되는 안드로이드 도구에는 무엇이 있나요?

# Q27) 안드로이드 파일 시스템이란 무엇인가요?
- 안드로이드 기기에서 데이터 저장을 관리하고 구성하는 구조화된 환경
- 앱과 사용자가 파일을 효율적으로 저장, 검색, 관리할 수 있게 함
- 리눅스의 파일 시스템 아키텍처 위에 구축되어 엄격한 보안 및 권한 모델을 준수하면서 앱을 위한 비공개 및 공유 저장 공간을 모두 제공

### 안드로이드 파일 시스템의 주요 구성 요소
- System Partition
  - 안드로이드 프레임워크 라이브러리, 시스템 앱 및 구성 파일을 포함한 핵심 운영 체제 파일이 들어 있음
  - 우발적/악의적 수정을 방지하기 위해 일반 사용자/앱에 대해 읽기 전용
- Data Partition
  - 데이터베이스, SharedPreferences 및 사용자가 생성한 파일을 포함한 앱별 데이터가 저장됨
  - 각 앱은 /data/data 내에 해당 앱만 접근할 수 있는 비공개 디렉토리를 가지므로 데이터 보안이 보장
- Cache Partition
  - 시스템 업데이트, 기기 재시작 시 유지할 필요가 없는 캐시 파일과 같은 임시 데이터 저장에 사용됨
- External Storage
  - 여러 앱에서 접근할 수 있는 공유 저장 공간을 제공
  - 이미지, 비디오, 문서와 같은 미디어 파일에 자주 사용됨
  - 내부 또는 이동식 SD 카드일 수 있음
- Temporary Files
  - 앱 실행 중 임시 파일을 저장하는 위치
  - 일반적으로 앱이나 시스템이 재시작될 때 지워짐

### 안드로이드에서 파일 접근하기
- 앱은 안드로이드 프레임워크에서 제공하는 API를 사용하여 파일 시스템과 상호 작용함
- 내부 저장소
  - 애플리케이션 샌드박스 내의 비공개 저장 공간
  - 해당 앱만 접근할 수 있음
  - 민감한 데이터나 앱별 데이터 저장에 이상적
- 외부 저장소
  - 여러 앱에서 접근할 수 있는 공유 저장 공간
  - 사용자가 앱 외부에서 접근할 것으로 예상하는 사용자 생성 콘텐츠/미디어를 저장할 때 사용

### 파일 권한 및 보안
- 안드로이드 파일 시스템은 엄격한 권한 모델을 적용함
- 비공개 앱 데이터
  - 앱의 내부 저장소에 저장된 파일은 비공개이며 해당 앱만 접근할 수 있음
- 공유 파일
  - 앱 간에 파일을 공유하려면 개발자는 외부 저장소나 적절한 권한이 있는 ContentProvider를 사용할 수 있음
- 범위 지정 저장소
  - 안드로이드 10에서 도입되었으며, 공유 저장소에 대한 직접 접근을 제한하여 앱이 MediaStore/SAF API를 사용하도록 요구함

### 실전 질문) 안드로이드는 파일 시스템에서 보안 및 권한을 어떻게 관리하며, 앱이 서로의 비공개 데이터에 접근할 수 없도록 보장하는 메커니즘은 무엇인가요?

# Q28) ART, Dalvik, Dex 컴파일러란 무엇인가요?
### ART
- 안드로이드 4.4(Kitkat)에서 도입되어 Android 5.0(Lollipop)부터 디폴트로 사용되는 런타임 환경
- Ahead-of-Time(AOT) 컴파일을 사용하여 애플리케이션을 컴파일하며, 앱 설치 중에 바이트 코드를 기계 코드로 변환
- 런타임 시 Just-in-Time 컴파일의 필요성을 없애 앱 시작 시간을 단축하고 실행중 CPU 사용량을 줄임
  - JIT 컴파일과 혼합해서 사용하는걸로 알고 있음

- 개선된 성능
  - AOT 컴파일은 최적화된 기계 코드를 생성하여 런타임 오버헤드를 줄임
- 가비지 컬렉션
  - ART는 더 나은 메모리 관리를 위해 개선된 GC 기술을 도입했음
- 디버깅 및 프로파일링 지원
  - 개발자를 위해 상세한 스택 트레이스 및 메모리 사용량 분석과 같은 향상된 도구를 제공

### Dalvik
- ART 이전에 안드로이드에서 사용된 런타임
- 가성 머신 환경에서 애플리케이션을 실행하도록 설계되었으며, 제한된 메모리와 처리 능력을 위해 최적화됨
- Just-in-Time 컴파일을 사용하여 런타임에 바이트코드를 기계 코드로 변환함
- 앱 설치에 필요한 시간을 줄이지만, 즉석 컴파일로 인해 런타임 오버헤드가 증가함

- 컴팩트한 바이트 코드
  - 낮은 메모리 사용량과 빠른 실행을 위해 최적화된 dex 파일을 사용함
- 레지스터 기반 VM
  - 스택 기반이 아닌 레지스터 기반이므로 명령어 효율성이 향상됨
- 느린 앱 시작 시간, 높은 CPU 사용량 등의 한계로 인해 ART로 대체되었음

### Dex 컴파일러
- Java/Kotlin 컴파일러에서 생성된 Java 바이트코드를 dex 파일로 변환함
- dex 파일은 컴팩트하며 Dalvik/ART 런타임 환경에 최적화되어 있음

- 멀티덱스 지원
  - 64k 메서드 제한을 초과하는 애플리케이션의 경우 dex 컴파일러는 바이트코드를 여러 dex 파일로 분할함
- 바이트코드 최적화
  - 안드로이드 기기에서 더 나은 메모리 사용량과 실행 성능을 위해 바이트코드를 최적화함

# Q29) APK 파일과 AAB 파일의 차이점은 무엇인가요?
- 안드로이드 애플리케이션은 두 가지 기본 포맷인 APK와 AAB를 사용하여 배포 및 설치할 수 있음

### APK
- 안드로이드 애플리케이션을 배포하고 설치하는 전통적인 포맷
- 앱이 기기에서 작동하는 데 필요한 모든 리소스, 코드 및 메타데이터를 포함하는 완전하고 즉시 설치 가능한 패키지
- APK 파일은 과할 정도로 완전하다고 볼 수 있음
- 화면 밀도, CPU 아키텍처, 언어에 대한 모든 리소스를 포함하기 때문에
  사용자의 기기와 관련 없는 리소스를 포함하게 되어 파일 크기가 커질 수 있음
- 기기에 직접 설치되며, 앱 스토어 외부에서 공유하거나 사이드로딩할 수도 있음

### AAB
- 설치 가능한 APK와는 다른 게시 포멧
- AAB를 구글 플레이에 업로드하면, 구글 플레이는 이를 개별 기기에 맞게 최적화된 APK로 처리함
- AAB 파일은 모듈식으로, 다른 구성에 대한 리소스와 코드를 별개의 번들로 분리함
- 구글 플레이는 이 모듈식 구조를 사용하여 다운로드 시점에 기기별 APK를 생성함
  -> 필요한 리소스와 코드만 전달하여 사용자 기기의 앱 크기를 감소시킴
- AAB 파일은 구글 플레이의 서버 측에서 처리되므로 직접 설치할 수 없음(사이드 로딩 불가능)

### APK와 AAB의 주요 차이점
- 목적 및 구조
  - APK: 모든 구성에 대한 모든 리소스와 코드를 포함하는 완전한 패키지
  - AAB: 기기별 APK를 생성하는 모듈식 게시 형식
- 파일 크기
  - APK: 모든 기기에 대한 리소스를 포함하여 크기가 더 큼
  - AAB: 더 작고 최적화된 APK를 생성할 수 있게 하여 사용자에게 전달되는 앱 크기를 줄였음
- 배포
  - APK: 기기에 직접 공유하고 사이드로딩할 수 있음
  - AAB: 구글 플레이에 업로드되며, 구글 플레이가 최종 사용자를 위해 최적화된 APK를 생성
- 관리
  - APK: 개발자가 리소스와 구성을 수동으로 관리해야 함
  - AAB: 구성 관리를 구글 플레이에 위임하여 프로세스를 자동화
- 도구 및 호환성
  - APK: 모든 안드로이드 기기 및 앱 스토어에서 지원됨
  - AAB: 설치 가능한 APK를 생성하기 위해 구글 플레이/bundletool이 필요하며, 기본적으로 플레이 외 다른 스토어와 호환되지 않음

# Q30) R8 최적화란 무엇인가요?
- R8은 안드로이드 빌드 프로세스에서 APK/AAB의 크기를 줄이고 런타임 성능을 향상시키기 위해 사용되는 코드 축소 및 최적화 도구
- 안드로이드 빌드 시스템에 통합되어 Proguard를 대체함
- 코드 축소, 최적화, 난독화 및 리소스 관리를 위한 향상된 기능을 제공함

### R8 작동 방식
- 코드 축소
  - 애플리케이션 코드베이스에서 사용되지 않는 클래스, 메서드, 필드 및 속성을 제거하여 최종적인 APK/AAB의 크기를 줄임
- 최적화
  - 런타임 성능 향상을 위해 코드를 단순화하고 재구성함
  - 메서드 인라이닝, 중복 코드 제거, 동일한 코드 블록 병합 등이 포함됨
- 난독화
  - 클래스, 메서드, 필드의 이름을 변경하여 원래 이름을 모호하게 만들어 리버스 엔지니어링을 어렵게 만듬
- 리소스 최적화
  - 사용되지 않는 리소스를 제거하여 앱 사이즈를 최소화

### R8 최적화의 주요 특징
- 죽은 코드 제거
  - R8은 코드베이스를 분석하여 앱에서 도달할 수 없거나 사용되지 않는 코드를 식별하고 제거
- 인라이닝
  - 짧은 메서드나 함수를 호출자 쪽에 직접 인라인하여 메서드 호출 오버헤드를 줄이고 런타임 성능을 향상시킴
- 클래스 병합
  - 유사한 클래스나 인터페이스를 하나로 결합하여 메모리 공간을 줄이고 효율성을 향상시킴
- 도달 불가능한 코드 제거
  - 실행되지 않는 코드 경로를 완전히 제거
- 상수 폴딩 및 전파
  - 표현식을 단순화하고 변수를 가능한 경우 해당 상수 값으로 대체
- 난독화
  - R8은 코드의 의미 있는 이름을 더 짧고 덜 설명적인 이름으로 대체(유추가 어렵도록) 앱 크기 줄이고 리버스 엔지니어링을 더 어렵게 만듬

### R8의 구성
- R8은 Proguard 규칙을 동일하게 적용함

- 리플렉션을 위한 코드 보존
  - 리플렉션을 통해 접근하는 클래스나 메서드는 런타임에 해당 패키지 이름을 알아야 하므로 Proguard 규칙에 명시적으로 keep하여  난독화되지 않도록 해야 함
- 서드파티 라이브러리 제외
  - 일부 라이브러리는 내부적으로 리플렉션을 사용할 수도 있고, 정상적인 기능 동작을 위해 특정 규칙이 필요할 수 있음

### R8의 장점
- 긴밀한 통합
  - R8은 안드로이드 빌드 시스템이 내장되어 있어 일반적인 Progurad 규칙 외에 추가 설정이 필요하지 않음
- 향상된 효율성
  - 축소, 최적화 및 난독화를 단일 패스로 결합하여 Proguard보다 빠르고 효율적
- 앱 크기 감소
  - 사용되지 않는 코드와 리소스를 제거하여 최종 APK/AAB 크기를 크게 줄임
- 향상된 보안
  - 난독화는 앱을 리버스 엔지니어링하기 어렵게 만들어 보안을 강화함

### R8의 한계
- 과도한 축소 위험
  - 제대로 구성하지 않으면 R8이 간접적으로 참조되는 코드나 리소스를 제거하여 런타임 오류가 발생할 수 있음
- 복잡한 구성
  - 리플렉션/동적 클래스 로딩을 사용하는 프로젝트는 Proguard 규칙 작성이 복잡하고 까다로울 수 있음
- 디버깅 어려움
  - 난독화는 스택 트레이스에 난독화된 이름이 로깅되므로 디버깅이 어려워짐 -> 릴리스 빌드에서만 사용하기











