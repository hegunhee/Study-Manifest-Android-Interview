## ❓ Q) 예외(exceptions)를 어떻게 추적하나요?

안드로이드 앱에서 예외 추적은 문제를 진단하고 해결하는 데 매우 중요합니다. 대표적인 방법은 다음과 같습니다.

---

### 🔍 1. Logcat을 이용한 예외 로깅

- Android Studio의 **Logcat**은 예외 발생 시 자동으로 **스택 트레이스**, 예외 메시지, 발생 위치를 출력합니다.
- `E/AndroidRuntime` 등의 키워드로 필터링하면 예외에 집중할 수 있습니다.

```kotlin
try {
    val result = performRiskyOperation()
} catch (e: Exception) {
    Log.e("Error", "Exception occurred: ${e.message}", e)
}
```

---

### 🛡️ 2. try-catch 블록 활용

- 예외 발생 시 앱이 크래시 나는 것을 방지하고, 예외 메시지를 로깅하여 문제를 추적할 수 있습니다.
- 특히 중요한 연산이나 네트워크 호출 등에서 자주 사용합니다.

---

### 🌐 3. 전역 예외 핸들러 설정

- `Thread.setDefaultUncaughtExceptionHandler`를 이용해 앱 전역에서 처리되지 않은 예외를 포착할 수 있습니다.
- 예외를 저장하거나 Crashlytics로 전송하는 등 중앙 집중식 로깅이 가능합니다.

```kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
            Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}: ${exception.message}", exception)
            // FirebaseCrashlytics.getInstance().recordException(exception)
            defaultHandler?.uncaughtException(thread, exception)
        }
    }
}
```

---

### ☁️ 4. Firebase Crashlytics 사용

- 프로덕션 환경에서는 **Crashlytics**를 통해 예외를 자동으로 기록하고 분석합니다.
- 스택 트레이스, 기기 상태, 사용자 정보 등을 함께 수집해 상세한 보고서를 제공합니다.
- 중요하지 않은 예외도 수동으로 기록 가능함.

```kotlin
try {
    val data = fetchData()
} catch (e: IOException) {
    FirebaseCrashlytics.getInstance().recordException(e)
}
```

---

### 🐞 5. Breakpoints를 이용한 디버깅

- Android Studio의 **브레이크포인트** 기능을 활용하면 예외 발생 지점에서 중단하고 상태를 분석할 수 있어 개발 중 디버깅에 유용합니다.

---

### 🛠️ 6. Bug Report 캡처

- ADB 또는 Android Emulator, 개발자 옵션에서 **Bug Report**를 생성해 시스템 로그 및 예외 정보를 종합적으로 수집할 수 있습니다.

---

### 📌 요약

| 방법 | 용도 |
|------|------|
| Logcat | 기본적인 예외 로그 확인 |
| try-catch | 예외 발생 방지 및 상세 로그 출력 |
| 전역 예외 핸들러 | 처리되지 않은 예외 포착, 중앙 집중형 로깅 |
| Firebase Crashlytics | 프로덕션 환경 예외 수집 및 분석 |
| Breakpoints | 개발 중 정밀한 디버깅 |
| Bug Report | 시스템 수준의 디버깅 정보 수집 |

---

### ✅ 실전 질문 답변

---

**Q)** Logcat을 사용하여 개발 환경에서 예외를 디버깅하는 것과 Firebase Crashlytics와 같은 도구를 사용하여 프로덕션 환경에서 예외를 처리하는 것의 차이점은 무엇인가요?  
또한, Logcat과 같은 로컬 환경에서 추적된 예외랑 프로덕션에서 추적된 예외를 각각 어떻게 해결하시나요?

---

### 🧪 개발 환경 (Logcat) vs 🛰️ 프로덕션 환경 (Crashlytics)의 차이

| 항목 | Logcat (개발 환경) | Crashlytics (운영 환경) |
|------|---------------------|--------------------------|
| **용도** | 실시간 예외 추적 및 디버깅 | 사용자 환경에서 발생한 예외 수집 및 분석 |
| **사용 대상** | 개발자 본인의 테스트 기기 | 실제 사용자 디바이스 |
| **정보의 양** | 상세한 로그, 변수 상태, StackTrace 등 풍부 | 일부 시스템 로그만 제한적으로 수집 |
| **분석 방법** | 즉시 중단 후 상태 분석, 재현 쉬움 | 이슈 ID, 발생 기기, 사용자 수 기준 필터링 |
| **예외 발생 시점** | 예외 직후 즉시 대응 가능 | 서버 수집 이후 분석 필요 |
| **단점** | 실사용자 환경과 차이 있음 | 스택 트레이스만으로 원인 추적이 어려울 수 있음 |

---

### 🛠️ 예외 해결 방식

#### 1. Logcat으로 확인된 예외
- 예외 발생 시 `Logcat`에서 `E/AndroidRuntime` 또는 커스텀 태그를 통해 원인을 실시간으로 추적합니다.
- StackTrace, 변수 상태를 기반으로 IDE에서 즉시 브레이크포인트로 디버깅하여 재현과 수정이 쉽습니다.
- 예: `NullPointerException` → 해당 객체의 초기화 여부 확인 후 `null-safe` 처리 추가.

#### 2. Crashlytics로 보고된 예외
- 사용자 단말에서 발생한 예외가 Crashlytics 대시보드에 수집되면, 우선적으로 **발생률이 높은 이슈**부터 확인합니다.
- 예외가 발생한 기기, OS 버전, 앱 버전, 사용자의 행동 흐름 등을 기준으로 **재현 시나리오**를 추측합니다.
- 재현이 어려운 경우에도 로그 내 context 정보(`custom log`, `setUserId`, `setCustomKey`)를 함께 수집해두면 원인 추적에 도움이 됩니다.
- 이후 **테스트 기기에서 유사한 조건**으로 재현하여 수정하고, Firebase Test Lab이나 QA 환경에서 회귀 테스트를 진행합니다.

---

### 📌 추가 사항: 실무 예외 처리 전략  
[PRND 블로그 – 아릅답게 앱 오류 처리하기](https://medium.com/prnd/%EC%95%84%EB%A6%84%EB%8B%B5%EA%B2%8C-%EC%95%B1-%EC%98%A4%EB%A5%98-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-8bf9a46df515) 요약

---

### 🔄 ✨ 치명적 예외에도 앱 종료 대신 회복시키는 전략

#### ✅ 시나리오

앱에서 예기치 못한 치명적 예외(예: `NullPointerException`, `IllegalStateException`, 심지어 ANR 유사 상황 등)가 발생할 수 있습니다. 이때 보통은 앱이 **즉시 종료**되지만, PRND에서는 아래와 같은 전략을 적용합니다:

1. **전역 예외 처리기**(`UncaughtExceptionHandler`)를 등록해 모든 치명적 예외를 감지합니다.
2. 해당 예외가 발생하더라도 앱을 즉시 종료하지 않고, **처리 가능한 화면이나 초기 상태로 복귀**하도록 합니다.
3. 동시에 **Firebase Crashlytics에 예외 정보를 기록**하여 개발자는 문제를 인지할 수 있습니다.
4. QA 팀은 **디버그 빌드에서 로그를 통해 재현 시나리오 및 흐름을 정리해 개발자에게 전달**합니다.

---

#### 🎯 이렇게 처리하면 얻는 효과

| 역할 | 효과 |
|------|------|
| 사용자 | 앱이 죽지 않고 복구되어 **UX가 훼손되지 않음** |
| 개발팀 | Crashlytics에 기록되어 **운영 이슈를 실시간으로 인지** |
| QA팀 | 디버그 로그와 예외 기록으로 **명확한 오류 보고 가능** |

#### ✅ 1. `DEBUG` 빌드에서는 Crashlytics 비활성화

```kotlin
if (!BuildConfig.DEBUG) {
    FirebaseCrashlytics.getInstance().recordException(e)
}
```

또는 헬퍼로 래핑해서 조건 처리:

```kotlin
object MyCrashlyticsLogger {
    fun logException(tag: String, e: Throwable) {
        Log.e(tag, "Exception: ${e.message}", e)
        if (!BuildConfig.DEBUG) {
            FirebaseCrashlytics.getInstance().recordException(e)
        }
    }
}
```

---

#### 🗂️ 2. 비정상 상태지만 크래시는 아닌 경우

```kotlin
if (banner == null) {
    FirebaseCrashlytics.getInstance().recordException(
        Throwable("홈 배너가 null 상태에서 화면 진입")
    )
}
```

---

#### 🔑 3. 사용자 정보, 상태 정보 남기기

```kotlin
FirebaseCrashlytics.getInstance().setUserId("user_1329")
FirebaseCrashlytics.getInstance().setCustomKey("userType", "partner")
FirebaseCrashlytics.getInstance().setCustomKey("currentPage", "MainFragment")
FirebaseCrashlytics.getInstance().log("사용자가 결제 버튼을 누름")
```

---

#### 🚫 4. 네트워크 예외는 반드시 구분

```kotlin
try {
    val response = apiService.getData()
} catch (e: IOException) {
    Log.w("Network", "네트워크 오류: ${e.message}")
    // FirebaseCrashlytics.getInstance().recordException(e) ❌ 하지 않음
}
```

---

### 🔁 실무 전략 요약

| 예외 유형 | 처리 방식 |
|-----------|-----------|
| 개발 중 발생 | `Logcat` + `Log.e()`로 추적, Crashlytics는 제외 |
| 운영 중 치명적 예외 | `recordException()`으로 수집 |
| UI 오류 / 비정상 흐름 | `Throwable()` 수동 생성 후 `recordException()` |
| 네트워크 예외 | `Log.w()` 등으로만 처리, Crashlytics 제외 |
| 사용자 상태 기록 | `setCustomKey()`, `setUserId()` 활용 |

---

### ✅ 마무리 요약

> 단순히 예외를 로깅하거나 앱을 종료시키는 것에 그치지 않고,  
> **사용자 경험을 보호하면서도** 예외를 **기록 및 보고 가능한 체계**를 갖추면  
> 개발팀, QA팀, 사용자 모두에게 이득이 됩니다.  
> 특히, QA는 디버그 로그 기반으로 **정확한 시나리오를 개발팀에 전달**할 수 있어  
> 근본적인 해결에 매우 효과적입니다.
