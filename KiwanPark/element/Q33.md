## ❓ Q) 33. View 생명주기를 설명해주세요

---

### 📌 개요
안드로이드 **View**의 생명주기는 **화면에 View가 추가되어 보이는 시점부터 제거될 때까지**의 흐름을 의미하며, Activity/Fragment 생명주기와 밀접하게 연결됩니다. View는 화면에 붙을 때(`onAttachedToWindow`)와 화면에서 떨어질 때(`onDetachedFromWindow`)를 기준으로 상태가 변화하며, 화면 크기나 배치 변화에 따라 측정(`onMeasure`), 배치(`onLayout`), 그리기(`onDraw`)가 이루어집니다.

---

### 🔄 View 생명주기 흐름
1. **생성**
   - XML 레이아웃 인플레이트 또는 코드에서 직접 생성.
   - 생성자 호출 후 초기화 로직 실행.

2. **onAttachedToWindow()**
   - View가 윈도우에 연결될 때 호출.
   - 리소스 초기화, 리스너 등록 등의 작업 수행.

3. **onMeasure()**
   - 부모 View로부터 측정 요청을 받아 크기 결정.
   - `MeasureSpec`을 기반으로 `setMeasuredDimension()` 호출.

4. **onLayout()**
   - 자식 View들의 위치와 크기를 결정.
   - `onMeasure` 이후 실행.

5. **onDraw()**
   - View의 실제 UI를 그리는 단계.
   - `Canvas` 객체를 사용.

6. **onDetachedFromWindow()**
   - View가 윈도우에서 제거될 때 호출.
   - 리소스 해제, 리스너 제거 등 정리 작업 수행.

---

### 💡 실무 팁
- **onAttachedToWindow / onDetachedFromWindow**에서 View 관련 리소스를 초기화/해제하면 메모리 누수를 방지할 수 있음.
- **onDraw**는 가능한 한 최소한의 연산만 수행해야 성능 저하를 피할 수 있음.
- 크기나 위치 변경이 필요한 경우 **onMeasure / onLayout**을 적절히 오버라이드.
- **invalidate()** 호출 시 onDraw 재호출, **requestLayout()** 호출 시 onMeasure → onLayout → onDraw 순으로 재실행.

---

### 💻 코드 예시

```kotlin
class CustomView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        // 리소스 초기화
    }

    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        val width = MeasureSpec.getSize(widthMeasureSpec)
        val height = MeasureSpec.getSize(heightMeasureSpec)
        setMeasuredDimension(width, height)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // 커스텀 UI 그리기
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        // 리소스 해제
    }
}
```

---

### 💬 실전 질문 1
**Q)** 이미지 로딩이나 애니메이션 설정과 같이 비용이 많이 드는 기능을 포함하는 커스텀 View를 만든다고 가정해 봅시다. View 생명주기의 어느 시점에서 이러한 리소스 및 기능을 초기화해야 하며, 메모리 누수를 방지하기 어떻게 방지할 수 있나요?

**A)**  
- **초기화 시점**: `onAttachedToWindow()`에서 초기화하는 것이 안전합니다. 이 시점은 View가 화면에 완전히 연결되어 UI 리소스를 사용할 준비가 된 상태입니다.  
- **메모리 누수 방지**: `onDetachedFromWindow()`에서 모든 리스너 해제, 애니메이션 중지, Bitmap 및 Drawable 해제, Glide/Picasso 등 이미지 로더 취소 작업을 수행합니다.  
- **추가 팁**: Context 참조는 Application Context로 대체하거나, View 외부의 장기 참조를 피해야 합니다.

---

### 💬 실전 질문 2
**Q)** 애플리케이션에 성능 문제가 발생하는 동적으로 생성된 View를 포함하는 복잡한 레이아웃이 있습니다. 적절한 응답성을 유지하면서 렌더링 효율성을 향상시키기 위해 onMeasure() 및 onLayout() 메서드를 어떻게 최적화할 수 있을까요?

**A)**  
- **onMeasure 최적화**  
  - 불필요한 측정 호출을 줄이기 위해 가능한 한 `EXACTLY` 모드 사용.
  - 자식 View의 크기가 고정이면 `measure()` 호출을 최소화.
  - 연산량이 많은 크기 계산 로직은 캐싱.
- **onLayout 최적화**  
  - 자식 View 위치 변경이 없는 경우 재배치 로직 생략.
  - 반복 루프 최소화 및 중복 연산 제거.
- **공통 전략**  
  - `requestLayout()` 호출 최소화.
  - 자식 View 수를 줄이고, 중첩 레이아웃을 ConstraintLayout 등으로 평탄화.
  - 필요 없는 invalidate 호출 방지.

---

### 💡 Pro Tips for Mastery: View의 findViewTreeLifecycleOwner() 함수

---

#### 📌 개요
`findViewTreeLifecycleOwner()`는 **View 트리에서 LifecycleOwner를 탐색**하여 반환하는 확장 함수입니다.  
- LifecycleOwner는 Activity, Fragment처럼 안드로이드 생명주기를 관리하는 주체입니다.
- View 자신이 LifecycleOwner를 직접 구현하지 않아도, 부모 View 트리를 거슬러 올라가면서 가장 가까운 LifecycleOwner를 찾아줍니다.

---

#### 🛠 활용 사례
1. **View에서 Lifecycle 인식 작업 수행**
   - 예: View 내부에서 LiveData 관찰  
     ```kotlin
     findViewTreeLifecycleOwner()?.let { owner ->
         myLiveData.observe(owner) { data ->
             updateUI(data)
         }
     }
     ```
2. **Fragment/Activity 참조 없이 UI 상태 동기화**
   - View가 Activity/Fragment에 직접 의존하지 않아도 됨.
3. **ViewModelStoreOwner와 연계**
   - ViewModel도 View 트리에서 안전하게 가져올 수 있음.

---

#### ⚠️ 주의점
- `findViewTreeLifecycleOwner()`는 View가 윈도우에 연결된 후(`onAttachedToWindow`)에 호출해야 정상 동작.
- 연결되지 않은 상태에서 호출하면 `null` 반환 가능.
- 생명주기 종료 시점(`onDetachedFromWindow`)에 등록한 Observer는 해제해야 메모리 누수 방지.

---

#### 📍 장점
- View 단에서 **생명주기 안전성** 확보.
- 재사용 가능한 Custom View 제작에 유리.
- Activity나 Fragment 참조 없이도 Lifecycle 기반 로직 구현 가능.
