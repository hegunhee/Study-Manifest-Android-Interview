## Q) 45. 안드로이드의 Bitmap이란 무엇이며, 큰 Bitmap을 효율적으로 처리하는 방법은 무엇인가요?

- Bitmap은 메모리 내 이미지 표현으로, 픽셀 데이터를 저장하며 리소스, 파일, 원격 소스에서 가져온 이미지를 화면에 렌더링하는 데 사용됩니다.
- 고해상도 이미지를 부적절하게 처리하면 OutOfMemoryError 등 메모리 문제가 발생할 수 있습니다.

### 큰 Bitmap의 문제점

- 카메라나 인터넷에서 받은 이미지는 UI가 요구하는 크기보다 큰 경우가 많습니다.
- 전체 해상도로 로드하면 다음과 같은 문제 발생:
  * 과도한 메모리 소비
  * 성능 오버헤드 유발
  * 메모리 압박으로 인한 크래시 발생 위험

### 메모리를 할당하지 않고 Bitmap 크기 읽기

- 이미지를 로드하기 전 크기를 확인해 불필요한 메모리 할당을 방지할 수 있습니다.
- `BitmapFactory.Options`에서 `inJustDecodeBounds = true`로 설정하면 픽셀 데이터를 할당하지 않고 메타데이터만 읽을 수 있습니다.

```kotlin
val options = BitmapFactory.Options().apply {
    inJustDecodeBounds = true
}
BitmapFactory.decodeResource(resources, R.drawable.myimage, options) // R.id -> R.drawable 수정

val imageWidth = options.outWidth
val imageHeight = options.outHeight
val imageType = options.outMimeType
```

### 샘플링을 사용하여 축소된 Bitmap 로드하기

* 이미지 크기를 알면 `inSampleSize`로 비트맵을 대상 크기에 맞게 축소 가능
* 2, 4 등의 배수로 서브샘플링해 메모리 사용량 절감
* 예: `inSampleSize = 4` → 2048×1536 이미지를 512×384로 축소

```kotlin
fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
    // 이미지의 원본 높이와 너비
    val (height, width) = options.run { outHeight to outWidth }
    var inSampleSize = 1

    if (height > reqHeight || width > reqWidth) {
        val halfHeight = height / 2
        val halfWidth = width / 2

        // 요청된 너비와 높이보다 크거나 같을 때까지 inSampleSize를 2배씩 늘립니다.
        while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
            inSampleSize *= 2
        }
    }
    return inSampleSize
}
```

### 서브샘플링을 사용한 전체 디코딩 프로세스

* calculateInSampleSize를 사용하여 두 단계로 비트맵 디코딩:

    1. 경계만 디코딩해 크기 확인
    2. 계산된 `inSampleSize`로 축소된 비트맵 디코딩

* UI에 적절한 크기의 이미지를 최적 메모리로 제공

```kotlin
fun decodeSampledBitmapFromResource(
    res: Resources,
    resId: Int,
    reqWidth: Int,
    reqHeight: Int
): Bitmap? { // Bitmap? 반환 타입 변경 (디코딩 실패 가능성)
    // 먼저 inJustDecodeBounds=true로 크기 확인
    return BitmapFactory.Options().run {
        inJustDecodeBounds = true
        BitmapFactory.decodeResource(res, resId, this)

        // inSampleSize 계산
        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)

        // inSampleSize를 설정하고 비트맵 디코딩
        inJustDecodeBounds = false
        BitmapFactory.decodeResource(res, resId, this)
    }
}
```

* ImageView에 적용 시 간단히 호출:

```kotlin
// ImageView 크기에 맞게 reqWidth, reqHeight 설정
val bitmap = decodeSampledBitmapFromResource(resources, R.drawable.myimage, 100, 100)
imageView.setImageBitmap(bitmap)
```

### 💡 Pro Tips for Mastery: 커스텀 이미지 로딩 시스템에서 큰 비트맵 캐싱을 어떻게 구현하나요?

* 이미지 목록, 그리드, 캐러셀 등에서 큰 비트맵을 효율적으로 관리해 원활하고 메모리 안전한 앱 구축 필요
* 안드로이드는 **LruCache(메모리 캐싱)**, **[DiskLruCache(디스크 캐싱)](https://github.com/JakeWharton/DiskLruCache)** 두 가지 전략 제공

#### LruCache를 사용한 메모리 내 캐싱

LruCache는 최근 사용 항목에 대한 강력한 참조를 유지하고, 메모리 부족 시 오래 사용되지 않은 항목 자동 제거합니다.
작동 방식은 다음과 같습니다:

```kotlin
object LruCacheManager {
    // 사용 가능한 최대 메모리 (KB)
    val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
    // 캐시 크기를 최대 메모리의 1/8로 설정
    val cacheSize = maxMemory / 8

    val memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
        // 캐시 항목 크기를 KB 단위로 정의
        override fun sizeOf(key: String, bitmap: Bitmap): Int {
            // 비트맵의 바이트 수를 KB로 변환
            return bitmap.byteCount / 1024
        }
    }
}

```

사용 가능한 메모리의 1/8 정도를 캐시 크기로 할당해 메모리 오버플로우 방지 및 중복 디코딩 회피합니다. 사용 방법은 다음과 같습니다:

```kotlin
fun loadBitmap(imageId: Int, imageView: ImageView) {
    val key = imageId.toString()
    // 메모리 캐시에서 먼저 확인
    LruCacheManager.memoryCache.get(key)?.let {
        imageView.setImageBitmap(it)
    } ?: run {
        // 캐시에 없으면 플레이스홀더 설정 및 백그라운드 작업 요청
        imageView.setImageResource(R.drawable.image_placeholder)

        val workRequest = OneTimeWorkRequestBuilder<BitmapDecodeWorker>()
            .setInputData(workDataOf("imageId" to imageId))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}

```

그리고 Jetpack의 커스텀 Worker에서는 아래와 같이 처리할 수 있습니다:

```kotlin
class BitmapDecodeWorker(
    context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        val imageId = inputData.getInt("imageId", -1)
        if (imageId == -1) return Result.failure()

        // 리소스에서 샘플링된 비트맵 디코딩
        val bitmap = decodeSampledBitmapFromResource(
            res = applicationContext.resources,
            resId = imageId,
            reqWidth = 100, // 대상 너비
            reqHeight = 100 // 대상 높이
        )

        // 비트맵을 메모리 캐시에 추가
        bitmap?.let {
            LruCacheManager.memoryCache.put(imageId.toString(), it)
            return Result.success()
        }

        return Result.failure()
    }
}
```
여기서 메모리 핸들링 로직에 SoftReference/WeakReference는 사용하지 않음 → 공격적인 GC로 캐싱값 신뢰 불가 때문



#### DiskLruCache를 사용한 디스크 캐싱

- 비트맵이 앱 세션 간에 지속되고 재계산을 피하도록 보장하려면 DiskLruCache 라이브러리를 사용하여 비트맵을 디스크에 저장할 수 있습니다.
- 특히 리소스 집약적인 이미지나 스크롤 가능한 이미지 목록을 처리할 때 유용

먼저, 디코딩된 비트맵을 유지하기 위해 안전한 해싱 및 I/O 로직으로 [DiskLruCache](https://github.com/JakeWharton/DiskLruCache)를 래핑하는 DiskCacheManager를 작성할 수 있습니다.

```kotlin
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import com.jakewharton.disklrucache.DiskLruCache
import java.io.File
import java.io.IOException
import java.io.OutputStream
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException

class DiskCacheManager(context: Context, cacheDirName: String = "images", cacheSize: Long = 10 * 1024 * 1024) {

    private var diskLruCache: DiskLruCache? = null
    private val lock = Any()

    init {
        val cacheDir = getDiskCacheDir(context, cacheDirName)
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        try {
            // DiskLruCache 열기 (앱 버전, 값 개수, 최대 크기)
            diskLruCache = DiskLruCache.open(cacheDir, 1, 1, cacheSize)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun getDiskCacheDir(context: Context, uniqueName: String): File {
        val cachePath = context.cacheDir.path
        return File(cachePath + File.separator + uniqueName)
    }

    // 키를 안전한 파일 이름으로 변환 (SHA-1 사용)
    private fun filenameForKey(key: String): String {
        return try {
            val messageDigest = MessageDigest.getInstance("SHA-1")
            messageDigest.update(key.toByteArray())
            bytesToHexString(messageDigest.digest())
        } catch (e: NoSuchAlgorithmException) {
            key.hashCode().toString() // fallback
        }
    }

    private fun bytesToHexString(bytes: ByteArray): String {
        val sb = StringBuilder()
        for (b in bytes) {
            val hex = Integer.toHexString(0xFF and b.toInt())
            if (hex.length == 1) {
                sb.append('0')
            }
            sb.append(hex)
        }
        return sb.toString()
    }

    // 디스크 캐시에서 비트맵 가져오기
    fun get(key: String): Bitmap? {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var snapshot: DiskLruCache.Snapshot? = null
            return try {
                snapshot = diskLruCache?.get(safeKey)
                snapshot?.getInputStream(0)?.use { inputStream ->
                    BitmapFactory.decodeStream(inputStream)
                }
            } catch (e: IOException) {
                e.printStackTrace()
                null
            } finally {
                snapshot?.close()
            }
        }
    }

    // 디스크 캐시에 비트맵 설정하기
    fun set(key: String, bitmap: Bitmap) {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var editor: DiskLruCache.Editor? = null
            try {
                editor = diskLruCache?.edit(safeKey)
                if (editor != null) {
                    editor.newOutputStream(0).use { outputStream ->
                        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)
                        editor.commit()
                    }
                } else {
                    diskLruCache?.flush() // editor가 null이면 flush 시도
                }
            } catch (e: IOException) {
                e.printStackTrace()
                try {
                    editor?.abort()
                } catch (ignored: IOException) {}
            }
        }
    }
}
```

이 클래스는 다음을 보장합니다.

* 디스크 안전한 SHA-1 기반 파일 이름 생성
* 안전한 I/O 작업
* 디스크 캐시에 중복으로 데이터를 쓰는 행위 방지

다음으로, Jetpack WorkManager의 CoroutineWorker를 사용하여 메인 스레드 외부에서 디스크 캐싱을 수행하고 메모리 및 디스크 전략을 안전하게 결합합니다.

```kotlin
import androidx.work.*
import android.content.Context
import android.graphics.Bitmap
// DiskCacheManager 및 LruCacheManager 필요

class BitmapWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    // DiskCacheManager 인스턴스는 싱글톤 또는 의존성 주입으로 관리해야 합니다.
    private val diskCacheManager = DiskCacheManager(context)

    override suspend fun doWork(): Result {
        val key = inputData.getString("imageKey") ?: return Result.failure()
        val resId = inputData.getInt("resId", -1)
        if (resId == -1) return Result.failure()

        // 메모리 캐시 먼저 확인
        LruCacheManager.memoryCache.get(key)?.let {
            // 메모리 캐시에 이미 있으면 성공
            return Result.success()
        }

        // 디스크 캐시 확인
        diskCacheManager.get(key)?.let { bitmapFromDisk ->
            // 디스크 캐시에 있으면 메모리 캐시에 추가하고 성공
            LruCacheManager.memoryCache.put(key, bitmapFromDisk)
            return Result.success()
        }

        // 캐시에 없으면 디코딩 및 캐싱
        val bitmap = decodeSampledBitmapFromResource(
            applicationContext.resources,
            resId,
            reqWidth = 100, // 필요한 크기 지정
            reqHeight = 100 // 필요한 크기 지정
        )

        // 비트맵을 메모리 및 디스크 캐시에 추가
        return try {
            bitmap?.let {
                addBitmapToCache(diskCacheManager, key, it)
                Result.success()
            } ?: Result.failure() // 디코딩 실패
        } catch (e: Exception) {
            Result.failure()
        }
    }

    private fun addBitmapToCache(diskCacheManager: DiskCacheManager, key: String, bitmap: Bitmap) {
        // 메모리 캐시에 추가 (존재하지 않는 경우)
        if (LruCacheManager.memoryCache.get(key) == null) {
            LruCacheManager.memoryCache.put(key, bitmap)
        }

        // 디스크 캐시에 추가 (존재하지 않는 경우)
        // DiskCacheManager.set 메서드 내부에서 중복 확인하므로 여기서는 바로 호출
        diskCacheManager.set(key, bitmap)
    }

    // decodeSampledBitmapFromResource 함수 구현 필요 (Q45 예제 참조)
    private fun decodeSampledBitmapFromResource(res: Resources, resId: Int, reqWidth: Int, reqHeight: Int): Bitmap? {
        // ... (Q45의 함수 구현) ...
        return null // 실제 구현 필요
    }
}
```

위의 WorkManager는 다음을 수행합니다.

* 가능하면 디스크 캐시에서 읽습니다.
* 디코딩으로 대체합니다.
* 결과를 메모리 및 디스크 캐시 모두에 저장합니다.
* 코루틴을 활용하여 메인 스레드 외부에서 안전하게 실행합니다.

#### 요약

- 안드로이드에서 큰 Bitmap을 효율적으로 캐시하려면 빠른 최근에 접근했던 메모리 캐싱을 위해 LruCache를 사용하고, 앱 세션을 넘어 Bitmap을 유지하기 위해 DiskLruCache를 사용합니다.
- 두 전략을 하이브리드 형태로 결합하고 구성 변경 시 메모리 캐시를 유지하여 원활한 경험을 제공합니다.
- WorkManager를 사용한 적절한 초기화 및 백그라운드 작업을 통해 큰 비트맵으로 작업할 때 앱 성능과 사용자 경험을 향상시킬 수 있습니다.
