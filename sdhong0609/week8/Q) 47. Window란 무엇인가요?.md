## Q) 47. Window란 무엇인가요?

- Window는 화면에 표시되는 Activity 또는 다른 UI 컴포넌트의 모든 뷰를 담는 컨테이너
- View 계층 구조의 최상위 요소, 애플리케이션 UI와 디스플레이 간의 다리 역할
- 모든 Activity, Dialog, 또는 Toast는 Window 객체에 연결되어 있음

### Window의 주요 특징

Window 클래스는 다음과 같은 여러 주요 기능을 제공합니다.

1. DecorView
   1. Window는 계층 구조의 루트 뷰 역할을 하는 DecorView를 포함
   2. 일반적으로 상태 표시줄(status bar), 내비게이션 바(navigation bar) 및 앱의 콘텐츠 영역을 포함
2. 레이아웃 매개변수: 크기, 위치, 가시성과 같은 레이아웃 매개변수를 사용하여 뷰가 어떻게 정렬되고 표시되는지 정의
3. 입력 처리: 입력 이벤트(가령, 터치 제스처, 키 누름)를 처리하고 이를 적절한 뷰로 전달
4. 애니메이션 및 전환: 화면 열기, 닫기 또는 화면 간 전환을 위한 애니메이션을 지원
5. 시스템 UI 처리: 상태 표시줄 및 내비게이션 바와 같은 시스템 UI 요소를 표시하거나 숨길 수 있음

### Window 관리

- Window는 윈도우 추가, 제거 또는 업데이트를 담당하는 시스템 서비스인 WindowManager에 의해 관리됩니다.
- 이를 통해 다양한 윈도우(가령, 앱 윈도우, 시스템 다이얼로그, 알림)가 기기에서 올바르게 공존하고 상호 작용할 수 있습니다.

### Window의 사용 사례

1. Activity Window 커스텀: getWindow() 메서드를 사용하여 Activity의 윈도우 동작을 수정할 수 있습니다.
   가령, 상태 표시줄을 숨기거나 또는 배경색상을 변경할 수 있습니다.

```kotlin
// 전체 화면 모드 설정 (상태 표시줄 숨김)
window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_FULLSCREEN
// 배경을 검은색으로 설정
window.setBackgroundDrawable(ColorDrawable(Color.BLACK))
```

2. Dialog 생성: Dialog는 새로운 윈도우를 사용하여 그 위에 구현되므로 다른 UI 요소 위에 떠 있을 수 있습니다.
3. 오버레이 사용: TYPE\_APPLICATION\_OVERLAY를 통해 시스템 수준 기능이나 헤드업 알림과 같은 오버레이를 만드는 데 Window를 사용할 수 있습니다.
4. 멀티 윈도우 모드 처리: 안드로이드는 분할 화면이나 PIP(Picture-in-Picture) 모드와 같은 기능을 활성화하기 위해 멀티 윈도우를 지원합니다.

### 💡 Pro Tips for Mastery: WindowManager란 무엇인가요?

- WindowManager는 화면에서 윈도우의 배치, 크기 및 모양을 관리하는 안드로이드 시스템 서비스
- 애플리케이션과 안드로이드 시스템 간의 윈도우 관리 인터페이스 역할을 하며, 앱이 윈도우를 생성, 수정 또는 제거할 수 있도록 한다.
- 안드로이드의 윈도우는 전체 화면 Activity부터 플로팅 오버레이까지 무엇이든 될 수 있습니다.

#### WindowManager의 주요 책임

- WindowManager는 시스템의 윈도우 계층 구조를 관리하는 역할
- 윈도우가 z-순서(레이어링) 및 다른 시스템 윈도우와의 상호 작용에 따라 올바르게 표시되도록 보장
- 예를 들어, 윈도우의 포커스 변경, 터치 이벤트 및 애니메이션을 처리

#### 일반적인 사용 사례

* 커스텀 View 추가: WindowManager를 사용하여 플로팅 위젯이나 시스템 오버레이와 같이 앱의 표준 Activity 외부에 커스텀 뷰를 표시할 수 있습니다.
* 기존 Window 수정: 애플리케이션은 크기 조절, 위치 변경 또는 투명도 변경과 같이 기존 윈도우의 속성을 업데이트할 수 있습니다.
* Window 제거: removeView() 메서드를 사용하여 프로그래밍 방식으로 윈도우를 제거할 수 있습니다.

#### WindowManager 작업하기

- WindowManager 서비스는 Context.getSystemService(Context.WINDOW\_SERVICE)를 통해 접근합니다.
- 아래는 WindowManager를 사용하여 화면에 플로팅 뷰를 추가하는 예시입니다.

```kotlin
val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager

val floatingView = LayoutInflater.from(context).inflate(R.layout.floating_view, null)

val params = WindowManager.LayoutParams(
    WindowManager.LayoutParams.WRAP_CONTENT, // 너비
    WindowManager.LayoutParams.WRAP_CONTENT, // 높이
    // Android 8.0 (API 26)이상에서는 TYPE_APPLICATION_OVERLAY, 이전 버전에서는 TYPE_PHONE 등 사용
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
    } else {
        WindowManager.LayoutParams.TYPE_PHONE
    },
    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, // 윈도우 플래그 (포커스 안 받음)
    PixelFormat.TRANSLUCENT // 픽셀 형식 (투명 배경 허용)
)

// 초기 위치 설정 (예: 화면 좌상단)
params.gravity = Gravity.TOP or Gravity.START
params.x = 0
params.y = 0

// 윈도우에 뷰 추가
windowManager.addView(floatingView, params)

// ... 추후에 플로팅 뷰가 더 사용되지 않을 때 제거 ...
// windowManager.removeView(floatingView)
```

위의 예제에서 아래와 같은 WindowManager.LayoutParams 속성들이 사용되었습니다.

* TYPE\_APPLICATION\_OVERLAY는 뷰가 다른 앱 위에 표시되도록 허용합니다. (권한 필요)
* FLAG\_NOT\_FOCUSABLE과 같은 플래그는 달리 지정하지 않는 한 윈도우가 사용자 입력과 상호 작용하지 않도록 합니다.

#### 제한 사항 및 권한

- 시스템 오버레이와 같은 특정 유형의 윈도우에는 SYSTEM\_ALERT\_WINDOW와 같은 특별한 사용자 권한이 필요
- 안드로이드 8.0 (API 레벨 26)부터 시스템은 보안상의 이유로 오버레이 윈도우에 대해 더 엄격한 제한을 부과

### 💡 Pro Tips for Mastery: PopupWindow란 무엇인가요?

- PopupWindow는 기존 레이아웃 위에 떠 있는 팝업 뷰를 표시하는 데 사용되는 UI 컴포넌트
- 일반적으로 화면을 덮고 해제하기 위해 사용자 상호 작용이 필요한 Dialog와 달리, PopupWindow는 더 유연하며 화면의 특정 위치에 배치될 수 있으며, 메뉴나 툴팁과 같은 임시 또는 상황별 UI 요소에 자주 사용됩니다.
- 다음은 PopupWindow의 특징입니다.
  * 레아이웃 위에 존재하는 어떠한 뷰든 해당 뷰 위에 콘텐츠를 표시할 수 있습니다.
  * 팝업 외 영역 화면을 어둡게 하거나 사용자 인터렉션을 차단할 필요가 없는 시나리오에서 팝업 뒤의 다른 UI 컴포넌트와 상호 작용할 수 있습니다.
  * 커스텀 레이아웃, 애니메이션 및 해제 동작을 구현할 수 있습니다.
  * 원활한 사용자 경험을 위해 터치 기반 해제 및 포커스 제어를 지원합니다.

아래 예제 코드와 같이 PopupWindow를 생성하고 화면에 노출할 수 있습니다.

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

         // 팝업을 위한 커스텀 레이아웃 인플레이트
         val popupView = layoutInflater.inflate(R.layout.popup_layout, null)

        // PopupWindow 생성
        val popupWindow = PopupWindow(
            popupView,
            ViewGroup.LayoutParams.WRAP_CONTENT, // 너비
            ViewGroup.LayoutParams.WRAP_CONTENT, // 높이
            true // 포커스 가능하게 설정 (외부 클릭 시 닫기 위해 필요)
        )

        // 팝업 배경 설정 (외부 클릭 감지를 위해 필요)
        popupWindow.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
        // 팝업 외부 터치 가능하게 설정
        popupWindow.isOutsideTouchable = true

        // 팝업 외부 클릭 시 닫기 (Focusable이 true일 때 작동)
        // popupView.setOnTouchListener는 팝업 내부 터치에만 해당됩니다.
        // 외부 클릭 처리는 PopupWindow 속성으로 합니다.

        val button = findViewById<Button>(R.id.button)
        button.setOnClickListener { anchorView -> // 클릭된 뷰(버튼)를 anchorView로 사용
            // 버튼 아래에 PopupWindow 표시
            popupWindow.showAsDropDown(anchorView)
        }
    }
}
```

💡 Additional Tips: PopupWindow는 Window를 상속하고 있을 것 같지만, PopupWindow라는 독립적인 클래스로서 존재하고, 내부에서는 WindowManager를 통해 Window를 화면에 추가하고 제거합니다.
