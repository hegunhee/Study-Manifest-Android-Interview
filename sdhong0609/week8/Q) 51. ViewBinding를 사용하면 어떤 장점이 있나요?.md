## Q) 51. ViewBinding를 사용하면 어떤 장점이 있나요?

[ViewBinding](https://developer.android.com/topic/libraries/view-binding)은 레이아웃의 뷰와 상호 작용하는 프로세스를 단순화하기 위해 안드로이드에서 도입된 기능

### ViewBinding 작동 방식
* 프로젝트에서 ViewBinding을 활성화하면 안드로이드는 각 XML 레이아웃 파일에 대한 바인딩 클래스를 생성
* 생성된 바인딩 클래스의 이름은 레이아웃 파일 이름에서 파생되며, 각 밑줄(_)은 카멜 케이스(camel case)로 변환되고 이름 끝에 Binding이 추가됩니다.
* 예를 들어, 레이아웃 파일 이름이 activity_main.xml이면 생성된 바인딩 클래스는 ActivityMainBinding이 됩니다.

바인딩 클래스에는 **레이아웃의 모든 뷰에 대한 참조가 포함되어 있어** 캐스팅하거나 findViewById()를 호출할 필요 없이 직접 접근할 수 있습니다.

```kotlin
// Activity에서의 사용 예제
class MainActivity : AppCompatActivity() {
    // 바인딩 클래스 인스턴스 선언
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 레이아웃 인플레이트 및 바인딩 클래스 초기화
        binding = ActivityMainBinding.inflate(layoutInflater)
        // 루트 뷰를 액티비티의 콘텐츠 뷰로 설정
        setContentView(binding.root)

        // 바인딩 객체를 통해 뷰에 직접 접근
        binding.textView.text = "Hello, ViewBinding!"
        binding.button.setOnClickListener { /* 클릭 리스너 로직 */ }
    }
}
```

inflate() 메서드는 바인딩 클래스의 인스턴스를 생성하는 데 사용되고, binding.root는 레이아웃을 설정하기 위해 setContentView()에 전달됩니다.

### ViewBinding의 장점

* **타입 안전성(Type Safety)**: 캐스팅할 필요 없이 뷰에 직접 접근하여 타입 불일치로 인한 런타임 오류를 제거합니다.
* **더 깔끔한 코드**: findViewById()를 호출할 필요가 없어지고 보일러 플레이트 코드가 줄어듭니다.
* **Null 안전성(Null Safety)**: nullable 타입의 뷰를 자동으로 처리하여 선택적 UI 컴포넌트와 상호 작용할 때 더 안전한 코드를 보장합니다.
* **성능**: DataBinding과 달리 ViewBinding은 바인딩 표현식이나 추가 XML 파싱을 사용하지 않으므로 런타임 오버헤드가 최소화됩니다.

### DataBinding과의 비교

- DataBinding은 바인딩 표현식 및 양방향 데이터 바인딩과 같은 더 많은 기능을 제공하지만 더 복잡하고 런타임 오버헤드를 유발
- 반면에 ViewBinding은 순수하게 뷰 상호 작용 단순화에 중점을 두며 성능 면에서 더 가볍습니다.
- LiveData나 Flow 등을 바인딩하여 데이터를 직접적으로 결합하는 등과 같은 기능이 필요하지 않은 경우 이상적

### ViewBinding 활성화하기

```kotlin
// build.gradle (app 수준)
android {
    ...
    buildFeatures {
        viewBinding = true
    }
}
```
ViewBinding이 활성화되면 프로젝트의 모든 XML 레이아웃에 대해 바인딩 클래스가 자동으로 생성됩니다.

💡 **Additional Tips**: ViewBinding이 구글에 의해서 공식적으로 지원되기 전에는, findViewById를 사용하지 않고 annotation processing을 활용한 의존성 주입 (dependency injection)을 통해 필드에 View 인스턴스를 주입하여 타입 안정성을 보장하는 형태의 라이브러리 [ButterKnife](https://github.com/JakeWharton/butterknife)가 사용되었습니다.
현재의 JakeWharton을 존재하게 만들었다고 해도 과언이 아닌 ButterKnife는 한때 안드로이드 생태계에서 모르는 사람이 없을 정도로 많이 사용되었으며, 안드로이드 생태계에 많은 변화와 영감을 준 오픈 소스 라이브러리입니다.
현재는 ViewBinding이 구글에 의해 공식 지원되면서 ButterKnife는 deprecated 되었지만, 당시는 상당히 창의적인 아이디어였기에 많은 인기를 끌었고, 의존성 주입에 대해 견고한 학습을 원하시는 분들은 여전히 소스 코드를 탐색하며 학습해 볼 만한 가치가 있습니다.
