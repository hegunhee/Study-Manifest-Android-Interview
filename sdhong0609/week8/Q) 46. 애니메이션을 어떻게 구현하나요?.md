## Q) 46. 애니메이션을 어떻게 구현하나요?

### View Property Animations

- View Property Animations는 alpha, translationX, translationY, rotation, scaleX와 같은 View 객체의 속성을 애니메이션화할 수 있습니다.
- 간단한 뷰에 간단한 변화를 줄 때 이상적

```kotlin
val view: View = findViewById(R.id.my_view)
view.animate()
    .alpha(0.5f)
    .translationX(100f)
    .setDuration(500) // 지속 시간 설정
    .setInterpolator(AccelerateDecelerateInterpolator()) // 인터폴레이터 설정 (선택 사항)
    .start()
```

### ObjectAnimator

- ObjectAnimator는 View 객체뿐만 아니라 setter 메서드가 있는 모든 객체의 속성을 애니메이션화할 수 있습니다.
- 커스텀 속성을 애니메이션화하는 데 더 큰 유연성 제공

```kotlin
val animator = ObjectAnimator.ofFloat(view, "translationY", 0f, 300f)
animator.duration = 500
animator.interpolator = OvershootInterpolator() // 인터폴레이터 설정 (선택 사항)
animator.start()
```

### AnimatorSet

AnimatorSet은 여러 애니메이션을 순차적으로 또는 동시에 실행하도록 결합하여 복잡한 애니메이션을 조정하는 데 적합합니다.

```kotlin
val fadeAnimator = ObjectAnimator.ofFloat(view, "alpha", 1f, 0f)
val moveAnimator = ObjectAnimator.ofFloat(view, "translationX", 0f, 200f)

val animatorSet = AnimatorSet()
// 순차적으로 재생: fadeAnimator 실행 후 moveAnimator 실행
animatorSet.playSequentially(fadeAnimator, moveAnimator)
// 동시에 재생: animatorSet.playTogether(fadeAnimator, moveAnimator)
// 복잡한 순서: animatorSet.play(fadeAnimator).before(moveAnimator) 등
animatorSet.duration = 1000 // 전체 세트 지속 시간 (개별 설정도 가능)
animatorSet.start()
```

### ValueAnimator

- ValueAnimator는 임의의 값 사이를 애니메이션화하는 방법을 제공하여 커스텀 가능하고 유연한 애니메이션을 구현할 수 있습니다.
- 인터폴레이터로 애니메이션 진행을 제어함으로써 너비, 높이, 알파 또는 기타 속성을 애니메이션화하는 등 광범위한 사용 사례에 적용할 수 있습니다.
- 특정 요구 사항에 맞는 정밀하고 동적인 애니메이션을 구현하는 데 적합

```kotlin
val valueAnimator = ValueAnimator.ofInt(0, 100) // 0에서 100까지 정수 값 변경
valueAnimator.duration = 500
valueAnimator.addUpdateListener { animation ->
  val animatedValue = animation.animatedValue as Int
  // animatedValue를 사용하여 UI 업데이트 (예: ProgressBar 너비 조정)
  val params = binding.progressbar.layoutParams
  params.width = ((screenSize / 100f) * animatedValue).toInt() // 실수 나눗셈 주의
  binding.progressbar.layoutParams = params
}
valueAnimator.start()
```

### XML 기반 View 애니메이션

- XML 기반 애니메이션은 단순성과 재사용성을 위해 리소스 파일에서 애니메이션 동작을 정의
- 위치, 크기 조절, 회전 또는 투명도를 조절하는 데 사용할 수 있습니다.

#### XML 예제: res/anim/slide_in.xml

```xml
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:fromXDelta="-100%"
    android:toXDelta="0%"
    android:duration="500"
    android:interpolator="@android:anim/accelerate_decelerate_interpolator" /> <!-- 인터폴레이터 추가 -->
```

#### 사용법

```kotlin
val animation = AnimationUtils.loadAnimation(this, R.anim.slide_in)
view.startAnimation(animation)
```

### MotionLayout

- MotionLayout은 복잡한 모션 및 레이아웃 애니메이션을 만들기 위한 안드로이드 전용 컴포넌트
- ConstraintLayout 위에 구축되었으며 XML을 사용하여 상태 간의 애니메이션 및 전환을 정의할 수 있습니다.

#### XML 예제: res/xml/motion\_scene.xml (경로 변경: res/xml/)

```xml
<MotionScene xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <ConstraintSet android:id="@+id/start">
        <!-- 시작 상태 제약 조건 정의 -->
        <Constraint android:id="@id/box">
            <Layout
                android:layout_width="100dp"
                android:layout_height="100dp"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintStart_toStartOf="parent" />
        </Constraint>
    </ConstraintSet>

    <ConstraintSet android:id="@+id/end">
        <!-- 종료 상태 제약 조건 정의 -->
         <Constraint android:id="@id/box">
            <Layout
                android:layout_width="100dp"
                android:layout_height="100dp"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintEnd_toEndOf="parent" />
        </Constraint>
    </ConstraintSet>

    <Transition
        app:constraintSetStart="@id/start"
        app:constraintSetEnd="@id/end"
        app:duration="500">
        <!-- 스와이프 또는 클릭 트리거 추가 -->
        <OnSwipe
            app:touchAnchorId="@id/box"
            app:touchAnchorSide="top"
            app:dragDirection="dragDown" />
    </Transition>

</MotionScene>
```

#### MotionLayout 사용 예시

```xml
<androidx.constraintlayout.motion.widget.MotionLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutDescription="@xml/motion_scene"> <!-- 모션 씬 파일 참조 -->

    <!-- 애니메이션될 뷰 -->
    <View
        android:id="@+id/box"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:background="@color/blue" />

</androidx.constraintlayout.motion.widget.MotionLayout>
```

MotionLayout은 전환 및 상태에 대한 정밀한 제어로 정교한 애니메이션을 만드는 데 적합합니다.

### Drawable 애니메이션

Drawable 애니메이션은 AnimationDrawable을 사용하여 프레임별 전환을 포함하며, 로딩 스피너와 같은 간단한 애니메이션을 만드는 데 적합합니다.

#### XML 예제: res/drawable/animation\_list.xml

```xml
<animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false">
    <item android:drawable="@drawable/frame1" android:duration="100" />
    <item android:drawable="@drawable/frame2" android:duration="100" />
    <!-- 더 많은 프레임 추가 -->
</animation-list>
```

#### 사용법

```kotlin
// ImageView의 배경으로 설정했다고 가정
val imageView: ImageView = findViewById(R.id.animated_image)
imageView.setBackgroundResource(R.drawable.animation_list) // 또는 setImageResource
val animationDrawable = imageView.background as AnimationDrawable // 또는 imageView.drawable
animationDrawable.start()
```

### 물리 기반 Animations

물리 기반 애니메이션은 실제 역학을 시뮬레이션합니다.
안드로이드는 자연스럽고 동적인 모션 효과를 만들기 위해 SpringAnimation 및 FlingAnimation API를 제공합니다.

```kotlin
val springAnimation = SpringAnimation(view, DynamicAnimation.TRANSLATION_Y, 0f) // 최종 위치 설정
springAnimation.spring = SpringForce() // SpringForce 객체 생성
    .setFinalPosition(0f) // 최종 위치 설정 (중복될 수 있음)
    .setStiffness(SpringForce.STIFFNESS_LOW) // 강성 설정
    .setDampingRatio(SpringForce.DAMPING_RATIO_HIGH_BOUNCY) // 감쇠 비율 설정
springAnimation.start()
```

### 요약

- 크기 조절이나 이동과 같은 간단한 변환에는 View Property Animations 및 ObjectAnimator가 효과적
- 더 복잡한 시나리오의 경우, AnimatorSet을 통해 여러 애니메이션을 조정할 수 있으며, ValueAnimator는 임의의 값을 애니메이션화하는 유연한 방법을 제공합니다.

### 💡 Pro Tips for Mastery: 인터폴레이터(interpolator)는 애니메이션과 어떻게 작동하나요?

- Interpolator는 시작 값과 끝 값 사이의 애니메이션 동작을 정의하는 데 사용
- 예를 들어, 애니메이션이 느리게 시작하여 속도를 높인 다음 멈추기 전에 느려지도록 만들 수 있습니다.
- 이는 선형 진행을 넘어 애니메이션 실행 방식을 유연하게 제어할 수 있도록 합니다.

안드로이드는 원하는 효과에 따라 사용할 수 있는 여러 인터폴레이터 API를 제공합니다.

1. LinearInterpolator: 가속이나 감속 없이 일정한 속도로 애니메이션합니다.
2. AccelerateInterpolator: 느리게 시작하여 점진적으로 속도를 높입니다.
3. DecelerateInterpolator: 빠르게 시작하여 끝으로 갈수록 느려집니다.
4. AccelerateDecelerateInterpolator: 부드러운 효과를 위해 가속과 감속을 모두 결합합니다.
5. BounceInterpolator: 스프링 애니메이션을 모방하여 애니메이션이 튕기는 것처럼 보이게 합니다.
6. OvershootInterpolator: 최종 값을 초과하여 애니메이션한 후 다시 정착합니다.

ObjectAnimator, ValueAnimator 또는 ViewPropertyAnimator와 같은 모든 애니메이션 객체에 인터폴레이터를 적용할 수 있습니다.
인터폴레이터는 setInterpolator() 메서드를 사용하여 설정됩니다.

다음은 ObjectAnimator에 인터폴레이터를 적용하는 예시입니다.
OvershootInterpolator는 뷰가 최종 위치에 도달하기 전에 목표 위치를 넘어 애니메이션하도록 만들어 동적인 효과를 생성합니다.

```kotlin
val animator = ObjectAnimator.ofFloat(view, "translationY", 0f, 500f)
animator.duration = 1000
animator.interpolator = OvershootInterpolator() // OvershootInterpolator 적용
animator.start()
```

Interpolator 인터페이스를 확장하고 getInterpolation() 메서드를 재정의하여 커스텀 인터폴레이터를 만들 수도 있습니다.
이렇게 하면 애니메이션 타이밍을 완전히 커스텀할 수 있습니다.
이 커스텀 인터폴레이터는 애니메이션이 느리게 시작하여 시간이 지남에 따라 제곱 가속되도록 진행시킵니다.

```kotlin
class CustomInterpolator : Interpolator {
    override fun getInterpolation(input: Float): Float {
        // 애니메이션 타이밍을 위한 커스텀 로직 (예: 제곱 가속)
        return input * input
    }
}

// 커스텀 인터폴레이터 사용
animator.interpolator = CustomInterpolator()
```

- 그래프 및 수식 등을 통해 각 인터폴레이터를 시각적으로 이해하고 싶다면 [Understanding Interpolators in Android](https://medium.com/mindorks/understanding-interpolators-in-android-ce4e8d1d71cd) 참조
