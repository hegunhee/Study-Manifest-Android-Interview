## Q) 57. Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?

* **핵심 개념**: 대규모 데이터 셋을 **페이지 단위**로 **점진 로딩**하여 **메모리 사용을 최소화**하고 **RecyclerView 성능**을 향상.
* **지원 소스**: **로컬(Room)**, **원격(API)**, **로컬+원격 결합(RemoteMediator)** 모두 지원.
* **기본 제공**: **데이터 캐싱**, **재시도 메커니즘**, **Flow/LiveData 연동**으로 **변경 관찰 → UI 업데이트** 자동화.

### Paging 라이브러리의 구성 요소

* **PagingData**: UI가 소비하는 **지연 로드 스트림**. RecyclerView와 결합해 **스크롤 위치에 따른 로딩**을 유도.
* **PagingSource**: **키(위치/ID 등)** 기반으로 **페이지 로드 방식** 정의. **load / getRefreshKey** 구현.
* **Pager**: **PagingSource ↔ PagingData** 중개자. **PagingConfig**(pageSize, placeholders, prefetchDistance 등)로 스트림 생성/수명 관리.
* **RemoteMediator**: **로컬 캐시 + 원격 API** 결합 시 **경계 조건/동기화 전략** 구현.

### Paging 라이브러리 작동 방식

* **스크롤 트리거 → 필요 페이지 로드 → UI 갱신**의 파이프라인을 자동 구성.
* **Flow/LiveData**로 노출된 **PagingData**를 **ViewModel**에서 `cachedIn(viewModelScope)`로 **구성 변경 시에도 유지**.
* 일반 워크플로우

   1. **PagingSource**로 로드 규칙 정의
   2. **Pager**로 `Flow<PagingData<…>>` 생성
   3. **ViewModel**에서 노출 → **PagingDataAdapter**로 전달해 렌더링

### Jetpack Paging 구현 예시

먼저, 네트워크에서 데이터를 가져오는 PagingSource를 다음과 같이 구현합니다.

```kotlin
class ExamplePagingSource(
    private val apiService: ApiService
) : PagingSource<Int, ExampleData>() { // Int: 페이지 키 타입, ExampleData: 로드할 데이터 타입

    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, ExampleData> {
        // 현재 페이지 키 가져오기 (null이면 첫 페이지)
        val page = params.key ?: 1
        return try {
            // API 호출하여 데이터 가져오기
            val response = apiService.getData(page, params.loadSize)
            // 로드 결과 반환 (성공 시 Page, 실패 시 Error)
            LoadResult.Page(
                data = response.items,
                prevKey = if (page == 1) null else page - 1, // 이전 페이지 키
                nextKey = if (response.items.isEmpty()) null else page + 1 // 다음 페이지 키
            )
        } catch (e: IOException) { // 네트워크 오류 처리
            LoadResult.Error(e)
        } catch (e: HttpException) { // HTTP 오류 처리
            LoadResult.Error(e)
        }
    }

    // 페이지 키를 정의하는 로직 (선택 사항, Paging 3에서는 load()에서 키 처리)
    override fun getRefreshKey(state: PagingState<Int, ExampleData>): Int? {
        // 가장 최근 접근한 위치(anchorPosition)를 기반으로 키 반환 시도
        return state.anchorPosition?.let { anchorPosition ->
            state.closestPageToPosition(anchorPosition)?.prevKey?.plus(1)
                ?: state.closestPageToPosition(anchorPosition)?.nextKey?.minus(1)
        }
    }
}
```

다음으로, PagingSource와 PagingData 간의 중개를 위해 리포지토리에서 Pager를 생성합니다.

```kotlin
class ExampleRepository(private val apiService: ApiService) {
    fun getExampleData(): Flow<PagingData<ExampleData>> {
        return Pager(
            // Paging 구성 설정 (페이지 크기 등)
            config = PagingConfig(
                pageSize = 20, // 각 페이지에 로드할 항목 수
                enablePlaceholders = false // 플레이스홀더 사용 여부
                // prefetchDistance = 5 // 미리 로드할 거리 (선택 사항)
                // initialLoadSize = 40 // 초기 로드 크기 (선택 사항)
            ),
            // PagingSource 인스턴스를 제공하는 팩토리
            pagingSourceFactory = { ExamplePagingSource(apiService) }
        ).flow // PagingData 스트림 반환
    }
}
```

다음으로, ViewModel에서 PagingData를 관찰할 수 있습니다.

```kotlin
class ExampleViewModel(private val repository: ExampleRepository) : ViewModel() {
    val exampleData: Flow<PagingData<ExampleData>> = repository.getExampleData()
        // viewModelScope 내에서 스트림 캐싱 (구성 변경 시 데이터 유지)
        .cachedIn(viewModelScope)
}
```

마지막으로, 아래 예제와 같이 PagingDataAdapter를 상속받는 커스텀 RecyclerView\.Adapter를 생성하여 RecyclerView에 데이터를 전달하고 랜더링할 수 있습니다.

```kotlin
class ExampleAdapter : PagingDataAdapter<ExampleData, ExampleAdapter.ExampleViewHolder>(DIFF_CALLBACK) {

    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {
        val item = getItem(position) // PagingDataAdapter에서 제공하는 getItem 사용
        // ViewHolder에 데이터 바인딩 (item이 null일 수 있음에 유의)
        item?.let { holder.bind(it) }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.example_item, parent, false)
        return ExampleViewHolder(view)
    }

    // ViewHolder 클래스 (예시)
    class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        // 뷰 바인딩 또는 findViewById 등
        fun bind(item: ExampleData) {
            // 아이템 데이터로 뷰 업데이트
        }
    }

    companion object {
        // DiffUtil 콜백 정의 (ListAdapter와 유사)
        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<ExampleData>() {
            override fun areItemsTheSame(oldItem: ExampleData, newItem: ExampleData): Boolean {
                return oldItem.id == newItem.id // 고유 ID 비교
            }

            override fun areContentsTheSame(oldItem: ExampleData, newItem: ExampleData): Boolean {
                return oldItem == newItem // 데이터 내용 비교
            }
        }
    }
}
```

### 요약

* **구성 요소 역할 분담**: `PagingSource`(로드 규칙) → `Pager`(구성/스트림 생성) → `PagingData`(UI 소비) → `PagingDataAdapter`(렌더링).
* **성능 최적화**: **페이지 크기/프리페치/플레이스홀더**로 **메모리·네트워크 효율** 극대화.
* **안정성**: **에러 처리/재시도**, **Flow/LiveData** 연동, `cachedIn(viewModelScope)`로 **구성 변경 대응**.
* **유즈케이스**: **무한 스크롤**, **페이지네이션 API**, **대용량 DB** 등에서 **표준화된 패턴**으로 생산성 향상.
