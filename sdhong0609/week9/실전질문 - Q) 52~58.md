### Q) 52. DataBinding의 동작 원리에 대해서 설명해주세요.

Q) DataBinding과 ViewBinding의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 선택하는 것이 좋을까요?

Q) MVVM 아키텍처에서 DataBinding은 어떤 역할을 하며, 안드로이드 개발에서 UI 로직과 비즈니스 로직을 분리하는 데 어떻게 활용할 수 있나요?

### Q) 53. LiveData에 대해서 설명해 주세요.

Q) LiveData는 생명주기 인식을 어떻게 보장하며, RxJava 또는 EventBus와 같은 전통적인 observable한 객체와 비교하여 어떤 이점을 제공하나요?

Q) LiveData에서 setValue()와 postValue()의 차이점은 무엇이며, 각각 언제 사용해야 하나요?

Q) LiveData의 한계는 무엇이며, 구성 변경 시 다시 트리거되지 않고 내비게이션 또는 토스트 메시지 표시와 같은 여러 UI 이벤트를 관찰해야 하는 경우에 어떻게 처리해야 하나요?

### Q) 54. Jetpack ViewModel에 대해 설명해 주세요.

Q) ViewModel은 구성 변경 시 데이터를 어떻게 유지하며, onSaveInstanceState()를 사용하여 상태를 저장하는 것과 어떻게 다른가요?

Q) ViewModelStoreOwner의 목적은 무엇이며, 동일한 Activity 내의 여러 Fragment 간에 ViewModel을 어떻게 공유할 수 있나요?

Q) UI 상태 관리를 위해 ViewModel 내에서 StateFlow 또는 LiveData를 사용하는 것의 장점과 잠재적인 단점은 무엇인가요?

### Q) 55. Jetpack Navigation 라이브러리란 무엇인가요?

Q) Jetpack Navigation 라이브러리는 백 스택을 어떻게 처리하고, NavController로 어떻게 백스택을 조작할 수 있나요?

Q) Safe Arguments란 무엇이며, Jetpack Navigation Component에서 목적 내비게이션 간 데이터를 전달할 때 타입 안전성을 어떻게 보장하나요?

### Q) 56. Dagger 2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.

Q) Dagger 2와 비교하여 의존성 Hilt는 주입을 어떻게 단순화하고, 안드로이드 애플리케이션에서 Hilt를 사용하는 것의 장점은 무엇인가요?

Q) Dagger와 Hilt에서 @Provides와 @Binds의 차이점은 무엇이고, 각각 언제 사용해야 하나요?

Q) Hilt에서 @Singleton, @ActivityScoped, @ViewModelScoped를 사용하면 내부적으로 스코핑이 어떻게 작동하는지 매커니즘을 설명하고, 해당 스코프가 사용되면 애플리케이션 내 의존성의 수명을 어떻게 관리하는지 설명해 주세요.

### Q) 57. Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?

Q) Paging 라이브러리는 데이터 로딩 중 오류를 어떻게 처리하며, 페이지네이션된 데이터 흐름에서 오류 처리 및 재시도 메커니즘을 구현하기 위해 사용해 본 전략은 무엇인가요?

### Q) 58. Baseline Profile은 앱의 성능에 어떤 이점을 가져다주나요?

Q) Baseline Profiles를 활용하면 Android Runtime (ART)이 앱 성능을 어떻게 개선시키고, 해당 접근 방식이 기존 Just-In-Time (JIT) 컴파일과 비교하여 가지는 성능적인 이점은 무엇인가요?
