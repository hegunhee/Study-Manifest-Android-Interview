## Q) 56. Dagger 2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.

- **요지**: 두 라이브러리는 모두 Google이 지원하는 **DI(Dependency Injection)** 솔루션으로, Dagger 2는 **정적 컴파일 타임 코드 생성** 기반, Hilt는 **Android 생명주기 통합**과 **보일러플레이트 감소**에 초점.
- **핵심 포인트**
   - Dagger 2: 유연하지만 **컴포넌트/모듈/스코프를 수동 구성**해야 하며 초기 설정이 다소 복잡.
   - Hilt: Dagger 위에 구축되어 **@HiltAndroidApp / @AndroidEntryPoint / @InstallIn** 등으로 **설정 단순화** 및 **생명주기 스코프 내장**.
   - 선택 기준: **안드로이드 앱 전반**은 Hilt가 생산적이며, **고도로 커스텀 DI 그래프**가 필요한 경우 Dagger 2를 고려.

### Dagger 2란?

- **정적 코드 생성** 기반 DI로 **성능/타입 안정성**이 높음.
- **@Module / @Provides / @Component / @Inject** 등으로 의존성 그래프를 구성하고 주입.

```kotlin
@Module
class NetworkModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://example.com")
            .build()
    }
}

@Component(modules = [NetworkModule::class])
interface AppComponent {
    // MainActivity에 의존성 주입
    fun inject(activity: MainActivity)
}

class MainActivity : AppCompatActivity() {
    // Retrofit 의존성 주입 요청
    @Inject
    lateinit var retrofit: Retrofit

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Dagger 컴포넌트 생성 및 주입 실행
        DaggerAppComponent.create().inject(this)
        // 이제 retrofit 인스턴스 사용 가능
    }
}
```

### Hilt란 무엇인가?

- Dagger 기반의 **Android 특화 DI 프레임워크**. Activity/Fragment/ViewModel 등 생명주기 컴포넌트에 **사전 정의 스코프** 제공.
- **보일러플레이트 제거** 및 **설정 단순화**에 강점.

```kotlin
@HiltAndroidApp // Hilt 사용을 위한 Application 클래스 어노테이션
class MyApplication : Application()

@AndroidEntryPoint // Hilt가 의존성을 주입할 Activity
class MainActivity : AppCompatActivity() {
    @Inject // Retrofit 의존성 주입 요청
    lateinit var retrofit: Retrofit

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // Hilt가 자동으로 의존성 주입 처리
    }
}

@Module
@InstallIn(SingletonComponent::class) // 모듈이 설치될 컴포넌트 지정 (앱 전체 범위)
object NetworkModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://example.com")
            .build()
    }
}
```

### Dagger 2와 Hilt의 주요 차이점

- **통합 방식**
   - Dagger 2: **컴포넌트/인젝터 수동 정의** 필요(보일러플레이트 多).
   - Hilt: **사전 정의 컴포넌트 + 스코프 어노테이션**으로 단순화.
- **생명주기 통합**
   - Dagger 2: 범용적이나 **생명주기 대응 수동 구성** 필요.
   - Hilt: Android 컴포넌트(ViewModel 등) **내장 지원**.
- **스코핑**
   - Dagger 2: **커스텀 스코프 수동 정의**.
   - Hilt: **@Singleton/@ActivityScoped/@FragmentScoped** 등 **표준 스코프 제공**.
- **코드 단순성**
   - Dagger 2: **세밀 제어** 가능하나 설정 복잡.
   - Hilt: **보일러플레이트 최소화**로 접근성↑.

### Hilt 및 Dagger 2에서 제공하는 어노테이션

Hilt는 Dagger 위에 구축되어 **동일/유사 어노테이션**을 공유하며, Android 특화 어노테이션을 추가 제공.

#### Dagger 2 기반의 어노테이션 (Dagger에서 제공하고 Hilt에서도 사용)

- **@Inject**: 생성자/필드/메서드 주입.
- **@Provides / @Module**: 제공 메서드/모듈 정의.
- **@Binds**: 인터페이스 → 구현 바인딩.
- **@Qualifier**: 동일 타입 다중 바인딩 구분.
- **@Scope / @Singleton**: 생명주기·싱글턴 범위 지정.
- **@Component / @Subcomponent**: DI 그래프 인터페이스와 하위 그래프 정의.

#### Hilt에 특화된 어노테이션

- **@HiltAndroidApp**: 앱 전역 그래프 부트스트랩.
- **@AndroidEntryPoint**: Android 컴포넌트를 **주입 대상**으로 표시.
- **@InstallIn**: 모듈을 어느 컴포넌트에 설치할지 지정.
- **@EntryPoint**: Hilt 비관리 영역에서 의존성에 접근하는 진입점.
- **@HiltViewModel**: ViewModel과 Hilt 통합(생성자에 **@Inject** 병행).
- **스코프**: **@ActivityRetainedScoped / @ViewModelScoped / @ActivityScoped / @FragmentScoped / @ViewScoped / @ServiceScoped** 등.

### 요약

- **Dagger 2**: **성능/유연성** 높음, **설정 복잡**. 대규모·정교한 그래프 커스텀에 적합.
- **Hilt**: **Android 통합/생산성** 뛰어남, **보일러플레이트 최소화**. 대부분의 Android 프로젝트에 적합.

### 💡 Pro Tips for Mastery: 수동으로 의존성 주입을 구현해 본 적이 있나요?

- 프레임워크 없이 **수동 DI**도 가능하나, **스코프/생명주기/리소스 정리** 등을 직접 관리해야 하므로 **보일러플레이트와 유지보수 비용**이 증가할 수 있음.
- 컴파일 타임 DI(Dagger/Hilt)는 **코드 생성 + 컴파일 타임 검증**으로 **순환 참조 등 오류 예방** 및 **런타임 성능**에 유리.


### 💡 Pro Tips for Mastery: Dagger 2 및 Hilt 이외에 알고 있는 DI 라이브러리가 있나요?

* **배경**: 안드로이드에서 보편적인 DI는 **Dagger 2/Hilt**이지만, **Koin**, **Anvil**처럼 **접근 방식이 다른 대안**도 존재.
* **핵심 요지**

   * **Koin**: 어노테이션/코드 생성 없이 **Kotlin DSL**로 구성하는 **경량 DI**. 빌드 속도·설정 단순성에 강점, **KMP** 대응.
   * **Anvil**: Dagger 기반의 **컴파일러 플러그인**으로 **보일러플레이트 감소**와 **빌드 성능** 개선. 기존 Dagger 대규모 코드베이스에 유리.

#### Koin: 가볍고 사용하기 쉬운 DI 라이브러리

* **특징 요약**

   * **어노테이션 처리 없음**: DI 구성을 **순수 Kotlin 코드**로 정의 → **빌드 시간 단축**.
   * **Kotlin 우선**: **Kotlin DSL**로 가독성 높은 모듈 선언, 진입 장벽 낮음.
   * **사용 편의성**: 초기 셋업이 빠르고 **소규모/프로토타이핑**에 적합.
   * **런타임 해결**: **동적 의존성** 시나리오에 유용(컴파일 타임 생성 無).
   * **KMP 대응**: Hilt/Dagger의 제한과 달리 **Kotlin Multiplatform** 프로젝트에 적합.
   * **버전 동향**: **Koin 4.0 Stable**로 기능 성숙도/신뢰성 강화(복잡한 사례 대응력 향상).
* **적합도**

   * **빌드 성능 우선**이거나 **작은 그래프/단순 구조**에서 실용적.
   * 매우 큰 그래프/복잡한 스코프 체계에서는 **수동 전파 비용**(런타임 결합) 고려 필요.

```kotlin
// 모듈 정의
val appModule = module {
    single { Repository() } // 싱글톤 정의
    factory { ViewModel(get()) } // 팩토리(매번 새 인스턴스) 정의, get()으로 의존성 주입
}

// Koin 시작 (Application 클래스 등에서)
startKoin {
    androidContext(this@MyApplication) // 안드로이드 컨텍스트 제공
    modules(appModule) // 모듈 등록
}

// 의존성 주입 (Activity, Fragment 등에서)
class MyActivity : AppCompatActivity() {
    // by inject() 델리게이트 사용
    val viewModel: ViewModel by inject()

    // 또는 get() 직접 사용
    // val repository: Repository = get()
}
```

#### Dagger 2 vs. Koin?

* **논점 정리(커뮤니티 논의 요지)**

   * **Dagger 2**: \*\*정식 DI(컴파일 타임 바인딩/전파)\*\*로 대규모 그래프에서 **자동 전파**와 **타입 안전성/성능** 제공. 초기 오버헤드는 있으나 규모가 커질수록 이점↑.
   * **Koin**: **서비스 로케이터에 가까운 런타임 해결** 측면이 있어, **대규모 그래프**에서는 바인딩 **수동 전파**가 누적되어 **보일러플레이트/유지보수 비용** 증가 가능.
* **실무 판단 가이드**

   * **작은 앱/토이 프로젝트**: Koin으로도 충분(심지어 “라이브러리 無” 선택 가능).
   * **수백 개 바인딩/깊은 그래프**: **Dagger/Hilt** 같은 **컴파일 타임 DI**가 일관성·안정성 면에서 유리.

#### Koin은 서비스 로케이터 패턴인가요?

* **Koin 팀 입장 요약**

   * Koin은 **DI와 서비스 로케이터**를 모두 지원하지만, **생성자 주입 중심의 DI**를 **강력 권장**(테스트 용이성·가독성↑).
   * **철학**: 일반적 케이스에서는 **단순성/빠른 셋업**에 초점, 필요 시 **복잡 구성**도 허용.
* **실무 팁**

   * Koin 사용 시에도 **Constructor Injection 우선** → 구조적 결합 감소·테스트성 향상.
   * **동적 주입이 많은 프로젝트**는 장점, **정교한 스코프/대규모 그래프**는 주의.

#### Anvil: Dagger 2에 기반한 컴파일러 플러그인

* **개요**: Block(구 Square) 제작. **Dagger 컴파일러 플러그인**으로 **모듈/팩토리 자동 생성**, **보일러플레이트 제거**, **빌드 속도 개선**.
* **장점**

   * **Dagger와 자연스러운 통합**: 기존 그래프를 유지하면서 **설정 단순화**.
   * **빌드 성능 최적화**: 어노테이션 프로세싱 범위를 **선택적으로 제한** 가능.
   * **대규모 Dagger 코드베이스**에 실용적(수천 모듈/다중 컴포넌트 환경).
* **Hilt와의 관계**

   * **Hilt 사용 중**이면 일반적으로 **Anvil 추가 필요 없음**(Hilt가 많은 보일러플레이트를 해결).
   * 단, **기존 Dagger 대규모 레거시**에서 **Hilt로 전환 불가/비용 과다** 시 **Anvil이 대안**.
* **적합도**

   * \*\*“이미 Dagger를 깊게 쓰는 조직”\*\*에서 **마이그레이션 부담 없이** 생산성·빌드 성능을 개선하려는 경우 최적.

```kotlin
// Anvil 어노테이션 사용 예시
import com.squareup.anvil.annotations.ContributesBinding
import com.squareup.anvil.annotations.ContributesTo
import javax.inject.Inject

interface Repository
interface AppScope // 커스텀 스코프

// Repository 구현 클래스에 ContributesBinding 적용
@ContributesBinding(AppScope::class)
class MyRepository @Inject constructor() : Repository

// 모듈 인터페이스에 ContributesTo 적용
@ContributesTo(AppScope::class)
interface AppModule {
    // Provides 메서드 정의 (Anvil이 구현 생성)
    fun provideSomeDependency(): SomeDependency
}
```

#### 올바른 라이브러리 선택하기

* **Koin**: **소규모/빠른 DI 셋업**, **KMP 필요**, **빌드 시간 민감**한 팀에 적합.
* **Anvil**: **대규모 Dagger 기반** 프로젝트에서 **보일러플레이트/빌드 시간**을 줄이고 싶을 때 선택.
* **요약 판단**: 신규 안드로이드 앱 전반은 **Hilt**가 기본값, \*\*특수 요구(대규모 Dagger 유지·KMP·초경량 셋업)\*\*에는 **Anvil/Koin** 고려.
