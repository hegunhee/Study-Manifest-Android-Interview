## Q) 53. LiveData에 대해서 설명해 주세요.

- [LiveData](https://developer.android.com/topic/libraries/architecture/livedata)는 안드로이드 Jetpack에서 제공하는 관찰 가능한 데이터 홀더 클래스이며, Activity, Fragment 같은 컴포넌트의 생명주기를 인식합니다.
- 컴포넌트가 활성 상태일 때만 데이터를 관찰하고 UI를 업데이트하도록 보장하며, 데이터 변경 시 UI를 자동으로 반응형으로 갱신할 수 있게 합니다.

LiveData는 아래와 같은 이점을 제공합니다.

1. 생명주기 인식 (Lifecycle Awareness): 활성 상태일 때만 데이터를 업데이트해 크래시와 메모리 누수를 줄입니다.
2. 자동 정리 (Automatic Cleanup): 생명주기가 소멸되면 관찰자가 자동으로 제거됩니다.
3. 관찰자 패턴 (Observer Pattern): 데이터 변경 시 UI가 자동으로 업데이트됩니다.
4. 스레드 안전성 (Thread Safety): 백그라운드 스레드에서도 안전하게 업데이트할 수 있습니다.

다음 예제는 UI 관련 데이터를 관리하기 위해 ViewModel에서 LiveData를 사용하는 방법을 보여줍니다.

```kotlin
// ViewModel
class MyViewModel : ViewModel() {
    // 내부 수정을 위한 MutableLiveData
    private val _data = MutableLiveData<String>()

    // 외부 수정을 방지하기 위해 LiveData로 노출
    val data: LiveData<String> get() = _data

    fun updateData(newValue: String) {
        // LiveData 값 업데이트
        _data.value = newValue
    }
}

// Fragment 또는 Activity
class MyFragment : Fragment() {
    private val viewModel: MyViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // LiveData 관찰
        viewModel.data.observe(viewLifecycleOwner) { updatedData ->
            // 새 데이터로 UI 업데이트
            textView.text = updatedData
        }
    }
}
```

이 예제에서 MyViewModel은 데이터를 보유하고 Fragment는 LiveData 객체를 관찰합니다.
updateData 함수가 호출될 때마다 UI가 자동으로 업데이트됩니다.

### MutableLiveData와 LiveData의 차이점

* MutableLiveData: `setValue()`나 `postValue()`로 데이터 수정 가능, 보통 ViewModel 내부에서만 사용해 외부 수정은 막음.
* LiveData: 읽기 전용으로 제공되어 외부에서 데이터 변경을 방지, 캡슐화 보장.

### LiveData 사용 사례

1. UI 상태 관리: 네트워크 응답이나 데이터베이스와 같은 소스의 데이터를 담는 컨테이너 역할, 데이터 변경 시 UI 자동 업데이트, 앱 상태와 동기화 보장.
2. 관찰자 패턴 구현: LiveData는 발행자(publisher) 역할을 하고 Observer 인터페이스 구현이 구독자(subscriber) 역할, 동적 UI나 데이터 기반 상호작용에 적합.
3. 일회성 이벤트 처리: 토스트, 화면 전환 등에 활용되며 [SingleLiveEvent](https://gist.github.com/skydoves/60f83bf678803e3b65742d541aba935f#file-singleliveevent-kt) 같은 커스텀 구현 필요.

### 💡 Additional Tips

#### 1. 잘못된 주장

* “StateFlow가 생겼으니 LiveData는 deprecated 대상” → ❌ 잘못된 주장
  Flow는 안드로이드 라이프사이클을 알지 못해서 잘못 구독하면 메모리 누수 위험 존재

#### 2. LiveData의 장점

* 구독 시 LifecycleOwner와 자동 결합
* 구독 해제를 직접 관리하지 않아도 수명주기에 맞게 안전하게 처리
* 특정 상황에서는 여전히 LiveData가 더 적절할 수 있음

#### 3. Flow 사용 논리 검증

* “안드로이드 의존성을 줄이기 위해 LiveData → Flow 마이그레이션” : 설득력 부족
* 네트워크/데이터/도메인 레이어 JVM 타입 모듈화한다고 해서 성능·구조적 이점이 입증된 바 없음

#### 4. 올바른 선택 기준

* Flow → 복잡한 데이터 가공, Flow의 장점을 활용할 수 있는 상황
* LiveData → 단순 UI 데이터 관찰 + 라이프사이클 안전성이 필요한 경우

#### 5. 참고 자료

* [Manuel Vivo - A safer way to collect flows from Android UIs](https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda)


### 💡 Pro Tips for Mastery: LiveData에서 setValue()와 postValue() 메서드의 차이점은 무엇인가요?

#### postValue()

* 비동기적으로 값 업데이트
* 백그라운드 스레드에서 호출 가능
* 메인 스레드 실행자(ArchTaskExecutor)를 통해 안전하게 전달
* 여러 번 호출되면 마지막 값만 유지

#### 동작 예시

```kotlin
liveData.postValue("a")
liveData.setValue("b")
```

* `"b"`가 즉시 반영됨
* 이후 메인 스레드가 postValue 작업 처리 시 `"a"`로 덮어씀




#### 1. setValue()

* 메인 스레드(UI 스레드)에서만 호출 가능
* 동기적으로 값 업데이트
* 즉시 관찰자에게 반영
* 백그라운드 스레드에서 호출 시 예외 발생

```kotlin
val liveData = MutableLiveData<String>()

fun updateOnMainThread() {
    if (Looper.myLooper() == Looper.getMainLooper()) {
        liveData.setValue("Updated Value") // 메인 스레드에서만 작동
    } else {
        // 메인 스레드가 아니면 예외 발생 가능성
        Log.e("LiveData", "Cannot call setValue on a background thread")
    }
}
```

#### 2. postValue()

* 비동기적으로 값 업데이트
* 백그라운드 스레드에서 호출 가능
* 메인 스레드 실행자(ArchTaskExecutor)를 통해 안전하게 전달하기 때문에 스레드 안전
* 여러 번 호출되면 마지막 값만 유지

```kotlin
val liveData = MutableLiveData<String>()

fun updateInBackground() {
    Thread {
        // 백그라운드 스레드에서 값 전달
        liveData.postValue("Updated Value") // 모든 스레드에서 호출 가능
    }.start()
}
```

```java
protected void postValue(T value) {
    boolean postTask;
    synchronized (mDataLock) {
        postTask = mPendingData == NOT_SET; // 이전에 전달된 작업이 없는지 확인
        mPendingData = value; // 보류 중인 데이터 업데이트
    }
    if (!postTask) {
        return; // 이미 전달된 작업이 있으면 반환
    }
    // 메인 스레드 실행자에 Runnable 실행
    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
}
```

이 메서드는 먼저 mDataLock에서 동기화하고 mPendingData를 업데이트하여 작업을 실행해야 하는지 확인합니다.
값이 이미 보류 중이면 중복 실행을 피합니다.<br>
그렇지 않으면 mPostValueRunnable을 ArchTaskExecutor를 통해 메인 스레드에서 실행되도록 예약하여 스레드 안전 업데이트를 보장합니다.
이를 통해 백그라운드 스레드에서 안전하게 업데이트를 게시하면서 스레드 안전성을 유지할 수 있습니다.

반면에 다음 코드가 메인 스레드에서 실행되면 어떤 상황이 발생할까요?

```kotlin
liveData.postValue("a")
liveData.setValue("b")
```

값 `"b"`가 즉시 반영되고, 나중에 메인 스레드가 전달 받은 작업을 처리할 때 `"b"`를 `"a"`로 덮어씁니다.<br>
이 동작은 postValue()가 업데이트를 비동기적으로 예약하는 반면 setValue()는 메인 스레드에서 동기적으로 값을 업데이트하기 때문에 발생합니다.

#### 주요 차이점

| Aspect                   | setValue()                 | postValue()                    |
|--------------------------|----------------------------|--------------------------------|
| Thread                   | 메인 스레드에서 호출해야 함            | 모든 스레드에서 호출 가능                 |
| Synchronous/Asynchronous | 값을 즉시 동기적으로 업데이트함          | 메인 스레드에서 업데이트를 비동기적으로 예약함      |
| Use Case                 | UI 업데이트 또는 메인 스레드에서 시작된 변경 | 백그라운드 스레드 업데이트 또는 비동기 작업       |
| Observer Notification    | 동일한 프레임 동안 관찰자를 즉시 트리거함    | 메인 스레드 처리 후 다음 프레임에서 관찰자를 트리거함 |

#### 일반적인 사용 패턴

* setValue() 사용: 사용자 상호 작용이나 생명주기 기반 이벤트와 같이 업데이트가 메인 스레드에서 직접 트리거될 때 적합합니다.
* postValue() 사용: 데이터베이스에서 데이터를 쿼리하거나, 네트워크 호출 수행 또는 그 외 장기적으로 실행되는 작업과 같이 백그라운드 스레드로 작업 중이면서 값을 업데이트 해야할 때 적합합니다.
