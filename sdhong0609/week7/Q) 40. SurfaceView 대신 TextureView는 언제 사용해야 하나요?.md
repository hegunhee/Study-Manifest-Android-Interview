## Q) 40. SurfaceView 대신 TextureView는 언제 사용해야 하나요?

### SurfaceView

- 별도의 스레드에서 렌더링되는 전용 드로잉 표면을 제공하는 특수한 View
- 시나리오 : 비디오 재생, 커스텀 그래픽 렌더링, 게임처럼 성능이 중요한 시나리오에 사용
- SurfaceHolder.Callback을 통해 표면 생성·변경·해제를 관리하고, 필요할 때 렌더링 시작/중지 가능
- 메인 UI 스레드 외부에 별도의 표면을 생성하여 다른 UI 작업을 차단하지 않고 효율적인 렌더링이 가능
- 연속적인 렌더링(예: 비디오 재생)에 효율적이지만, 크기 조절·회전 같은 변환에는 제한이 있어 UI 상호작용에는 덜 적합

```kotlin
class CustomSurfaceView(context: Context) : SurfaceView(context), SurfaceHolder.Callback {
    init {
        holder.addCallback(this)
    }

    override fun surfaceCreated(holder: SurfaceHolder) {
        // 여기서 렌더링 또는 드로잉 시작
    }

    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
        // 표면 변경 처리
    }

    override fun surfaceDestroyed(holder: SurfaceHolder) {
        // 여기서 렌더링 중지 또는 리소스 해제
    }
}
```

### TextureView

- 콘텐츠를 오프스크린으로 렌더링하면서 UI 계층 구조에 원할하게 통합 가능
- 회전, 크기 조절, 알파 블렌딩 등 변환과 애니메이션을 지원
- 메인 스레드에서 작동하므로 연속 렌더링 성능은 SurfaceView보다 떨어지지만, UI와의 상호작용은 더 유연함
- 시나리오 : 라이브 카메라 피드 표시, 비디오 렌더링 등

```kotlin
class CustomTextureView(context: Context, attrs: AttributeSet? = null) : TextureView(context, attrs),
    TextureView.SurfaceTextureListener {
    init {
        surfaceTextureListener = this
    }

    override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {
        // 렌더링 시작 또는 SurfaceTexture 사용
    }

    override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {
        // 표면 크기 변경 처리
    }

    override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {
        // 리소스 해제 또는 렌더링 중지
        return true // SurfaceTexture가 앱 프로세스에 의해 해제되었음을 나타냄
    }

    override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {
        // 표면 텍스처 업데이트 처리 (프레임 업데이트 등)
    }
}
```

### SurfaceView와 TextureView의 차이점

- SurfaceView: 별도 스레드에서 렌더링, 별도 Window 사용 → 성능 유리, 변환 및 애니메이션화에는 제약
- TextureView: 메인 스레드에서 렌더링, 동일 Window 사용 → 변환/애니메이션 가능, 성능은 다소 불리하여 고성능 렌더링에는 비효율적
