## Q) 41. RecyclerView는 내부적으로 어떻게 작동하나요?

- RecyclerView는 새로운 아이템 뷰를 매번 인플레이션하지 않고, 스크롤 시 기존 뷰를 재활용하여 대규모 데이터 셋을 효율적으로 표시하는 컴포넌트입니다.
- 이 과정에서 ViewHolder 패턴과 객체 풀(RecycledViewPool)과 유사한 메커니즘을 사용하여 성능과 메모리 사용을 최적화합니다.

### RecyclerView 내부 메커니즘의 핵심 개념

1. 뷰 재활용: 화면 밖으로 나간 뷰는 소멸되지 않고 풀에 저장, 이후 재사용되어 인플레이션 오버헤드를 피합니다.
2. ViewHolder 패턴: 뷰 참조를 저장해 바인딩 중 반복적인 findViewById() 호출을 방지하고 레이아웃 순회 및 뷰 조회를 줄여 성능을 개선합니다.
3. Adapter의 역할: 데이터 소스와 RecyclerView를 연결하는 다리 역할. onBindViewHolder()에서 재사용되는 뷰에 새 데이터를 바인딩합니다.
4. RecycledViewPool: 사용되지 않는 뷰가 저장되는 객체 풀 역할. 이를 통해 RecyclerView는 유사한 뷰 유형을 가진 여러 목록 또는 섹션에서 뷰를 재사용하여 메모리 사용량을 더욱 최적화
   가능합니다.

### 재활용 메커니즘

1. 스크롤 시, 화면 밖 뷰는 풀에 추가됩니다.
2. 새로운 아이템이 들어올 때, 풀에서 사용 가능한 뷰를 가져와 onBindViewHolder()로 데이터만 교체합니다.
3. 풀에 해당 뷰가 없으면 onCreateViewHolder()로 새 뷰를 인플레이션합니다.
4. 이를 통해 메모리 할당과 가비지 컬렉션을 최소화합니다.

다음은 기본적인 RecyclerView 구현 예시입니다.

```kotlin
class MyAdapter(private val dataList: List<String>) : RecyclerView.Adapter<MyAdapter.MyViewHolder>() {

    // ViewHolder 클래스: 아이템 뷰의 참조를 저장
    class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val textView: TextView = itemView.findViewById(R.id.textView)
    }

    // ViewHolder 생성: 새 뷰 인플레이션
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return MyViewHolder(view)
    }

    // ViewHolder에 데이터 바인딩
    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        holder.textView.text = dataList[position]
    }

    // 데이터 셋 크기 반환
    override fun getItemCount(): Int = dataList.size
}
```

### RecyclerView의 객체 풀 접근 방식의 장점

1. 향상된 성능: 인플레이션 횟수를 줄여 스크롤을 부드럽게 유지
2. 효율적인 메모리 관리: 객체 풀은 뷰를 재활용하여 메모리 할당을 최소화하고 빈번한 가비지 컬렉션을 방지
3. 커스텀: 뷰 유형별 최대 풀 크기를 설정해 상황에 맞는 최적화 가능

### 💡 Pro Tips for Mastery: 동일한 RecyclerView에서 다른 유형의 아이템을 어떻게 구현하나요?

#### 여러 아이템 유형 구현 단계

1. 아이템 유형 정의 : 각 아이템에 정수 상수로 유형 식별자 부여
2. getItemViewType() 재정의 : 각 아이템에 대해 적절한 유형 반환
3. 여러 ViewHolder 생성 : 유형별로 전용 ViewHolder 클래스 작성
4. onCreateViewHolder()에서 레이아웃 인플레이션 : 뷰 유형에 맞는 레이아웃 사용
5. onBindViewHolder()에서 데이터 바인딩 : 해당 ViewHolder에 맞는 데이터 연결

#### 예제: 여러 아이템 유형 구현하기

```kotlin
class MultiTypeAdapter(private val items: List<ListItem>) : RecyclerView.Adapter<RecyclerView.ViewHolder>() {

    // 아이템 유형 상수 정의
    companion object {
        const val TYPE_HEADER = 0
        const val TYPE_CONTENT = 1
    }

    // 위치에 따른 아이템 유형 반환
    override fun getItemViewType(position: Int): Int {
        return when (items[position]) {
            is ListItem.Header -> TYPE_HEADER
            is ListItem.Content -> TYPE_CONTENT
        }
    }

    // 뷰 유형에 따라 ViewHolder 생성
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            TYPE_HEADER -> {
                val view = LayoutInflater.from(parent.context).inflate(R.layout.item_header, parent, false)
                HeaderViewHolder(view)
            }
            TYPE_CONTENT -> {
                val view = LayoutInflater.from(parent.context).inflate(R.layout.item_content, parent, false)
                ContentViewHolder(view)
            }
            else -> throw IllegalArgumentException("Invalid view type")
        }
    }

    // ViewHolder에 데이터 바인딩
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is HeaderViewHolder -> holder.bind(items[position] as ListItem.Header)
            is ContentViewHolder -> holder.bind(items[position] as ListItem.Content)
        }
    }

    override fun getItemCount(): Int = items.size

    // 헤더 유형 ViewHolder
    class HeaderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val title: TextView = itemView.findViewById(R.id.headerTitle)

        fun bind(item: ListItem.Header) {
            title.text = item.title
        }
    }

    // 콘텐츠 유형 ViewHolder
    class ContentViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val content: TextView = itemView.findViewById(R.id.contentText)

        fun bind(item: ListItem.Content) {
            content.text = item.text
        }
    }
}
```

```kotlin
// 다양한 아이템 유형을 나타내는 데이터 클래스 (Sealed Class 사용)
sealed class ListItem {
    data class Header(val title: String) : ListItem()
    data class Content(val text: String) : ListItem()
}
```

#### 주요 참고 사항

1. 효율성 : ViewHolder 재사용으로 여러 아이템 유형을 성능 저하 없이 관리
2. 명확한 분리 : 유형별 레이아웃과 ViewHolder로 관심사 분리 및 코드 가독성 향상
3. 확장성 : 새 유형 추가 시 새로운 레이아웃, 새로운 ViewHolder 정의와 최소한의 로직 수정만 필요

### 💡 Pro Tips for Mastery: RecyclerView의 성능을 어떻게 향상시키나요?

[ListAdapter](https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter)
와 [DiffUtil](https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil)을 활용하면 RecyclerView 성능을 최적화할
수 있습니다.
DiffUtil은 두 목록 간 차이를 계산해 필요한 항목만 업데이트하며, 불필요한 notifyDataSetChanged() 호출을 피할 수 있습니다.
이를 통해 대규모 데이터 셋에서도 최소한의 업데이트만 수행해 성능 저하를 방지합니다.

#### DiffUtil 사용 단계

1. DiffUtil.ItemCallback 구현 또는 DiffUtil.Callback 상속 : 이전 목록과 새 목록의 차이 계산 정의
2. 어댑터에 새 데이터 제공 : ListAdapter의 submitList()나 커스텀 어댑터 메서드로 변경사항 반영
3. DiffUtil과 어댑터를 연동 : 업데이트를 자동으로 처리

#### 예제: RecyclerView와 DiffUtil 구현하기

```kotlin
class MyDiffUtilCallback : DiffUtil.ItemCallback<MyItem>() {
    override fun areItemsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {
        // 아이템이 동일한 데이터를 나타내는지 확인
        return oldItem.id == newItem.id
    }

    override fun areContentsTheSame(oldItem: MyItem, newItem: MyItem): Boolean {
        // 아이템의 내용이 동일한지 확인
        return oldItem == newItem
    }
}
```

```kotlin
class MyAdapter : ListAdapter<MyItem, MyViewHolder>(MyDiffUtilCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return MyViewHolder(view)
    }

    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}

class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    private val textView: TextView = itemView.findViewById(R.id.textView)

    fun bind(item: MyItem) {
        textView.text = item.name
    }
}
```

```kotlin
val adapter = MyAdapter()
recyclerView.adapter = adapter

val oldList = listOf(MyItem(1, "Old Item"), MyItem(2, "Another Item"))
val newList = listOf(MyItem(1, "Updated Item"), MyItem(3, "New Item"))

// 자동으로 아이템의 다른 부분을 계산하고 필요한 부분만 RecyclerView에서 업데이트
adapter.submitList(newList)
```

#### DiffUtil의 주요 이점

1. 향상된 성능: 전체 목록 대신 수정된 항목만 갱신
2. 세분화된 업데이트: 삽입, 삭제, 수정 개별적 처리에 따른 부드러운 애니메이션 지원
3. ListAdapter와의 원활한 통합: ListAdapter는 DiffUtil을 내부적으로 구현하고 있는 안드로이드 Jetpack 라이브러리의 어댑터로, 보일러플레이트 코드 감소

#### 고려 사항

1. 대규모 목록에 대한 오버헤드: 대규모 목록에서는 차이 계산 자체가 오버헤드가 될 수 있음. 상황에 맞게 사용 필요
2. 불변 데이터: 데이터 모델이 불변(immutable)인지 확인합니다. 가변 데이터는 DiffUtil이 변경 사항을 계산하려고 할 때 불일치를 유발할 수 있습니다.
