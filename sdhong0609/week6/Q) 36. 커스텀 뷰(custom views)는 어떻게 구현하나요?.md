## Q) 36. 커스텀 뷰(custom views)는 어떻게 구현하나요?

- 커스텀 뷰 구현은 여러 화면에서 재사용해야 하는 특정 스펙과 동작을 가진 UI 컴포넌트를 사용자 정의해야 할 때 필수적
- 커스텀 뷰를 생성하면 복잡한 UI 로직을 캡슐화하고 재사용성을 높이며 프로젝트 내 다른 레이어의 구조를 단순화할 수 있습니다.
- 안드로이드에서 기본적으로 제공하는 표준적인 UI 컴포넌트로 달성할 수 없는 디자인 요청사항을 구현해야 하는 경우 커스텀 뷰 개발이 필수적

### 1. 커스텀 View 클래스 생성하기

- 먼저, 기본 뷰 클래스(View, ImageView, TextView 등)를 확장하는 새 클래스를 정의합니다.
- 그런 다음 구현하려는 커스텀 동작에 따라 onDraw(), onMeasure(), onLayout()과 같은 필요한 생성자 및 메서드를 재정의합니다.

아래 예시는 onDraw() 메서드를 오버라이드하여 캔버스에 적접 빨간색 원을 그리는 커스텀 뷰 입니다.

```kotlin
class CustomCircleView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyle: Int = 0
) : View(context, attrs, defStyle) {

    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply { // Anti-aliasing 추가
        color = Color.RED
        style = Paint.Style.FILL
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // 중앙에 빨간색 원 그리기
        canvas.drawCircle(width / 2f, height / 2f, min(width, height) / 4f, paint) // 반지름 수정
    }
}
```

### 2. XML 레이아웃에서 커스텀 View 사용하기

- 커스텀 뷰 클래스를 생성한 후 전체 패키지 이름으로 XML 레이아웃 파일에서 직접 참조할 수 있습니다.
- 아래 예시와 같이 XML에서 정의할 수 있는 커스텀 속성(layout_width 등)을 커스텀 뷰에 전달할 수도 있습니다.

```xml

<com.example.myapp.ui.CustomCircleView
        android:id="@+id/customCircleView"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:layout_gravity="center"/>
```

### 3. 커스텀 속성 추가하기 (선택 사항)

- res/values 폴더에 새 attrs.xml 파일을 만들어 커스텀 속성을 정의할 수 있습니다.
- 이를 통해 XML 레이아웃에서 뷰의 속성을 커스텀할 수 있습니다.
- 가령, 원을 그리는 커스텀 뷰에서 원의 색상이나 반지름을 사용자 정의할 수 있도록 하여, 커스텀 뷰의 재사용성을 확장시킬 수 있습니다.

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="CustomCircleView">
        <attr name="circleColor" format="color"/>
        <attr name="circleRadius" format="dimension"/>
    </declare-styleable>
</resources>
```

커스텀 뷰 클래스에서 context.obtainStyledAttributes()를 사용하여 커스텀 속성 값(여기서는 circleColor, circleRadius)을 가져올 수 있습니다.

```kotlin
class CustomCircleView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0 // defStyleAttr로 이름 변경 권장
) : View(context, attrs, defStyleAttr) {

    var circleColor: Int = Color.RED
    var circleRadius: Float = 50f

    private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
        style = Paint.Style.FILL
    }

    init {
        attrs?.let {
            getAttrs(it, defStyleAttr)
        }
        paint.color = circleColor // 페인트 색상 초기화
    }

    private fun getAttrs(attrs: AttributeSet, defStyleAttr: Int) {
        val typedArray = context.obtainStyledAttributes(
            attrs, R.styleable.CustomCircleView, defStyleAttr, 0 // 기본 스타일 리소스 0
        )
        try {
            setTypeArray(typedArray)
        } finally {
            typedArray.recycle()
        }
    }

    private fun setTypeArray(typedArray: TypedArray) {
        circleColor = typedArray.getColor(R.styleable.CustomCircleView_circleColor, Color.RED)
        circleRadius = typedArray.getDimension(R.styleable.CustomCircleView_circleRadius, 50f)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        // onDraw에서 사용자 정의 된 반지름 값 사용
        canvas.drawCircle(width / 2f, height / 2f, circleRadius, paint)
    }

    // 필요하다면 onMeasure 재정의
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        val desiredWidth = (circleRadius * 2 + paddingLeft + paddingRight).toInt()
        val desiredHeight = (circleRadius * 2 + paddingTop + paddingBottom).toInt()

        val width = resolveSize(desiredWidth, widthMeasureSpec)
        val height = resolveSize(desiredHeight, heightMeasureSpec)
        setMeasuredDimension(width, height)
    }

    // circleColor 또는 circleRadius 변경 시 뷰를 다시 그리도록 하는 메서드
    fun setCircleProperties(color: Int, radius: Float) {
        this.circleColor = color
        this.circleRadius = radius
        paint.color = color
        requestLayout() // 뷰의 크기 변경 가능성이 있으므로 requestLayout 호출
        invalidate() // 다시 그리기 요청
    }
}
```

이제 XML 파일에서 아래와 같이 커스텀 속성을 사용할 수 있습니다.

```xml

<com.example.myapp.ui.CustomCircleView
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/customCircleView"
        android:layout_width="100dp"
        android:layout_height="100dp"
        app:circleColor="@color/blue"
        app:circleRadius="30dp"/>
```

### 4. 레이아웃 측정 처리하기 (선택 사항)

커스텀 뷰가 크기를 측정하는 방식을 수동적으로 처리하고 싶고, 특히 표준적인 뷰와 다르게 동작해야 하는 경우 onMeasure() 메서드를 재정의하여 구현할 수 있습니다.

```kotlin
override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    // 원하는 기본 크기 설정
    val desiredWidth = (paddingLeft + paddingRight + suggestedMinimumWidth).coerceAtLeast(200) // 예시 크기
    val desiredHeight = (paddingTop + paddingBottom + suggestedMinimumHeight).coerceAtLeast(200) // 예시 크기

    // MeasureSpec 모드와 크기를 기반으로 최종 크기 결정
    val width = resolveSize(desiredWidth, widthMeasureSpec)
    val height = resolveSize(desiredHeight, heightMeasureSpec)

    // 최종 측정된 크기 설정
    setMeasuredDimension(width, height)
}
```

### 💡 Additional Tips

커스텀 뷰 구축에 대한 이해를 높이려면 GitHub에서 다양한 예제와 실전 코드를 살펴보며 학습하실 수 있습니다.
이미 많은 안드로이드 프로젝트에서 사용되고 있는 오픈 소스 라이브러리인 [ElasticViews](https://github.com/skydoves/ElasticViews)
및 https://github.com/skydoves/ProgressView 등을 살펴보시면 커스텀 뷰 구현에 대한 실질적인 사례를 살펴보실 수 있습니다.
또는 [CircleImageView](https://github.com/hdodenhof/CircleImageView)를 살펴보실 수도 있습니다.

### 💡 Pro Tips for Mastery: 커스텀 뷰의 기본 생성자에서 @JvmOverloads를 사용할 때 왜 주의해야 하나요?

- Kotlin의 @JvmOverloads 어노테이션은 Kotlin 함수 또는 클래스에 대해 여러 오버로드된 메서드 또는 생성자를 자동으로 생성하여 Kotlin과 Java 간의 상호 운용성을 단순화하는 기능입니다.
- 이는 Java가 기본 인수(Default parameter)를 기본적으로 지원하지 않기 때문에 Kotlin의 기본 인수가 관련된 경우 특히 유용합니다.
- @JvmOverloads를 사용하면 Kotlin 컴파일러는 컴파일된 바이트코드에서 기본값을 가진 매개변수의 모든 가능한 조합을 나타내기 위해 여러 메서드 또는 생성자 시그니처를 컴파일 타임에 자동적으로
  생성합니다.
- 하지만 커스텀 뷰를 구현할 때 @JvmOverloads를 신중하게 사용하지 않으면 의도치 않게 기본 뷰 스타일을 재정의하여 커스텀 뷰의 의도된 스타일링이 손실될 수 있습니다.
- 이는 Button이나 TextView와 같이 미리 정의된 스타일이 있는 안드로이드 뷰를 확장하는 커스텀 뷰를 만들 때 특히 문제가 됩니다.

예를 들어, 커스텀 TextInputEditText를 구현할 때 다음과 같이 정의할 수 있습니다.

```kotlin
class ElasticTextInputEditText @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyle: Int = 0 // 여기서 defStyleAttr 대신 defStyle을 사용하고 기본값을 0으로 설정
) : TextInputEditText(context, attrs, defStyle) {
    ..
}
```

이 예제에서 ElasticTextInputEditText를 일반 TextInputEditText처럼 사용하면 예기치 않은 동작이나 스타일링에 잠재적인 손상이 발생할 수 있습니다.
이는 위 코드에서 볼 수 있듯이 defStyle 값이 0으로 재정의되어 커스텀 뷰가 의도한 스타일링을 잃을 수 있기 때문입니다.

View가 XML 파일에서 인플레이션될 때 두 매개변수 생성자(Context 및 AttributeSet)가 호출되고, 이는 다시 세 매개변수 생성자를 호출합니다.

```java
// @JvmOverloads가 생성한 두 매개변수 생성자 (내부적으로)
public ElasticTextInputEditText(Context context, @Nullable AttributeSet attrs) {
    this(context, attrs, 0); // defStyle에 0 전달
}
```

세 번째 매개변수인 defStyleAttr은 커스텀 구현에서 종종 0으로 설정하는 경우가 많습니다.
그러나 이 세 매개변수 생성자의
목적은 [안드로이드 문서](https://developer.android.com/reference/android/view/View#View(android.content.Context,%20android.util.AttributeSet,%20int))
에 다음과 같이 설명되어 있습니다.

***
XML에서 인플레이션을 수행하고 테마 속성에서 클래스별 기본 스타일을 적용합니다.
이 View 생성자를 사용하면 하위 클래스가 인플레이션될 때 자체 기본 스타일을 사용할 수 있습니다.
예를 들어, Button 클래스의 생성자는 이 버전의 상위 클래스 생성자를 호출하고 defStyleAttr에 R.attr.buttonStyle을 제공합니다.
이를 통해 테마의 버튼 스타일이 모든 기본 뷰 속성(특히 배경)뿐만 아니라 Button 클래스의 속성도 수정할 수 있습니다.
***

적절한 defStyleAttr 값(가령, ElasticTextInputEditText의 경우 R.attr.editTextStyle)을 생략하면 커스텀 뷰가 상속된 스타일 구성을 잃어 XML 인플레이션 중에 일관성
없거나 깨진 동작이 발생할 수 있습니다. (0으로 두면 테마의 기본 스타일이 적용되지 않아, 같은 앱 안에서도 UI 일관성이 깨질 수 있다.)

TextInputEditText의 내부 구현을 살펴보면 아래 코드에서 볼 수 있듯이 내부적으로 R.attr.editTextStyle을 defStyleAttr로 사용한다는 것을 알 수 있습니다.

```java
public class TextInputEditText extends AppCompatEditText {

    // ... 필드 정의 ...

    public TextInputEditText(@NonNull Context context) {
        this(context, null);
    }

    public TextInputEditText(@NonNull Context context, @Nullable AttributeSet attrs) {
        // 기본 스타일 속성으로 R.attr.editTextStyle 사용
        this(context, attrs, R.attr.editTextStyle);
    }

    public TextInputEditText(
            @NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        // ... 나머지 생성자 로직 ...
    }
}
```

- TextInputEditText의 구현에서 세 번째 매개변수(defStyleAttr)로 androidx.appcompat.R.attr.editTextStyle을 전달하는 것을 어떤 방법(AOSP를 서치하든,
  IDE에서 클래스를 타고 올라가든)으로든 알아야합니다.
- 이는 테마 스타일을 제공하는 AppCompat 라이브러리나 Android SDK에서 기본적으로 제공하는 여러 커스텀 뷰 마다 완전히 다른 스타일 값을 사용하고 있습니다.
- ElasticTextInputEditText 예시의 경우는 올바른 스타일링을 보장하기 위해 커스텀 뷰의 생성자에서 defStyleAttr 매개변수의 기본값으로 R.attr.editTextStyle을 설정하여
  수정할 수 있습니다.

```kotlin
class ElasticTextInputEditText @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    // 기본값으로 올바른 스타일 속성 참조
    defStyleAttr: Int = androidx.appcompat.R.attr.editTextStyle
) : TextInputEditText(context, attrs, defStyleAttr) {
    // Custom implementation
}
```

androidx.appcompat.R.attr.editTextStyle을 기본값으로 명시적으로 할당함으로써 커스텀 뷰가 XML 인플레이션 중에 예상되는 기본 스타일을 상속하여 원래 TextInputEditText의
동작과 일관성을 유지하도록 보장합니다.
