## Q) 35. ViewStub이란 무엇이고, 이를 사용하여 UI 성능을 최적화해 본 경험이 있나요?

- ViewStub은 명시적으로 필요할 때까지 레이아웃의 인플레이션을 지연시키는 데 사용되는 가볍고 보이지 않는 플레이스홀더 뷰
- 앱 생명주기 동안 지금 당장 필요하지 않은 뷰를 필요한 시기에 적절하게 인플레이션하여 오버헤드를 피함으로써 성능을 개선하는 데 사용됩니다.

### ViewStub의 주요 특징

1. 가벼움: ViewStub은 인플레이션될 때까지 레이아웃 공간을 차지하거나 리소스를 소비하지 않으므로 메모리 공간이 최소화된 매우 가벼운 뷰입니다.
2. 인플레이션 지연: ViewStub에 지정된 실제 레이아웃은 inflate() 메서드가 호출되거나 ViewStub이 보이게 될 때만 인플레이션됩니다.
3. 일회성: 한번 인플레이션되면 ViewStub은 뷰 계층 구조에서 인플레이션된 레이아웃으로 대체되며 재사용할 수 없습니다.

### ViewStub의 일반적인 사용 사례

1. 조건부 레이아웃: ViewStub은 오류 메시지, 진행률 표시줄 또는 선택적 UI 요소와 같이 조건부로 표시되는 레이아웃에 이상적입니다.
2. 초기 렌더링 시간 절감: 복잡하거나 리소스 집약적인 뷰의 인플레이션을 지연시킴으로써 ViewStub은 Activity 또는 Fragment의 초기 렌더링 시간을 개선하는 데 도움이 됩니다.
3. 동적 UI: 필요할 때만 화면에 동적으로 콘텐츠를 렌더링하는 데 사용될 수 있어 메모리 사용량을 최적화합니다.

### ViewStub 사용 방법

ViewStub은 인플레이션할 레이아웃 속성과 함께 XML 레이아웃에 정의할 수 있습니다.

```xml

<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

    <!-- Regular Views -->
    <TextView
            android:id="@+id/title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Main Content"/>

    <!-- Placeholder ViewStub -->
    <ViewStub
            android:id="@+id/viewStub"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout="@layout/optional_content"/>
</LinearLayout>
```

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val viewStub = findViewById<ViewStub>(R.id.viewStub)

        // 필요할 때 레이아웃 인플레이션
        val inflatedView: View? = try {
            viewStub.inflate() // 성공 시 inflatedView 반환, 실패 시 null 또는 예외
        } catch (e: IllegalStateException) {
            // 이미 인플레이트된 경우 findViewById 사용
            findViewById(viewStub.inflatedId)
        }

        // 인플레이션된 레이아웃의 뷰에 접근 (null 체크 필요)
        inflatedView?.let {
            val optionalTextView = it.findViewById<TextView>(R.id.optionalText)
            optionalTextView.text = "Inflated Content"
        }
    }
}
```

### ViewStub의 장점

1. 최적화된 성능: 늦게 초기화 해도 되는 뷰 생성을 지연시켜 메모리 사용량을 줄이고 초기 렌더링 성능을 개선합니다.
2. 쉬운 레이아웃 관리: 뷰를 수동으로 추가하거나 제거하지 않고도 UI 요소를 선택적으로 렌더링함으로써 쉽게 관리할 수 있습니다.
3. 쉬운 사용성: API 사용이 간단하고 XML 통합이 쉬워 개발자가 쉽게 활용할 수 있습니다.

### ViewStub의 한계

1. 일회성: 일단 인플레이션되면 ViewStub은 뷰 계층 구조에서 제거되며 재사용할 수 없습니다.
    - 레이아웃에 미리 넣어두지만, 실제 UI는 만들지 않고 있다가 필요할 때 inflate()를 호출하면 해당 위치에 실제 레이아웃을 넣습니다.
    - 이 때 ViewStub 객체 자체는 뷰 계층에서 사라지고, 대신에 inflate된 실제 View가 그 자리를 차지합니다.
2. 제한된 컨트롤: 플레이스홀더이므로 인플레이션될 때까지 사용자 상호 작용을 처리하거나 복잡한 작업을 수행할 수 없습니다.
